<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Interrupts</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.13.24"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
#button { display: inline-block; background-color: #FF9800; width: 50px; height: 50px; text-align: center; border-radius: 4px; position: fixed; bottom: 30px; right: 30px; transition: background-color .3s, opacity .5s, visibility .5s; opacity: 0; /*visibility: hidden;*/ z-index: 1000; } #button::after { content: "\f077"; font-family: FontAwesome; font-weight: normal; font-style: normal; font-size: 2em; line-height: 50px; color: #fff; } #button:hover { cursor: pointer; background-color: #333; } #button:active { background-color: #555; } #button.show { opacity: 1; visibility: visible; } #btn-back-to-top { position: fixed; bottom: 20px; right: 20px; display: none; } .to-top { background: white; position: fixed; bottom: 16px; right:32px; width:50px; height:50px; border-radius: 50%; border-color: white; display: flex; align-items: center; justify-content: center; font-size:32px; color:#1f1f1f; text-decoration: none; opacity: 0.5; pointer-events: auto; transition: all .4s; transform: rotate(270deg); } 
</style>
    </head>
    <body class="vscode-body vscode-light">
        <ul>
<li><a href="#interrupts">Interrupts</a>
<ul>
<li><a href="#interrupt-vs-exception">Interrupt vs Exception</a></li>
<li><a href="#procinterrupts">/proc/interrupts</a></li>
<li><a href="#interrupt-handler-and-interrupt-context">Interrupt handler and Interrupt context</a></li>
<li><a href="#top-halves-and-bottom-halves">Top Halves and Bottom Halves</a></li>
<li><a href="#bottom-half-mechnisms">Bottom half mechnisms</a>
<ul>
<li><a href="#softirq">softirq</a></li>
<li><a href="#tasklet">tasklet</a></li>
<li><a href="#work-queues">work queues</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#linux-interrupts">Linux Interrupts</a>
<ul>
<li><a href="#local-timer-interrupts">Local Timer Interrupts</a>
<ul>
<li><a href="#config_no_hz">CONFIG_NO_HZ</a></li>
<li><a href="#how-to-check">How to check:</a></li>
</ul>
</li>
<li><a href="#interprocessor-interrupts-ipi">Interprocessor interrupts (IPI)</a></li>
<li><a href="#non-maskable-interrupts-nmi">Non-maskable Interrupts (NMI)</a></li>
<li><a href="#system-management-interrupts-smi">System Management Interrupts (SMI)</a></li>
</ul>
</li>
<li><a href="#kernel-internals">Kernel Internals</a>
<ul>
<li><a href="#kernel-code-flow-for-calling-interrupt-handler">Kernel code flow for calling interrupt handler</a></li>
<li><a href="#registering-an-interrupt-handler">Registering an Interrupt Handler</a></li>
<li><a href="#an-interrupt-handler-example">An interrupt handler example</a></li>
<li><a href="#softirqs-kernel-interals">softirqs Kernel Interals</a></li>
<li><a href="#tasklets-kernel-interals">Tasklets Kernel Interals</a></li>
<li><a href="#ksoftirqd">ksoftirqd</a></li>
<li><a href="#work-queue-kernel-internals">Work Queue Kernel Internals</a></li>
</ul>
</li>
</ul>
<h1 id="interrupts">Interrupts</h1>
<p>An interrupt enable hardware to signal to the processor.</p>
<ul>
<li>hardware devices physically produced electronic signals
<ul>
<li>Different devices is associated with different interrupts by different interrupt numeric value, often called <em>interrupt request</em> (IRQ) lines.</li>
</ul>
</li>
<li>directed into input pins on an interrupt controller (PIC)
<ul>
<li>interrupt controller is a simple chip that multiplexes multiple interrupt lines into a single line to the processor.</li>
</ul>
</li>
<li>Upon receiving an interrupt, the interrupt controller sends a signal to the processor on CPU INTR pin.
<ul>
<li>the interrupt controller waits for CPU to acknowlege an interrupt before raising another interrupt.</li>
</ul>
</li>
<li>The processor detects this signal and interrupts its current execution to handle the interrupt.</li>
<li>The processor can then notify the kernel that an interrupt has occurred, and the kernel can handle the interrupt appropriately.
<ul>
<li><a href="#kernel-code-flow-for-calling-interrupt-handler">Refer to Kernel implemenation</a></li>
</ul>
</li>
</ul>
<p><img src="images/2022-02-09-10-17-16.png" alt=""></p>
<h2 id="interrupt-vs-exception">Interrupt vs Exception</h2>
<p>the kernel infrastructure for handling the two is similar.</p>
<ul>
<li>interrupts (hardware interrupts): asynchronous interrupts generated by hardware</li>
<li>exceptions (software interrupts): synchronous interrupts generated by the processor while executing instructions
<ul>
<li>Exception, programming error, eg: divide by zero</li>
<li>Faults, abnormal conditions, eg: page fault</li>
<li>Trap: eg. X86-32 system call (<code>int 0x80</code>): issue a software interrupt which traps into the kernel and causes execution of exception handler.</li>
</ul>
</li>
</ul>
<p>Interrupts can be divided to maskable interrupts and non-maskable interrupts.</p>
<ul>
<li>maskable:  can be ignored, signalled via INT pin</li>
<li><a href="#non-maskable-interrupts-nmi">non-maskable</a>:  cannot be ignored, signalled via NMI pin</li>
</ul>
<p>There are two sources for exceptions:</p>
<ul>
<li>processor detected
<ul>
<li>faults: A fault is a type of exception that is reported before the execution of the instruction and can be usually corrected. The saved EIP is the address of the instruction that caused the fault, so after the fault is corrected the program can re-execute the faulty instruction. (e.g page fault).</li>
<li>traps: A trap is a type of exception that is reported after the execution of the instruction in which the exception was detected. The saved EIP is the address of the instruction after the instuction that caused the trap. (e.g debug trap).</li>
<li>aborts: Aborts inform about hardware failures and invalid system tables and and abort handler has no choice but to force affected process to terminate</li>
</ul>
</li>
<li>programmed
<ul>
<li><code>INT n</code> : The <code>INT n</code> instruction permits interrupts to be generated by software.</li>
</ul>
</li>
</ul>
<p>The 80×86 microprocessors issue roughly 20 different exceptions.* The kernel must
provide a dedicated exception handler for each exception type.</p>
<ol start="0">
<li>“Divide error” (fault)
Raised when a program issues an integer division by 0.</li>
<li>“Debug” (trap or fault)
Raised when the TF flag of eflags is set (quite useful to implement single-step
execution of a debugged program) or when the address of an instruction or
operand falls within the range of an active debug register (see the section “Hardware
Context” in Chapter 3).</li>
<li>Not used
Reserved for nonmaskable interrupts (those that use the NMI pin).</li>
<li>“Breakpoint” (trap)
Caused by an int3 (breakpoint) instruction (usually inserted by a debugger).</li>
<li>“Overflow” (trap)
An into (check for overflow) instruction has been executed while the OF (overflow)
flag of eflags is set.</li>
<li>“Bounds check” (fault)
A bound (check on address bound) instruction is executed with the operand outside
of the valid address bounds.</li>
<li>“Invalid opcode” (fault)
The CPU execution unit has detected an invalid opcode (the part of the machine
instruction that determines the operation performed).</li>
<li>“Device not available” (fault)
An ESCAPE, MMX, or SSE/SSE2 instruction has been executed with the TS flag
of cr0 set (see the section “Saving and Loading the FPU, MMX, and XMM Registers”
in Chapter 3).</li>
<li>“Double fault” (abort)
Normally, when the CPU detects an exception while trying to call the handler
for a prior exception, the two exceptions can be handled serially. In a few cases,
however, the processor cannot handle them serially, so it raises this exception.</li>
<li>“Coprocessor segment overrun” (abort)
Problems with the external mathematical coprocessor (applies only to old 80386
microprocessors).</li>
<li>“Invalid TSS” (fault)
The CPU has attempted a context switch to a process having an invalid Task
State Segment.</li>
<li>“Segment not present” (fault)
A reference was made to a segment not present in memory (one in which the
Segment-Present flag of the Segment Descriptor was cleared).</li>
<li>“Stack segment fault” (fault)
The instruction attempted to exceed the stack segment limit, or the segment
identified by ss is not present in memory.</li>
<li>“General protection” (fault)
One of the protection rules in the protected mode of the 80×86 has been
violated.</li>
<li>“Page Fault” (fault)
The addressed page is not present in memory, the corresponding Page Table
entry is null, or a violation of the paging protection mechanism has occurred.</li>
<li>Reserved by Intel</li>
<li>“Floating-point error” (fault)
The floating-point unit integrated into the CPU chip has signaled an error condition,
such as numeric overflow or division by 0.*</li>
<li>“Alignment check” (fault)
The address of an operand is not correctly aligned (for instance, the address of a
long integer is not a multiple of 4).</li>
<li>“Machine check” (abort)
A machine-check mechanism has detected a CPU or bus error.</li>
<li>“SIMD floating point exception” (fault)
The SSE or SSE2 unit integrated in the CPU chip has signaled an error condition
on a floating-point operation.</li>
</ol>
<h2 id="procinterrupts">/proc/interrupts</h2>
<p>Procfs is a virtual filesystem that exists only in kernel memory and is typically mounted at
/proc. An example is the /proc/interrupts file, which is populated
with statistics related to interrupts on the system.</p>
<p>Example output</p>
<p><img src="images/2022-02-09-10-43-26.png" alt=""></p>
<ul>
<li>col1: interrupt line numebrs (IRQ no.).</li>
<li>col2: a counter of number of interrupts received on each CPU.</li>
<li>col3: interrupt controller name.</li>
<li>col4: device assocated with this interrupt, the name is supplied by the <code>name</code> argument in <code>request_irq()</code> call.</li>
</ul>
<p>procfs code is located primarily in <code>fs/proc</code>.The function that provides /proc/interrupts is architecture-dependent and named <code>show_interrupts()</code>, eg, in <code>&lt;arch/x86/kernel/irq.c&gt;</code>.</p>
<h2 id="interrupt-handler-and-interrupt-context">Interrupt handler and Interrupt context</h2>
<p>The function the kernel runs in response to a specific interrupt is called an <em>interrupt handler</em>
or <em>interrupt service routine (ISR)</em>.</p>
<ul>
<li>kernel invokes them in response to interrupts and that they run in a special context called interrupt context.</li>
<li>code executing in this context is unable to block.
<ul>
<li>Interrupt context is not associated with a process, without a backing processs, it can <em>not</em> be rescheduled.</li>
<li>It is time-critical, so the code should be quick and simple as possible.</li>
</ul>
</li>
</ul>
<p>Interrupt handlers in Linux need not be reentrant. When a given interrupt handler is executing,
the corresponding interrupt line is masked out on all processors, preventing another interrupt on the same line from being received.</p>
<ul>
<li>ie., Top half runs in <em>interrupt-disabled</em> mode to postpone the delivery of new interrupts, which can cause latency problems for other threads if it runs for too long.</li>
</ul>
<p>Also refer to <a href="scheduler.html#interrupt-context">interrupt-context</a></p>
<h2 id="top-halves-and-bottom-halves">Top Halves and Bottom Halves</h2>
<p>The processing of interrupts is split into two parts, or halves.</p>
<ul>
<li>The interrupt handler is the top half. The top half is run immediately upon receipt of the interrupt and performs only the work that is time-critical, such as acknowledging receipt of the interrupt or resetting the hardware.
<ul>
<li>If the work is time sensitive, perform it in the interrupt handler.</li>
<li>If the work is related to the hardware, perform it in the interrupt handler.</li>
<li>If the work needs to ensure that another interrupt (particularly the same interrupt) does not interrupt it, perform it in the interrupt handler.</li>
<li>For everything else, consider performing the work in the bottom half.</li>
</ul>
</li>
<li>Bottom half is the work that can be deferred. The bottom half runs in the future, at a more convenient time, with all interrupts enabled.</li>
</ul>
<p>Eg. a network card recevies packets from the network, it immediately issues an interrupt, The interrupt runs, acknowledges the hardware, copies the new networking packets into main memory, and readies the network card for more packets. These jobs are done as top halves (including copying data into main memory because network card memory is limited). After the networking data is safely in the main memory, the interrupt’s job is done, and it can return control of the system to whatever code was interrupted when the interrupt was generated.The rest of the processing and handling of the packets occurs later, in the bottom
half.</p>
<p><img src="images/2022-02-17-15-28-52.png" alt=""></p>
<ul>
<li>In the first phase the kernel will run the generic interrupt handler that determines the interrupt number, the interrupt handler for this particular interrupt and the interrupt controller. At this point any timing critical actions will also be performed (e.g. acknowledge the interrupt at the interrupt controller level). Local processor interrupts are disabled for the duration of this phase and continue to be disabled in the next phase.</li>
<li>In the second phase all of the device drivers handler associated with this interrupt will be executed. At the end of this phase the interrupt controller's &quot;end of interrupt&quot; method is called to allow the interrupt controller to reassert this interrupt. The local processor interrupts are enabled at this point.</li>
<li>Finally, in the last phase of interrupt handling interrupt context deferrable actions will be run. These are also sometimes known as &quot;bottom half&quot; of the interrupt (the upper half being the part of the interrupt handling that runs with interrupts disabled). At this point interrupts are enabled on the local processor.</li>
</ul>
<h2 id="bottom-half-mechnisms">Bottom half mechnisms</h2>
<h3 id="softirq">softirq</h3>
<p>set of statically defined bottom halves</p>
<ul>
<li>Softirqs are useful when performance is critical. Currently, only two subsystems—networking and block devices—directly use softirqs.</li>
<li>kernel timers and tasklets are built on top of softirqs</li>
</ul>
<p>softirq can run simultaneously on any processor; even two of the same type can run concurrently.</p>
<ul>
<li>This means that any shared data (including global data used only within the softirq handler) needs proper locking</li>
<li>most softirq handlers resort to per-processor data (data unique to each processor and thus not requiring locking) to avoid explict locking</li>
<li>If you really need lock, consider tasklets.</li>
</ul>
<p>softirq code in the <code>kernel/softirq.c</code>.</p>
<p><a href="#softirqs-kernel-interals">Implementation details refer to Softirq Kernel Internals</a></p>
<h3 id="tasklet">tasklet</h3>
<p>tasklets are flexible, dynamically created bottom halves built on top of softirqs.</p>
<ul>
<li>tasklets are a much more common form of bottom half.</li>
<li>they have a simpler interface and relaxed locking rules than softirqs.</li>
</ul>
<p>Same as with softirqs:</p>
<ul>
<li>tasklets cannot sleep.This means you cannot use semaphores or other blocking functions in a tasklet.</li>
<li>Tasklets also run with all interrupts enabled, so you must take precautions (for example, disable interrupts and obtain a lock) if your tasklet shares data with an interrupt handler.</li>
</ul>
<p>Unlike softirqs, however, two of the same tasklets never run concurrently</p>
<ul>
<li>although two different tasklets can run at the same time on two different processors.</li>
<li>If your tasklet shares data with another tasklet or softirq, you need to use proper locking</li>
</ul>
<p><a href="#tasklets-kernel-interals">Implementation details refer to tasklet Kernel Internals</a></p>
<h3 id="work-queues">work queues</h3>
<p>Work queues are a method of queuing work to later be performed in process context.</p>
<p>Compared to softirq/taskset, most importantly, work queues are schedulable and can therefore sleep.</p>
<p>If you need a schedulable entity to perform your bottom-half processing, you need
work queues. They are the only bottom-half mechanisms that run in process context, and
thus, the only ones that can sleep.This means they are useful for situations in which you
need to allocate a lot of memory, obtain a semaphore, or perform block I/O.</p>
<p><a href="#work-queue-kernel-internals">Implementation details refer to work queue Kernel Internals</a></p>
<br>
<h1 id="linux-interrupts">Linux Interrupts</h1>
<h2 id="local-timer-interrupts">Local Timer Interrupts</h2>
<p>The kernel timer tick is an interrupt triggered at a periodic interval (based on the kernel compile option <code>CONFIG_HZ</code>) on one core, it interrupts only a particular CPU instead of raising an interrupt that can be handled by any CPU.</p>
<p>When the tick fires (as often as every millisecond, based on value of <code>CONFIG_NO_HZ</code>), it will get scheduled ahead of whatever’s currently running on a CPU core.</p>
<p>The tick is used to:</p>
<ul>
<li>It does timekeeping, i.e. to update <code>gettimeofday</code> and system <code>uptime</code>.</li>
<li>Run any dynamic timers that have expired. (such as <code>poll()</code> and <code>select()</code> timeout)</li>
<li>keeps track of kernel statistics such as CPU and memory usage.</li>
<li>provides for scheduler fairness by ensuring the scheduler runqueues are balanced and, if not, balancing them.
<ul>
<li>update process's timeslice count so that they can be scheduled in time.</li>
</ul>
</li>
<li>catch up with read-copy-update (RCU) callbacks</li>
</ul>
<p>Kernel Details of Timer Interrupt Handler - &quot;Linux Kernel Development Chapter 11 Section The Timer Interrupt Handler&quot;</p>
<p>The frequency of the system timer is defined as <code>HZ</code>. The kernel defines the value in &lt;asm/param.h&gt;, by default the x86 architecture defines HZ to be 100. The value can be configured at kernel compile time.</p>
<h3 id="config_no_hz">CONFIG_NO_HZ</h3>
<p>If that option is set, the timer tick will be turned off (with cavet), but only when the CPU is idle.</p>
<p>In Kernel 3.10, the CONFIG_NO_HZ option has been replaced by a three-way choice:</p>
<ul>
<li><code>CONFIG_HZ_PERIODIC</code> is the old-style mode wherein the timer tick runs at all times.</li>
<li><code>CONFIG_NO_HZ_IDLE</code> (the default setting) will cause the tick to be disabled at idle, the way setting <code>CONFIG_NO_HZ</code> did in earlier kernels.</li>
<li><code>CONFIG_NO_HZ_FULL</code> will enable the &quot;full&quot; tickless mode.
<ul>
<li>nohz_full=&quot; boot parameter specifies the adaptive-ticks CPUs.  For example, &quot;nohz_full=1,6-8&quot;</li>
<li>At least one non-adaptive-tick CPU must remain online to handle timekeeping tasks in order to ensure that system calls like gettimeofday() returns accurate values</li>
<li>Even then, a running CPU will only disable the timer tick if there is a single runnable process on that CPU.
<ul>
<li>As soon as a second process appears, the tick is needed so that the scheduler can make the necessary time-slice decisions.</li>
<li>And even with a single runnable process, it is not technically tickless, since the timer tick still needs to happen at least once per second to keep the scheduler happy.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Reference: <a href="https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt">https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt</a></p>
<h3 id="how-to-check">How to check:</h3>
<pre><code class="language-bash"><div>$ watch -n1 -d <span class="hljs-string">&quot;cat /proc/interrupts|egrep &#x27;LOC|CPU&#x27;&quot;</span>
$ perf <span class="hljs-built_in">stat</span> -C 1 -e irq_vectors:local_timer_entry sleep 1
</div></code></pre>
<h2 id="interprocessor-interrupts-ipi">Interprocessor interrupts (IPI)</h2>
<p>Interprocessor interrupts (IPIs) are used to exchange messages between CPUs in SMP system.</p>
<p>In SMP systems we may have multiple interrupt controllers in the systems. On the x86 architecture each core has a local APIC used to process interrupts from locally connected devices like timers or thermals sensors. Then there is an I/O APIC is used to distribute IRQ from external devices to CPU cores.</p>
<p>Important feature of the APIC is that it allows CPUs to generate interprocessor interrupts (IPI). CPU can store the interrupt vector and the identifier of the target’s local APIC in the Interrupt Command Register (ICR) of its own local APIC. A message is then sent via the ICC bus to the target’s local APIC, which then issues a corresponding interrupt to its own CPU.</p>
<p><img src="images/2022-02-17-19-37-49.png" alt=""></p>
<p>SMP kernel recognizes four different type of messages identified by interrupt vectors:</p>
<ul>
<li>RESCHEDULE_VECTOR(0x30)
<ul>
<li>Used at least when the best cpu for the woken up task is not this cpu.
<ul>
<li>The kernel’s scheduler wants to schedule some work on an idle core</li>
<li>A timer is going to expire on an idle core, etc..</li>
</ul>
</li>
<li>Handler: <code>smp_reschedule_interrupt()</code>.</li>
<li>Check: <code># watch -n1 -d &quot;cat /proc/interrupts|egrep 'RES|CPU&quot;</code></li>
<li>Remediation: Running latency-sensitive processes at realtime priority in a different scheduling domain. So that it won’t trigger or be triggered on a rescheduling interrupt.</li>
</ul>
</li>
<li>INVALIDATE_TLB_VECTOR(0x31)
<ul>
<li>Used when the TLBs of the other CPU need to be invalidated.</li>
<li>Handler: <code>smp_invalidate_interrupt()</code>.</li>
</ul>
</li>
<li>LOCAL_TIMER_VECTOR(0x41)
<ul>
<li>Used for finer grained (better than traditional 100 Hz timer) kernel profiling and process statistics and rescheduling.</li>
<li>Handler: <code>smp_apic_timer_interrupt()</code>, which handles pending softirqs also.</li>
</ul>
</li>
<li>CALL_FUNCTION_VECTOR(0x50)
<ul>
<li>Used to call functions with a given argument on other CPUs like <code>flush_tlb_all_ipi()</code> and <code>stop_this_cpu()</code>.</li>
<li>Handler: <code>smp_call_function_interrupt()</code>.</li>
<li>TLB shootdowns and rescheduling interrupts also use this facility but they are tracked separately in <code>/proc/interrupts</code>.</li>
<li>Check :  <code># watch -n1 -d &quot;cat /proc/interrupts|egrep ‘CAL|CPU'&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="non-maskable-interrupts-nmi">Non-maskable Interrupts (NMI)</h2>
<p>An interrupt is said to be masked when it has been disabled, or when the CPU has been instructed to ignore it. A non-maskable interrupt (NMI) cannot be ignored, and is generally used only for critical hardware errors.</p>
<p>NMIs are normally delivered over a separate interrupt line (NMI pin). When an NMI is received by the CPU, it indicates that a critical error has occurred and that the system is probably about to crash. The NMI is generally the best indication of what might have caused the problem.</p>
<p>Because NMIs are not able to be ignored, they are also used by some systems as a hardware monitor. The device sends a stream of NMIs, which are checked by an NMI handler in the processor. If certain conditions are met - such as an interrupt not being triggered after a specified length of time - the NMI handler can produce a warning and debugging information about the problem. This helps to identify and prevent system lockups.</p>
<h2 id="system-management-interrupts-smi">System Management Interrupts (SMI)</h2>
<p>System Management Interrupts (SMIs) are a special type of non-maskable interrupt (NMI) that places the CPU in system management mode.</p>
<p>SMIs are configured and serviced by the BIOS and are typically used to handle critical thermal or power management events.  They are sometimes also used to implement BIOS-level emulation of legacy devices, like floppy disk drives.</p>
<br>
<h1 id="kernel-internals">Kernel Internals</h1>
<h2 id="kernel-code-flow-for-calling-interrupt-handler">Kernel code flow for calling interrupt handler</h2>
<p>C Code is in <code>arch/x86/kernel/irq.c</code>.</p>
<ul>
<li>For each interrupt line, the kernel jumps to a unique location in memory and executes the code located
there. The initial entry point (written in assembly, in <code>arch/x86/kernel/entry_64.S</code>) simply saves this IRQ number and stores the current register values on the interruption stack. then the kernel calls <code>do_IRQ()</code>.</li>
<li><code>do_IRQ()</code> acknowledges the receipt of the interrupt and disables interrupt delivery on the line. Next, <code>do_IRQ()</code> ensures that a valid handler is registered on the line and that it is enabled and not currently executing. If so, it calls <code>handle_IRQ_event()</code>, defined in <code>kernel/irq/handler.c</code>, to run the installed interrpt handler on the line.</li>
<li>Once <code>handle_IRQ_event()</code> is done, Back in <code>do_IRQ()</code>, the function cleans up and returns
to the initial entry point, which then jumps to <code>ret_from_intr()</code>.</li>
<li>The routine <code>ret_from_intr()</code>, written in assembly, checks whether a reschedule is pending.
<ul>
<li>If a reschedule is pending, and the kernel is returning to user-space (that is, the interrupt interrupted a user process), <code>schedule()</code> is called.</li>
<li>If the kernel is returning to kernel-space (that is, the interrupt interrupted the kernel itself), <code>schedule()</code> is called only if the <code>preempt_count()</code> is zero.</li>
<li>After <code>schedule()</code> returns, or if there is no work pending, the initial registers are restored and the kernel resumes whatever was interrupted.</li>
</ul>
</li>
</ul>
<h2 id="registering-an-interrupt-handler">Registering an Interrupt Handler</h2>
<p>Interrupt handlers are the responsibility of the driver managing the hardware. The driver
should register the interrupt handler.</p>
<p>Drivers can register an interrupt handler and enable a given interrupt line for handling
with the function request_irq(), which is declared in <code>&lt;linux/interrupt.h&gt;</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-comment">/* request_irq: allocate a given interrupt line */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">request_irq</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> irq,
                <span class="hljs-keyword">irq_handler_t</span> handler, <span class="hljs-comment">/*a function pointer to the actual interrupt handler*/</span>
                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags,
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,
                <span class="hljs-keyword">void</span> *dev)</span>
</span></div></code></pre>
<p>The meaning of the arguments of above functions is explained in <em>&quot;Linux Kernel Development Chapter 7&quot;</em></p>
<p>Above registered <code>handler</code> function is invoked whenever the operating system receives the interrupt.</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">irqreturn_t</span> <span class="hljs-params">(*<span class="hljs-keyword">irq_handler_t</span>)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span> *)</span></span>;
</div></code></pre>
<p>Note that request_irq() can sleep and therefore cannot be called from interrupt context or other situations where code cannot block.</p>
<ul>
<li>The reason is on registration, an entry corresponding to the interrupt is
created in <code>/proc/irq</code>. The function <code>proc_mkdir()</code> creates new procfs entries. It in turn
calls <code>proc_create()</code> to set up the new procfs entries, which in turn calls kmalloc() to allocate memory, and kmalloc() can sleep.</li>
</ul>
<h2 id="an-interrupt-handler-example">An interrupt handler example</h2>
<p>An example from the real-time clock (RTC) driver, found in <code>&lt;drivers/char/rtc.c&gt;</code>.</p>
<p>An RTC is a device that sets the system clock, provides an alarm, or supplies a periodic timer. The timer functionality is normally implemented via interrupt.</p>
<p>When the RTC driver loads, the function rtc_init() is invoked to initialize the
driver. One of its duties is to register the interrupt handler:</p>
<pre><code class="language-C++"><div><span class="hljs-comment">/* register rtc_interrupt on rtc_irq */</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">request_irq</span>(rtc_irq, rtc_interrupt, IRQF_SHARED, <span class="hljs-string">&quot;rtc&quot;</span>, (<span class="hljs-keyword">void</span> *)&amp;rtc_port)) {
    <span class="hljs-built_in">printk</span>(KERN_ERR <span class="hljs-string">&quot;rtc: cannot register IRQ %d\n&quot;</span>, rtc_irq);
    <span class="hljs-keyword">return</span> -EIO;
}
</div></code></pre>
<p>The handler itself. This function is invoked whenever the machine receives the RTC interrupt. The spin lock ensures the data is not accessed concurrently by another processor on an SMP machine.</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">irqreturn_t</span> <span class="hljs-title">rtc_interrupt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">void</span> *dev)</span>
</span>{
    <span class="hljs-comment">/*
    * Can be an alarm interrupt, update complete interrupt,
    * or a periodic interrupt. We store the status in the
    * low byte and the number of interrupts received since
    * the last read in the remainder of rtc_irq_data.
    */</span>
    <span class="hljs-built_in">spin_lock</span>(&amp;rtc_lock);
    rtc_irq_data += <span class="hljs-number">0x100</span>;
    rtc_irq_data &amp;= ~<span class="hljs-number">0xff</span>;
    rtc_irq_data |= (<span class="hljs-built_in">CMOS_READ</span>(RTC_INTR_FLAGS) &amp; <span class="hljs-number">0xF0</span>);
    <span class="hljs-keyword">if</span> (rtc_status &amp; RTC_TIMER_ON)
        <span class="hljs-built_in">mod_timer</span>(&amp;rtc_irq_timer, jiffies + HZ/rtc_freq + <span class="hljs-number">2</span>*HZ/<span class="hljs-number">100</span>);
    <span class="hljs-built_in">spin_unlock</span>(&amp;rtc_lock);
    <span class="hljs-comment">/*
    * Now do the rest of the actions
    */</span>
    <span class="hljs-built_in">spin_lock</span>(&amp;rtc_task_lock);
    <span class="hljs-keyword">if</span> (rtc_callback)
        rtc_callback-&gt;<span class="hljs-built_in">func</span>(rtc_callback-&gt;private_data);
    <span class="hljs-built_in">spin_unlock</span>(&amp;rtc_task_lock);
    <span class="hljs-built_in">wake_up_interruptible</span>(&amp;rtc_wait);
    <span class="hljs-built_in">kill_fasync</span>(&amp;rtc_async_queue, SIGIO, POLL_IN);
    <span class="hljs-keyword">return</span> IRQ_HANDLED;
}
</div></code></pre>
<h2 id="softirqs-kernel-interals">softirqs Kernel Interals</h2>
<p>Softirqs are statically allocated at compile time. Softirqs are represented by the <code>softirq_action</code> structure,
defined in <code>&lt;linux/interrupt.h&gt;</code></p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> {</span>
    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*action)(struct softirq_action *);
};
</div></code></pre>
<p>A 32-entry array of this structure is declared in <code>&lt;kernel/softirq.c&gt;</code>. The kernel enforces a limit of 32
registered softirqs; in the current kernel, however, only nine exist.</p>
<table>
<thead>
<tr>
<th>Tasklet</th>
<th>Priority</th>
<th>Softirq Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>HI_SOFTIRQ</td>
<td>0</td>
<td>High-priority tasklets</td>
</tr>
<tr>
<td>TIMER_SOFTIRQ</td>
<td>1</td>
<td>Timers</td>
</tr>
<tr>
<td>NET_TX_SOFTIRQ</td>
<td>2</td>
<td>Send network packets</td>
</tr>
<tr>
<td>NET_RX_SOFTIRQ</td>
<td>3</td>
<td>Receive network packets</td>
</tr>
<tr>
<td>BLOCK_SOFTIRQ</td>
<td>4</td>
<td>Block devices</td>
</tr>
<tr>
<td>TASKLET_SOFTIRQ</td>
<td>5</td>
<td>Normal priority tasklets</td>
</tr>
<tr>
<td>SCHED_SOFTIRQ</td>
<td>6</td>
<td>Scheduler</td>
</tr>
<tr>
<td>HRTIMER_SOFTIRQ</td>
<td>7</td>
<td>High-resolution timers</td>
</tr>
<tr>
<td>RCU_SOFTIRQ</td>
<td>8</td>
<td>RCU locking</td>
</tr>
</tbody>
</table>
<pre><code class="language-C++"><div><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> <span class="hljs-title">softirq_vec</span>[<span class="hljs-title">NR_SOFTIRQS</span>];</span>
</div></code></pre>
<p>The prototype of a softirq handler, action, looks like</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">softirq_handler</span><span class="hljs-params">(struct softirq_action *)</span>
</span></div></code></pre>
<p>the kernel would invoke the softirq handler function as</p>
<pre><code class="language-C++"><div>my_softirq-&gt;<span class="hljs-built_in">action</span>(my_softirq);
</div></code></pre>
<p><strong>register softirq handler</strong></p>
<p>the softirq handler is registered at run-time via open_softirq(), which takes two
parameters: the softirq’s index and its handler function.The networking subsystem, for
example, registers its softirqs like this, in <code>net/core/dev.c</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-built_in">open_softirq</span>(NET_TX_SOFTIRQ, net_tx_action);
<span class="hljs-built_in">open_softirq</span>(NET_RX_SOFTIRQ, net_rx_action);
</div></code></pre>
<p><strong>raise softirq</strong></p>
<p>After a handler is added to the enum list and registered via open_softirq(), it is ready to
run. To mark it pending, so it is run at the next invocation of <code>do_softirq()</code>, use
<code>raise_softirq()</code> call. For example, the networking subsystem would call,</p>
<pre><code class="language-C++"><div><span class="hljs-built_in">raise_softirq</span>(NET_TX_SOFTIRQ);
</div></code></pre>
<p>Softirqs are most often raised from within interrupt handlers. The interrupt handler performs the basic hardware-related work, raises the softirq, and then exits.</p>
<p><strong>softirq execution</strong></p>
<p>Usually, an interrupt handler marks its softirq for execution before returning. Then, at a
suitable time, the softirq runs. Pending softirqs are checked for and executed in the following
places:</p>
<ul>
<li>In the return from hardware interrupt code path</li>
<li>In the ksoftirqd kernel thread</li>
<li>In any code that explicitly checks for and executes pending softirqs, such as the networking
subsystem</li>
</ul>
<p>softirq execution occurs in <code>__do_softirq()</code>, which is invoked by <code>do_softirq()</code>, both defined in <code>&lt;kernel/softirq.c&gt;</code>, the gut of <code>__do_softirq()</code> is listed below:</p>
<pre><code class="language-C++"><div>u32 pending;
<span class="hljs-comment">// a 32-bit mask of pending softirqs, if n-th bit is set, nth softirq is pending</span>
pending = <span class="hljs-built_in">local_softirq_pending</span>(); 
<span class="hljs-keyword">if</span> (pending) {
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> *<span class="hljs-title">h</span>;</span>
  <span class="hljs-comment">/* reset the pending bitmask */</span>
  <span class="hljs-built_in">set_softirq_pending</span>(<span class="hljs-number">0</span>);
  h = softirq_vec;
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">if</span> (pending &amp; <span class="hljs-number">1</span>)
    h-&gt;<span class="hljs-built_in">action</span>(h);
    h++;
    pending &gt;&gt;= <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">while</span> (pending);
}
</div></code></pre>
<h2 id="tasklets-kernel-interals">Tasklets Kernel Interals</h2>
<p>tasklets are implemented on top of softirqs, they are represetned by two softirqs: <code>HI_SOFTIRQ</code> and <code>TASKLET_SOFTIRQ</code>.The only difference is that the <code>HI_SOFTIRQ</code> based tasklets run prior to the <code>TASKLET_SOFTIRQ</code> tasklets.</p>
<p>Tasklets are represented by the tasklet_struct structure, declared in <code>&lt;linux/interrupt.h&gt;</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> {</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">/* next tasklet in the list */</span>
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> state; <span class="hljs-comment">/* state of the tasklet */</span>

  <span class="hljs-comment">// If it is nonzero, the tasklet is disabled and cannot run; </span>
  <span class="hljs-comment">// if it is zero, the tasklet is enabled and can run if marked pending.</span>
  <span class="hljs-keyword">atomic_t</span> count; <span class="hljs-comment">/* reference counter */</span>

  <span class="hljs-comment">// The func member is the tasklet handler (the equivalent of action to a softirq) </span>
  <span class="hljs-comment">// and receives data as its sole argument.</span>
  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*func)(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>); <span class="hljs-comment">/* tasklet handler function */</span>
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data; <span class="hljs-comment">/* argument to the tasklet function */</span>
};
</div></code></pre>
<p><strong>Create tasklet</strong></p>
<p>You can create tasklets statically or dynamically, defined in <code>&lt;linux/interrupt.h&gt;</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// use one of two macros to create statically</span>
<span class="hljs-built_in">DECLARE_TASKLET</span>(name, func, data)  <span class="hljs-comment">// sets reference count to zero, and the tasklet is enabled</span>
<span class="hljs-built_in">DECLARE_TASKLET_DISABLED</span>(name, func, data); <span class="hljs-comment">// sets count to 1, the tasklet is disabled</span>

<span class="hljs-built_in">tasklet_init</span>(t, tasklet_handler, dev); <span class="hljs-comment">/* dynamically as opposed to statically */</span>
</div></code></pre>
<p><strong>tasklet handler</strong></p>
<p>The tasklet handler must match the correct prototype:</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tasklet_handler</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data)</span>
</span></div></code></pre>
<p><strong>Schedule tasklet</strong></p>
<p>Scheduled tasklets (the equivalent of raised softirqs) are stored in the <strong>per-processor</strong> structures:
<code>tasklet_vec</code> (for regular tasklets) and <code>tasklet_hi_vec</code> (for high-priority tasklets).
Both of these structures are linked lists of tasklet_struct structures.</p>
<p>Tasklets are scheduled via the <code>tasklet_schedule()</code> and <code>tasklet_hi_schedule()</code>, which receive a pointer to the tasklet’s <code>tasklet_struct</code> as the only argument.</p>
<ol>
<li>Check whether the tasklet’s state is TASKLET_STATE_SCHED. If it is, the tasklet is
already scheduled to run and the function can immediately return.</li>
<li>Call <code>__tasklet_schedule()</code>.</li>
<li>Save the state of the interrupt system, and then disable local interrupts.This ensures
that nothing on this processor will mess with the tasklet code while
<code>tasklet_schedule()</code> is manipulating the tasklets.</li>
<li>Add the tasklet to be scheduled to the head of the <code>tasklet_vec</code> or
<code>tasklet_hi_vec</code> linked list, which is unique to each processor in the system.</li>
<li>Raise the <code>TASKLET_SOFTIRQ</code> or <code>HI_SOFTIRQ</code> softirq, so <code>do_softirq()</code> executes this
tasklet in the near future.</li>
<li>Restore interrupts to their previous state and return.</li>
</ol>
<p>At the next earliest convenience when do_softirq(), the softirq handlers, <code>tasklet_action()</code> and <code>tasklet_hi_action()</code> will be run. Here the steps these handlers perform:</p>
<ol>
<li>Disable local interrupt delivery (there is no need to first save their state because the
code here is always called as a softirq handler and interrupts are always enabled) and
retrieve the tasklet_vec or tasklet_hi_vec list for this processor.</li>
<li>Clear the list for this processor by setting it equal to NULL.</li>
<li>Enable local interrupt delivery.Again, there is no need to restore them to their previous
state because this function knows that they were always originally enabled.</li>
<li>Loop over each pending tasklet in the retrieved list.</li>
<li>If this is a multiprocessing machine, check whether the tasklet is running on
another processor by checking the <code>TASKLET_STATE_RUN</code> flag. If it is currently running,
do not execute it now and skip to the next pending tasklet. (Recall that only
one tasklet of a given type may run concurrently.)</li>
<li>If the tasklet is not currently running, set the <code>TASKLET_STATE_RUN</code> flag, so another
processor will not run it.</li>
<li>Check for a zero count value, to ensure that the tasklet is not disabled. If the tasklet
is disabled, skip it and go to the next pending tasklet.</li>
<li>We now know that the tasklet is not running elsewhere, is marked as running so it
will not start running elsewhere, and has a zero count value. Run the tasklet handler.</li>
<li>After the tasklet runs, clear the TASKLET_STATE_RUN flag in the tasklet’s state field.</li>
<li>Repeat for the next pending tasklet, until there are no more scheduled tasklets
waiting to run.</li>
</ol>
<p>all tasklets are multiplexed on top of two softirqs, HI_SOFTIRQ and TASKLET_SOFTIRQ. When a tasklet is
scheduled, the kernel raises one of these softirqs. These softirqs, in turn, are handled by
special functions that then run any scheduled tasklets. The special functions ensure that
only one tasklet of a given type runs at the same time. (But other tasklets can run simultaneously.)</p>
<h2 id="ksoftirqd">ksoftirqd</h2>
<p>Softirq (and tasklet) processing is aided by a set of per-processor kernel threads. These
kernel threads help in the processing of softirqs when the system is overwhelmed with
softirqs.</p>
<p>kernel processes softirqs in a number of places, which could overload system in heavy softirq environment.</p>
<ul>
<li>on return from handling an interrupt (most common)</li>
<li>softirq functions can reactivate themselves. While running, a softirq can raise itself so that it runs again (for example, the networking subsystem’s softirq raises itself).</li>
</ul>
<p>The solution ultimately implemented in the kernel is to not immediately process
reactivated softirqs. Instead, if the number of softirqs grows excessive, the kernel wakes up
a family of kernel threads to handle the load.</p>
<ul>
<li>The kernel threads run with the lowest possible priority (nice value of 19)</li>
<li>This concession prevents heavy softirq activity from completely starving user-space of processor time.</li>
</ul>
<p>There is one thread per processor.The threads are each named <code>ksoftirqd/n</code>, such as <code>ksoftirqd/0</code> and
<code>ksoftirqd/1</code>. they run a tight loop similar to this:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">for</span> (;;) {
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">softirq_pending</span>(cpu))
    <span class="hljs-built_in">schedule</span>();
  
  <span class="hljs-built_in">set_current_state</span>(TASK_RUNNING);
  
  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">softirq_pending</span>(cpu)) {
    <span class="hljs-built_in">do_softirq</span>();
    <span class="hljs-comment">// After each iteration, schedule() is called if needed, to enable more important processes to run</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">need_resched</span>())
      <span class="hljs-built_in">schedule</span>();
  }
  <span class="hljs-built_in">set_current_state</span>(TASK_INTERRUPTIBLE);
}
</div></code></pre>
<h2 id="work-queue-kernel-internals">Work Queue Kernel Internals</h2>
<p>A good overview reference: <a href="https://lwn.net/Articles/11360/">https://lwn.net/Articles/11360/</a></p>
<p>the work queue subsystem is an interface for creating kernel threads (called worker threads) to handle work queued from elsewhere. The kernel provides a default worker thread for handling work, called <code>events/n</code>, where n is the processor number, eg, <code>events/0</code>.</p>
<p>The relationship between the different data structures of work queue.</p>
<p><img src="images/2022-02-10-13-57-54.png" alt=""></p>
<ul>
<li>At the top of diagram, there are worker threads. There can be multiple types of worker
threads; there is one worker thread per processor of a given type. By default, there is the events worker thread.</li>
<li>At the bottom of diagram, the device driver creates work, which it wants to defer to later.The <code>work_struct</code> structure represents this work. Among other things, this structure contains a pointer to the function that handles the defered work.</li>
<li>The work is submitted to a specific worker thread. The worker thread then wakes up and performs the queued work.</li>
</ul>
<p>The work is represented by the work_struct structure, defined in <code>&lt;linux/workqueue.h&gt;</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> {</span>
  <span class="hljs-keyword">atomic_long_t</span> data;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span>
  <span class="hljs-keyword">work_func_t</span> func;
};

<span class="hljs-comment">// This statically creates a work_struct structure named name with handler function func and argument data.</span>
<span class="hljs-built_in">DECLARE_WORK</span>(name, <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*func)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *data);

<span class="hljs-comment">//This dynamically initializes the work queue pointed to by work with handler function func and argument data.</span>
<span class="hljs-built_in">INIT_WORK</span>(struct work_struct *work, <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*func)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *data);
</div></code></pre>
<p>The prototype for the work queue handler is</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work_handler</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *data)</span>
</span></div></code></pre>
<p>A worker thread executes this function, and thus, the function runs in process context.</p>
<p>Note that, despite running in process context, the work handlers <strong>cannot</strong> access user-space
memory because there is no associated user-space memory map for kernel threads. The kernel can access user memory only when running on behalf of a user-space process, such as when executing a system call. Only then is user memory mapped in.</p>
<p>Now that the work is created, we can schedule it.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// To queue a given work’s handler function with the default events worker threads</span>
<span class="hljs-built_in">schedule_work</span>(&amp;work);

<span class="hljs-comment">// you can schedule work to execute at a given time in the future:</span>
<span class="hljs-built_in">schedule_delayed_work</span>(&amp;work, delay);
</div></code></pre>
<p>If default event queue is insufficient for your needs, you can create a new work queue and corresponding worker threads. And schedule the work onto it.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// create a new work queue and the associated worker threads via a simple function:</span>
<span class="hljs-comment">// This function creates *all* the worker threads (one for each processor in the system) </span>
<span class="hljs-function">struct workqueue_struct *<span class="hljs-title">create_workqueue</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span>;

<span class="hljs-comment">// schedule work onto non-default work queue</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_work</span><span class="hljs-params">(struct workqueue_struct *wq, struct work_struct *work)</span>
</span></div></code></pre>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>