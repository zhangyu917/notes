<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Process Overview</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.13.24"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
#button { display: inline-block; background-color: #FF9800; width: 50px; height: 50px; text-align: center; border-radius: 4px; position: fixed; bottom: 30px; right: 30px; transition: background-color .3s, opacity .5s, visibility .5s; opacity: 0; /*visibility: hidden;*/ z-index: 1000; } #button::after { content: "\f077"; font-family: FontAwesome; font-weight: normal; font-style: normal; font-size: 2em; line-height: 50px; color: #fff; } #button:hover { cursor: pointer; background-color: #333; } #button:active { background-color: #555; } #button.show { opacity: 1; visibility: visible; } #btn-back-to-top { position: fixed; bottom: 20px; right: 20px; display: none; } .to-top { background: white; position: fixed; bottom: 16px; right:32px; width:50px; height:50px; border-radius: 50%; border-color: white; display: flex; align-items: center; justify-content: center; font-size:32px; color:#1f1f1f; text-decoration: none; opacity: 0.5; pointer-events: auto; transition: all .4s; transform: rotate(270deg); } 
</style>
    </head>
    <body class="vscode-body vscode-light">
        <ul>
<li><a href="#process-overview">Process Overview</a>
<ul>
<li><a href="#process-vs-thread">Process vs Thread</a>
<ul>
<li><a href="#process">Process</a></li>
<li><a href="#thread">Thread</a></li>
<li><a href="#linux-thread-implementation">Linux thread implementation</a></li>
<li><a href="#resources-not-shared-among-threads">Resources not shared among threads:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#process-creation">Process Creation</a>
<ul>
<li><a href="#fork-system-call">fork() system call</a>
<ul>
<li><a href="#file-sharing-with-fork">File sharing with fork()</a></li>
<li><a href="#memory-semantics-of-fork">Memory semantics of fork()</a></li>
<li><a href="#fork-implementation">fork() implementation</a></li>
</ul>
</li>
<li><a href="#vfork-system-call">vfork() system call</a></li>
</ul>
</li>
<li><a href="#process-termination">Process Termination</a>
<ul>
<li><a href="#ways-of-termination">Ways of termination</a></li>
<li><a href="#details-of-termination">Details of termination</a></li>
<li><a href="#exit-handlers">Exit handlers</a></li>
<li><a href="#nohup"><strong><code>nohup</code></strong></a></li>
</ul>
</li>
<li><a href="#process-monitoring">Process monitoring</a>
<ul>
<li><a href="#wait-system-call"><code>wait()</code> system call</a>
<ul>
<li><a href="#waitpid-system-call">waitpid() system call</a></li>
<li><a href="#waitid-system-call">waitid() system call</a></li>
<li><a href="#wait3-and-wait4">wait3() and wait4()</a></li>
</ul>
</li>
<li><a href="#orphan">Orphan</a></li>
<li><a href="#zombie">Zombie</a></li>
<li><a href="#establish-handler-for-sigchld">Establish handler for SIGCHLD</a></li>
</ul>
</li>
<li><a href="#program-execution">Program Execution</a>
<ul>
<li><a href="#execve-system-call"><code>execve()</code> system call</a>
<ul>
<li><a href="#exec-library-function-family">exec() library function family</a></li>
</ul>
</li>
<li><a href="#exec-of-interpreter-scripts">Exec of interpreter scripts</a></li>
<li><a href="#file-descriptor-with-exec">File descriptor with exec()</a>
<ul>
<li><a href="#the-steps-for-ls-tmp--dirtxt">The steps for <code>ls /tmp &gt; dir.txt</code></a></li>
</ul>
</li>
<li><a href="#system-library-call">system() library call</a>
<ul>
<li><a href="#implementation-of-system">Implementation of system()</a></li>
</ul>
</li>
<li><a href="#signals-and-exec">Signals and exec()</a></li>
</ul>
</li>
<li><a href="#kernel-internals">Kernel Internals</a>
<ul>
<li><a href="#process-descriptor--task_struct">Process descriptor / task_struct</a>
<ul>
<li><a href="#how-to-find-current-processs-task_struct">How to find current process's task_struct?</a></li>
<li><a href="#process-context--and-interrupt-context">Process Context  and Interrupt Context</a></li>
<li><a href="#process-family-tree">Process Family Tree</a></li>
</ul>
</li>
<li><a href="#clone-system-call">clone() system call</a>
<ul>
<li><a href="#clone-kernel-implementation">clone() kernel implementation</a></li>
</ul>
</li>
<li><a href="#do_exit-kernel-implementation">do_exit() kernel implementation</a></li>
<li><a href="#wait-kernel-implementation">wait() kernel implementation</a></li>
<li><a href="#kernel-threads">Kernel threads</a></li>
</ul>
</li>
</ul>
<p><a href="#" class="to-top">➤</i></a></p>
<h1 id="process-overview">Process Overview</h1>
<p>A process is an active program and related resources.</p>
<ul>
<li>include a set of resources such as open files and pending signals,
internal kernel data, processor state, a memory address space with one or more memory
mappings, one or more threads of execution, and a data section containing global variables.</li>
<li>The Linux kernel internally refers to processes as tasks.</li>
</ul>
<p>Threads of execution, often shortened to threads, are the objects of activity within the
process.</p>
<ul>
<li>Each thread includes a unique program counter, process stack, and set of processor
registers.</li>
<li>The kernel schedules individual threads, not processes.</li>
<li>Linux has a unique implementation of threads: It does not differentiate between
threads and processes. A thread is just a special kind of process.</li>
</ul>
<p>Process Life Cycle:</p>
<ul>
<li>
<p>A process begins its life when, not surprisingly, it is created. In Linux, this occurs by means of the <code>fork()</code> system call, which creates a new process by duplicating an existing one.</p>
</li>
<li>
<p>Often, immediately after a <code>fork()</code> it is desirable to execute a new, different program.The
exec() family of function calls creates a new address space and loads a new program into
it.</p>
<ul>
<li>In Linux kernels, <code>fork()</code> is actually implemented via the <code>clone()</code> system call</li>
</ul>
</li>
<li>
<p>Finally, a program exits via the <code>exit()</code> system call.This function terminates the process
and frees all its resources.</p>
</li>
</ul>
<h2 id="process-vs-thread">Process vs Thread</h2>
<h3 id="process">Process</h3>
<p>Each process provides the resources needed to execute a program.</p>
<ul>
<li>A process has a virtual address space, executable code, file descriptor / handles to system objects, a unique process identifier, environment variables, and at least one thread of execution.</li>
</ul>
<h3 id="thread">Thread</h3>
<p>A thread is an entity within a process that can be scheduled for execution.</p>
<ul>
<li>All threads of a process share its virtual address space and system resources.</li>
<li>Each thread maintains its own stack frame and registers, exception handlers, a scheduling priority, thread local storage, a unique thread identifier, and a set of structures the system will use to save the thread context until it is scheduled.</li>
<li>Since the threads of a process share the same memory, synchronizing the access to the shared data within the process gains unprecedented importance.</li>
<li>Process creation with <code>fork()</code> is relatively expensive, even with copy-on-write technique. Thread creation is faster than process creation—typically, ten times faster or better.
<ul>
<li>On Linux, threads are implemented using the <code>clone()</code> system call, so many of the attributes that must be duplicated in a child created by <code>fork()</code> are instead shared between threads. In particular, copy-on-write duplication of pages of memory is not required, nor is duplication of page tables.</li>
</ul>
</li>
</ul>
<h3 id="linux-thread-implementation">Linux thread implementation</h3>
<p>Linux has a unique implementation of threads. To the Linux kernel, there is no concept of a thread. Linux implements all threads as standard processes. Each thread has a unique task_struct and appears to the kernel as a normal process.</p>
<p>A thread is merely a process that shares certain resources, such as an address space, with other processes.</p>
<p>Other OS, such as Windows or Solaris, have explicit kernel support for threads, or called <em>lightweight processes</em>. To these other operating systems, threads are an abstraction to provide a lighter, quicker execution unit than the heavy process.</p>
<p><strong>NPTL</strong> (Native POSIX Thread Library) is the GNU C library POSIX threads implementation that is used on Linux systems. The NPTL was originally developed by Red Hat. An application compiled with <code>gcc -pthread</code> and linked with <code>-pthread</code> uses NPTL code on Linux.</p>
<h3 id="resources-not-shared-among-threads">Resources not shared among threads:</h3>
<ul>
<li>stack (local variables and function call linkage information).
<ul>
<li>Each thread has its own stack whose size is fixed when the thread is created.</li>
<li>On Linux/x86-32, the default stack size is 2 MB (which means 3G/2M = 1500 threads max).</li>
<li>The main thread has a much larger space for stack growth</li>
<li>pthread_attr_setstack() function can be used to control both the size and the location of the stack</li>
<li>if the stack size resource limit (RLIMIT_STACK) is set to anything other than unlimited, then it is used as the default stack size when creating new threads.</li>
</ul>
</li>
<li>thread ID (Section 29.5);</li>
<li>signal mask;</li>
<li>thread-specific data (Section 31.3);</li>
<li>the errno variable;
<ul>
<li>On Linux, a thread-specific errno is defined as a macro that expands into a function call returning a modifiable lvalue that is distinct for each thread.</li>
</ul>
</li>
<li>floating-point environment (see fenv(3));</li>
<li>realtime scheduling policy and priority (Sections 35.2 and 35.3);</li>
<li>CPU affinity (Linux-specific, described in Section 35.4);</li>
<li>capabilities (Linux-specific, described in Chapter 39);</li>
</ul>
<p><img src="images/2022-02-14-19-30-28.png" alt=""></p>
<h1 id="process-creation">Process Creation</h1>
<h2 id="fork-system-call">fork() system call</h2>
<p>fork() creates a new process by duplicating the calling process. The child obtains copies of the parent’s stack, data, heap, and text segments.</p>
<ul>
<li>For the parent, fork() returns the process ID of the newly created child.</li>
<li>For the child, fork() returns 0.
<ul>
<li>If necessary, the child can obtain its own process ID using getpid(), and the process ID of its parent using getppid().</li>
</ul>
</li>
<li>Caution: after a fork(), it is indeterminate which of the two processes is next scheduled to use the CPU.
<ul>
<li>In Linux, there are version changes to make child-first-after-fork() default or parent-first. It is default can be changed in <code>/proc/sys/kernel/sched_child_runs_first</code></li>
</ul>
</li>
</ul>
<p>The child process and the parent process run in separate memory spaces.  At the time of fork() both memory spaces have the same content. Even they are in different address space, the variable’s address (virtual address will be the same), but physical address will be different.</p>
<p>The entire virtual address space of the parent is replicated in the child, including the states of mutexes, condition variables, and other pthreads objects;</p>
<h3 id="file-sharing-with-fork">File sharing with fork()</h3>
<p>With fork(), the child receives duplicates of all parant’s file descriptors, done with dup().</p>
<ul>
<li>I.e. descriptors in the parent and the child refer to the same open file description.</li>
<li>The open file description contains the current file offset (as modified by read(), write(), and lseek()) and the open file status flags, thus they are shared by parent and child processes.</li>
<li>If sharing of file descriptors is not desired, then each process should close unused descriptors after fork(), like in below figure.</li>
</ul>
<p><img src="images/2022-02-05-17-14-53.png" alt=""></p>
<h3 id="memory-semantics-of-fork">Memory semantics of fork()</h3>
<p>Only conceptually, fork() creates copies of the parent’s text, data, heap, and stack segments.</p>
<ul>
<li>For text segment (read-only). fork() just creates a text segment for the child by building the per-process page-table entries that refer to the same virtual memory page frames already used by the parent.</li>
<li>For data, heap, stack segments, the kernel uses <strong>copy-on-write (COW)</strong>.
<ul>
<li>Initially, the kernel makes child’s page-table entries for these segments refer to the same physical memory pages as the parent, and the pages themselves are marked read-only.</li>
<li>After the fork(), the kernel traps any attempts by either the parent or the child to modify one of these pages, and makes a duplicate copy of the page. This new page copy is assigned to the faulting process</li>
<li>The implication: we can be sure the parent's memory footprint (the virtual memory pages) stays the same if the parent doesn’t do work after fork() and before wait().</li>
<li>reason for COW: It is inefficient in that it copies much data that might otherwise be shared. Worse , if the new process were to immediately execute a new image, all that copying would go to waste.</li>
</ul>
</li>
<li><strong>The only overhead incurred by fork()</strong> is the duplication of the parent’s page tables and the creation of a unique process descriptor for the child.</li>
</ul>
<h3 id="fork-implementation">fork() implementation</h3>
<p>Linux implements fork() via the clone() system call.</p>
<ul>
<li>The fork(), vfork(), and __clone() library calls all invoke the clone() system call with the requisite flags.</li>
<li>The clone() system call, in turn, calls do_fork().</li>
</ul>
<p><a href="#clone-kernel-implementation">Refer to clone() implementation</a></p>
<h2 id="vfork-system-call">vfork() system call</h2>
<p>vfork() is expressly designed to be used in programs where the child performs an immediate exec() call. It is to get around inefficient old UNIX/BSD’s fork() copy memory implementation.</p>
<p>It should be used with caution, and not portable, and less useful with modern copy-on-write fork.</p>
<ul>
<li>No duplication of virtual memory pages or page tables is done for the child process (the only benefit to vfork() ). Instead, the child shares the parent’s memory until it either performs a successful exec() or calls _exit() to terminate.</li>
<li>Execution of the parent process is suspended until the child has performed an exec() or _exit().</li>
<li>File descriptors are still dup’ed during vfork().</li>
<li>After vfork(), the child is guaranteed to be scheduled for the CPU before the parent.</li>
</ul>
<br>
<h1 id="process-termination">Process Termination</h1>
<h2 id="ways-of-termination">Ways of termination</h2>
<ul>
<li>Abnormal termination - delivery of a signal whose default action is to terminate the process (with or without core dump).</li>
<li><code>_exit(int status)</code> system call
<ul>
<li>_exit() always successfully terminate the process, it never returns</li>
</ul>
</li>
<li><code>exit(int status)</code> library call
<ul>
<li>Exit handlers (functions registered with atexit() and on_exit()) are called, in reverse order of their registration.</li>
<li>The stdio stream buffers are flushed.</li>
<li>The _exit() system call is invoked</li>
</ul>
</li>
<li>Return from main()
<ul>
<li><strong>return n is equivalent to exit(n)</strong> That is, the C compiler places a call to exit()
after main() returns.</li>
<li>C99 requires falling off the end of main without return should be equivalent to calling exit(0)</li>
</ul>
</li>
</ul>
<h2 id="details-of-termination">Details of termination</h2>
<ul>
<li>Open file descriptors, directory streams are closed.
<ul>
<li>As a consequence of closing file descriptors, any file locks held by this process are released.</li>
</ul>
</li>
<li>Any attached System V shared memory segments are detached, and the shm_nattch counter corresponding to each segment is decremented by one.</li>
<li>For each System V semaphore for which a semadj value has been set by the process, that semadj value is added to the semaphore value.</li>
<li>If this is the controlling process for a controlling terminal, then the SIGHUP signal is sent to each process in the controlling terminal’s foreground process group, and the terminal is disassociated from the session.</li>
<li>Any POSIX named semaphores that are open in the calling process are closed as though sem_close() were called.</li>
<li>Any POSIX message queues that are open in the calling process are closed as though mq_close() were called.</li>
<li>If, as a consequence of this process exiting, a process group becomes orphaned and there are any stopped processes in that group, then all processes in the group are sent a SIGHUP signal followed by a SIGCONT signal.</li>
<li>Any memory locks established by this process using mlock() or mlockall() are removed.</li>
<li>Any memory mappings established by this process using mmap() are unmapped.</li>
</ul>
<p><a href="#exit-kernel-implementation">refer to kernel do_exit() implementation</a></p>
<h2 id="exit-handlers">Exit handlers</h2>
<p><code>int atexit(void (*func)(void))</code> glic library function</p>
<ul>
<li>The atexit() function adds func to a list of functions that are called when the process terminates.</li>
<li>Multiple exit handlers can be added, they are called in reverse order of registration.</li>
<li>Glibc chains the registered exit handlers in a dynamically allocated linked list.</li>
<li>A child process via fork() inherits a copy of parent’s exit handler registrations.</li>
<li>When a process performs an exec(), all exit handler registrations are removed.</li>
</ul>
<p><code>atexit()</code> limitations:</p>
<ul>
<li>When it is called, an exit handler doesn’t know what status was passed to exit()</li>
<li>We can’t specify an argument to the exit handler.</li>
</ul>
<p><code>int on_exit(void (*func)(int, void *), void *arg)</code> glic library function</p>
<ul>
<li>To address atexit() limitations, non-standard.</li>
<li>Functions registered using <code>atexit()</code> and <code>on_exit()</code> are placed on the same list.</li>
</ul>
<p>In an application that creates child processes, typically only one of the processes (most often the parent) should terminate via <code>exit()</code>, while the other processes should terminate via <code>_exit()</code>. This ensures that only one process calls exit handlers and flushes stdio buffers, which is usually desirable.</p>
<h2 id="nohup"><strong><code>nohup</code></strong></h2>
<p>A normal <code>foo</code> process:</p>
<ul>
<li>The process running <code>foo</code> is created by an interactive shell (connected to a terminal).</li>
<li>The process inherits <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> from the shell. Therefore it is also connected to the same terminal.</li>
<li>If the shell receives a <code>SIGHUP</code>, it also sends a <code>SIGHUP</code> to the process (which normally causes the process to terminate).</li>
<li>Otherwise the shell waits (is blocked) until the process terminates or gets stopped.</li>
</ul>
<p>if you put the process in the background at start, that is, <code>foo &amp;</code>:</p>
<ul>
<li>The process running <code>foo</code> is created, shell will not wait for its completion.</li>
<li>The process inherits <code>stdout</code>/<code>stderr</code> from the shell (so it still writes to the terminal).</li>
<li>The process in principle also inherits <code>stdin</code>, but as soon as it tries to read from <code>stdin</code>, it is blocked.</li>
<li>It is put into the list of background jobs the shell manages, which means especially:
<ul>
<li>It is listed with jobs and can be accessed using <code>%n</code> (where <code>n</code> is the job number).</li>
<li>It can be turned into a foreground job using <code>fg</code>, in which case it continues as if you would not have used <code>&amp;</code> on it (and if it was stopped due to trying to read from standard input, it now can proceed to read from the terminal).</li>
<li>If the shell received a <code>SIGHUP</code>, it also sends a <code>SIGHUP</code> to the process. Depending on the shell and possibly on options set for the shell, when terminating the shell it will also send a <code>SIGHUP</code> to the process.</li>
</ul>
</li>
</ul>
<p><strong><code>disown</code></strong></p>
<p><code>disown</code> removes the job from the shell's job list/control. <code>disown</code> is purely internal to the shell; it causes the shell not to send <code>SIGHUP</code> when it terminates.</p>
<p>However note that it still is connected to the terminal, so if the terminal is destroyed (which can happen if it was a pty, like those created by <code>xterm</code> or <code>ssh</code>, and the controlling program is terminated, by closing the <code>xterm</code> or terminating the SSH connection), the program will fail as soon as it tries to read from standard input or write to standard output.</p>
<p><strong><code>nohup</code></strong></p>
<p><code>nohup</code> is to effectively separate the process from the terminal, ie. the program not to have a controlling terminal, so that it won't be sent <code>SIGHUP</code> by the kernel when the terminal is closed.</p>
<ul>
<li>It closes process's standard input (the program will not be able to read any input, even if it is run in the foreground. it is not halted, but will receive an error code or <code>EOF</code>).</li>
<li>It redirects process's standard output and standard error to the file <code>nohup.out</code>, so the program won't fail for writing to standard output if the terminal fails.</li>
<li>It prevents the process from receiving a <code>SIGHUP</code> (thus the name).</li>
</ul>
<p>Note that nohup does not remove the process from the shell's job control and also doesn't put it in the background (but since a foreground nohup job is more or less useless, you'd generally put it into the background using <code>&amp;</code>). For example, unlike with disown, the shell will still tell you when the nohup job has completed (unless the shell is terminated before, of course).</p>
<br>
<h1 id="process-monitoring">Process monitoring</h1>
<h2 id="wait-system-call"><code>wait()</code> system call</h2>
<ul>
<li>If there are multiple terminated children at a particular moment, SUSv3 leaves unspecified the order in which these children will be reaped by a sequence of wait(). Even across versions of the Linux kernel, the behavior varies.</li>
</ul>
<p>Limitation:</p>
<ul>
<li>it is not possible to wait() for the completion of a specific child;</li>
<li>If no child has yet terminated, wait() always blocks.</li>
<li>It is only when a child process terminates. It is not possible to be notified when a child is stopped by a signal (such as SIGSTOP or SIGTTIN) or when a stopped child is resumed by delivery of a SIGCONT signal.</li>
</ul>
<h3 id="waitpid-system-call">waitpid() system call</h3>
<ul>
<li>To address wait() limitations.</li>
<li>A WNOHANG flag to essentially make wait() non-blocking.</li>
</ul>
<h3 id="waitid-system-call">waitid() system call</h3>
<ul>
<li>Similar to waitpid(), but provides more functionality. The most significant difference between waitpid() and waitid() is that waitid() provides more precise control of the child events that should be waited for.</li>
</ul>
<h3 id="wait3-and-wait4">wait3() and wait4()</h3>
<p>Similar to waitpid(), but wait3() and wait4() return resource usage information about the terminated child in the structure pointed to by the rusage argument. This information includes the amount of CPU time used by the process and memory management statistics.</p>
<p>The <code>wait()</code> family of functions are implemented via a single (and complicated) system
call, <code>wait4()</code>.</p>
<p><a href="#wait-kernel-implementation">refer to kernel wait implementation</a></p>
<h2 id="orphan">Orphan</h2>
<p>If a parent exits before its children, the orphaned child is adopted by init. A call to getppid() will return the value 1.</p>
<ul>
<li>This can be used as a way of determining if a child’s true parent is still alive (assuming
a child that was not created by init).</li>
<li>This is done at a task's exit. Kernel will reparent a task’s children on exit to either
another process in the current thread group or, if that fails, the init process. <code>do_exit()</code>
calls <code>exit_notify(</code>)<code>, which calls </code>forget_original_parent()<code>, which, in turn, calls </code>find_new_reaper()` to perform the reparenting.</li>
</ul>
<h2 id="zombie">Zombie</h2>
<p>A child that terminates before its parent has had a chance to perform wait(). The kernel turns the child into a zombie.</p>
<p>Most of the resources held by the child are released back to the system, The only part of the process that remains is an entry in the kernel’s process table recording (among other things) the child’s process ID, termination status, and resource usage statistics</p>
<p>a zombie process can’t be killed by a signal, not even the (silver bullet) SIGKILL. This ensures that the parent can always eventually perform a wait().</p>
<ul>
<li>When the parent does perform a wait(), the kernel removes the zombie.</li>
<li>If the parent terminates without doing a wait(), then the init process adopts the child and automatically performs a wait(), thus removing the zombie process from the system.</li>
<li>Implication: for the long-live parent process that creates numerous children, it should perform wait(), or handle the delivery of the SIGCHLD signal,</li>
</ul>
<h2 id="establish-handler-for-sigchld">Establish handler for SIGCHLD</h2>
<p>The SIGCHLD signal is sent to a parent process whenever one of its children terminates.</p>
<p>By default, this signal is ignored, but we can catch it by installing a signal handler.</p>
<ul>
<li>Within the signal handler, we can use wait() (or similar) to reap the zombie child, like below:<pre><code class="language-C++"><div><span class="hljs-keyword">while</span> (<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG) &gt; <span class="hljs-number">0</span>)
<span class="hljs-keyword">continue</span>;
</div></code></pre>
</li>
<li>Note that even though the default disposition for SIGCHLD is to be ignored, explicitly setting the disposition to SIG_IGN causes the different behavior: it causes any child process that subsequently terminates to be immediately removed from the system instead of being converted into a zombie.</li>
</ul>
<br>
<h1 id="program-execution">Program Execution</h1>
<h2 id="execve-system-call"><code>execve()</code> system call</h2>
<p>The execve() system call loads a new program into a process’s memory. During this operation, the old program is discarded, and the process’s stack, data, and heap are replaced by those of the new program. After executing various C library run-time startup code and program initialization code, the new program commences execution at its main() function.</p>
<ul>
<li>After an execve(), the process ID of the process remains the same.</li>
<li>If the set-user-ID (set-group-ID) permission bit of the new program is set,  the effective user ID is changed to that.</li>
<li>Then execve() copies the value of the process’s effective user ID into its saved set-user-ID (same for group id).</li>
<li>Successful execve() never returns. If it returns, it fails with errno set.</li>
</ul>
<h3 id="exec-library-function-family">exec() library function family</h3>
<p>Various library functions, all with names beginning with exec, are layered on top of the execve() system call.</p>
<p><img src="images/2022-02-06-11-14-26.png" alt=""></p>
<p>fexecve() - specifies the file to be execed via the open file descriptor fd, rather than as a pathname.</p>
<ul>
<li>useful for applications that want to open a file, verify its contents by performing a checksum, and then execute the file.</li>
</ul>
<h2 id="exec-of-interpreter-scripts">Exec of interpreter scripts</h2>
<p>If execve() detects that the file it has been given commences with the 2-byte sequence #!, it does below</p>
<p><img src="images/2022-02-06-11-15-19.png" alt=""></p>
<h2 id="file-descriptor-with-exec">File descriptor with exec()</h2>
<p>By default, all file descriptors opened by a program that calls exec() remain open across the exec() and are available for use by the new program.</p>
<ul>
<li>The kernel provides a <strong>close-on-exec</strong> flag for each file descriptor. If this flag is set, then the file descriptor is automatically closed during a successful exec(), but left open if the exec() fails.</li>
<li>The close-on-exec flag for a file descriptor can be accessed using the fcntl() system call.</li>
<li>Linux also allows the close-on-exec flag to be modified using two unstandardized ioctl() calls: ioctl(fd, FIOCLEX) to set, and ioctl(fd, FIONCLEX) to clear.</li>
</ul>
<p>The shell takes advantage of this feature to handle I/O redirection for the programs that it executes.</p>
<h3 id="the-steps-for-ls-tmp--dirtxt">The steps for <code>ls /tmp &gt; dir.txt</code></h3>
<ol>
<li>A fork() is performed to create a child process that is also running a copy of the shell (and thus has a copy of the command).</li>
<li>The child shell opens dir.txt for output using file descriptor 1 (standard output). One way to do that is to use <code>dup2()</code></li>
</ol>
<pre><code class="language-C++"><div>fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;dir.txt&quot;</span>, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
<span class="hljs-comment">/* rw-rw-rw- */</span>
<span class="hljs-keyword">if</span> (fd != STDOUT_FILENO) {
  <span class="hljs-built_in">dup2</span>(fd, STDOUT_FILENO);
  <span class="hljs-built_in">close</span>(fd);
}
</div></code></pre>
<ol start="3">
<li>The child shell execs the ls program. The ls program writes its output to standard output, which is the file dir.txt.</li>
</ol>
<h2 id="system-library-call">system() library call</h2>
<p>The system() function allows the calling program to execute an arbitrary shell command.The system() function creates a child process that invokes a shell to execute the command.</p>
<p>The main cost of <strong>system() is inefficiency</strong>. Executing a command using system() requires the creation of at least two processes—one for the shell and one or more for the command(s) it executes—each of which performs an exec().</p>
<ul>
<li>If efficiency or speed is a requirement, it is preferable to use explicit fork() and exec() calls to execute the desired program.</li>
</ul>
<h3 id="implementation-of-system">Implementation of system()</h3>
<p>To implement system(), we need to use fork() to create a child that then does an execl() with arguments corresponding to the shell command. To collect the status of the child created by system(), we use a waitpid() call that specifies the child’s process ID.</p>
<ul>
<li>The hard part is to handle signals correctly.</li>
<li>SIGCHLD should be blocked in calling process</li>
<li>SIGINT/SIGQUIT should be ignored in the calling process, but default in the child process.</li>
</ul>
<p><img src="images/2022-02-06-11-22-07.png" alt=""></p>
<h2 id="signals-and-exec">Signals and exec()</h2>
<ul>
<li>During an exec(), the text of the existing process is discarded. This text may include signal handlers established by the calling program.</li>
<li>Kernel resets the dispositions of all handled signals to SIG_DFL.</li>
<li>During an exec(), the process signal mask and set of pending signals are both preserved, because they are maintained in Kernel space.
<ul>
<li>This caused a bit of confusion, so it is recommended that signals should not be blocked or ignored across an exec() of an arbitrary program.</li>
</ul>
</li>
</ul>
<br>
<h1 id="kernel-internals">Kernel Internals</h1>
<h2 id="process-descriptor--task_struct">Process descriptor / task_struct</h2>
<p>The kernel stores the list of process descriptors in a circular doubly linked list called the <strong>task list</strong>.</p>
<p><img src="images/2022-02-05-11-06-53.png" alt=""></p>
<p>A <strong>process descriptor</strong> is of the type <code>struct task_struct</code>, defined in <code>&lt;linux/sched.h&gt;</code>.</p>
<ul>
<li>The task_struct is a relatively large data structure, at around 1.7 kilobytes on a 32-bit machine.</li>
<li>The task_struct structure is allocated via the slab allocator to provide object reuse and
cache coloring</li>
</ul>
<p><img src="images/2022-02-16-23-28-09.png" alt=""></p>
<p><strong>PID</strong><br>
The system identifies processes by a unique process identification value or PID.</p>
<ul>
<li>The kernel stores this value as <code>pid</code> field inside each process descriptor (<code>task_struct</code>).</li>
<li>type <code>pid_t</code>, which is typically an int.</li>
<li>For backwards compatiblity, the default maximum value is only 32,768 (that of a short int)</li>
<li>the administrator may increase the maximum value via <code>/proc/sys/kernel/pid_max</code>.</li>
<li>Standard requires threads in the same group share a common PID.
<ul>
<li>The indentifier shared by the threads is the PID of the <em>thread group leader</em>, called <code>tgid</code>.</li>
<li>The <code>getpid()</code> system call returns the value of <code>tgid</code> relative to the current process instead of the value of pid</li>
</ul>
</li>
</ul>
<p><strong>pid hashtable and chained list</strong><br>
In several circumstances, the kernel must be able to derive the process descriptor
pointer corresponding to a PID.</p>
<ul>
<li>When process P1 wishes to send a signal to another process, P2, it invokes
the kill( ) system call specifying the PID of P2 as the parameter.</li>
</ul>
<p>To speed up the search, four hash tables have been introduced, each keyed on <code>pid</code>, <code>tgid</code> (thread group leader), <code>pgrp</code> (group leader), <code>session</code> (session leader).</p>
<p><img src="images/2022-02-17-09-39-50.png" alt=""></p>
<ul>
<li>In the chain list rooted at the 71st entry of the hash table, there are two process descriptors corresponding to the PID numbers 246 and 4,351 (The PID numbers are stored in the <code>nr</code> field)</li>
<li>It also maintains a list of processes for each thread group, chained with <code>pid_list</code> field.</li>
</ul>
<p><strong>Process State</strong><br></p>
<p><strong>TASK_RUNNING</strong><br>
The process is runnable; it is either currently running or on a runqueue waiting to run.</p>
<p><strong>TASK_INTERRUPTIBLE</strong>:  S state in ps(1)
<br>The process is sleeping, blocked waiting for some condition to exist. When this condition exists, the kernel sets the process’s state to TASK_RUNNING.The process also awakes prematurely and becomes runnable if it receives a signal.</p>
<p><strong>TASK_UNINTERRUPTIBLE</strong>: D state in ps(1) <br>
The process is waiting on certain special classes of events without interruption, such as the completion of a disk I/O. The signal is not delivered until the process is out of this state.</p>
<p>In rare circumstances, a process may remain hung in this state, perhaps as the result of a hardware failure, an NFS problem, or a kernel bug. Because the task will not respond to signals, SIGKILL won’t terminate the hung process. If the underlying problem can’t otherwise be resolved, then we must restart the system in order to eliminate the process.</p>
<p><strong>TASK_STOPPED</strong> <br>
Process execution has stopped. This occurs if the task receives the SIGSTOP, SIGTSTP, SIGTTIN, or
SIGTTOU signal or if it receives any signal while it is being debugged.</p>
<p><strong>TASK_TRACED</strong> <br>
The process is being traced by another process, such as a debugger, via ptrace.</p>
<h3 id="how-to-find-current-processs-task_struct">How to find current process's task_struct?</h3>
<p><code>struct thread_info</code>, was created that lives at the bottom of the stack. It has a pointer to the task's actual <code>task_struct</code> (dynamically allcoated by slab allocator).</p>
<ul>
<li>x86 makes use of the fact that struct <code>thread_info</code> is stored on the kernel stack to calculate
the location of <code>thread_info</code> and subsequently the <code>task_struct</code>.
<ul>
<li><code>current_thread_info()</code> (in <code>&lt;asm/thread_info.h&gt;</code>) is calculated by masking out the 13 least-significant bits (assuming 8KB stack size) of the stack pointer to obtain the thread_info structure.</li>
</ul>
</li>
</ul>
<p><img src="images/2022-03-01-13-19-12.png" alt=""></p>
<p>After kernel v4.14, task_struct can be allocated by vmalloc, the way to use <code>thread_info</code> to find current <code>task_struct</code> is not used anymore. Now, <code>task_struct</code> is a per-cpu value.</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> current get_current()</span>

<span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline struct task_struct *<span class="hljs-title">get_current</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">percpu_read_stable</span>(current_task);
}

<span class="hljs-built_in">DECLARE_PER_CPU</span>(struct task_struct*, current_task);
</div></code></pre>
<h3 id="process-context--and-interrupt-context">Process Context  and Interrupt Context</h3>
<p>Normal program execution occurs in user-space.When a program executes a <strong>system call</strong> or triggers an <strong>exception</strong>, it enters kernel-space. At this point, the kernel is said to be “executing on behalf of the process” and is in process context.</p>
<ul>
<li>System calls and exception handlers are well-defined interfaces into the kernel.A
process can begin executing in kernel-space only through one of these interfaces</li>
</ul>
<p>In interrupt context, the system is not running on behalf of a process but is executing
an interrupt handler. No process is tied to interrupt handlers.</p>
<h3 id="process-family-tree">Process Family Tree</h3>
<p>Each task_struct has a pointer to the parent’s task_struct, named <em>parent</em>, and a list of children, named <em>children</em>.</p>
<table>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>real_parent</td>
<td>Points to the process descriptor of the process that created P or to the descriptor of process 1 (init) if the parent process no longer exists. (Therefore, when a user starts a background process and exits the shell, the background process becomes the child of init.)</td>
</tr>
<tr>
<td>parent</td>
<td>Points to the current parent of P (this is the process that must be signaled when the child process terminates); its value usually coincides with that of real_parent. It may occasionally differ, such as when another process issues a ptrace( ) system call requesting that it be allowed to monitor P</td>
</tr>
<tr>
<td>children</td>
<td>The head of the list containing all children created by P.</td>
</tr>
<tr>
<td>sibling</td>
<td>The pointers to the next and previous elements in the list of the sibling processes, those that have the same parent as P.</td>
</tr>
</tbody>
</table>
<pre><code class="language-C++"><div><span class="hljs-comment">// obtain the process descriptor of its parent with the following code:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">my_parent</span> =</span> current-&gt;parent;

<span class="hljs-comment">//iterate over a process’s children with</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">list</span>;</span>
<span class="hljs-built_in">list_for_each</span>(list, &amp;current-&gt;children) {
    task = <span class="hljs-built_in">list_entry</span>(list, struct task_struct, sibling);
    <span class="hljs-comment">/* task now points to one of current’s children */</span>
}

<span class="hljs-comment">// find init process</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span>
<span class="hljs-keyword">for</span> (task = current; task != &amp;init_task; task = task-&gt;parent)
  ;
<span class="hljs-comment">/* task now points to init */</span>

<span class="hljs-comment">// iterate over the entire task list (an expensive operation)</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span>
for_each_process(task) {
  <span class="hljs-comment">/* this pointlessly prints the name and PID of each task */</span>
  <span class="hljs-built_in">printk</span>(“%s[%d]\n”, task-&gt;comm, task-&gt;pid);
}
</div></code></pre>
<h2 id="clone-system-call">clone() system call</h2>
<p>Linux specific.</p>
<ul>
<li>the cloned child doesn’t continue from the point of the call, but instead commences by calling the function specified in the func argument</li>
<li>The cloned child process terminates either when func returns (in which case its return value is the exit status of the process) or when the process makes a call to exit().</li>
<li>Since a cloned child may (like vfork()) share the parent’s memory, it can’t use the parent’s stack. Instead, the caller must allocate a suitably sized block of memory and pass a pointer to that block in the argument child_stack.</li>
<li>The clone() flags argument let you select the child process's termination signal. When the child process is terminated, that signal is sent to the parent.</li>
</ul>
<p>The clone() flag is also a bit mask that controls the operation of clone(), it is defined in <code>&lt;linux/sched.h&gt;</code>,</p>
<ul>
<li>CLONE_FILES:
<ul>
<li>If set, the parent and the child share the same table of open file descriptors, this is different from fork().</li>
<li>If not set, the child gets a copy of the parent's table, same as fork().</li>
</ul>
</li>
<li>CLOSE_FS
<ul>
<li>If set, parent and child share file system related info - umask, root dir, current working dir. I.e, umaks(), chdir(), chroot() will affect each other.</li>
<li>If not set, parent and child have separate copies of this information, same as fork().</li>
</ul>
</li>
<li>CLONE_SIGHAND
<ul>
<li>If set, parent and child share the same table of signal dispositions. Using sigaction() or signal() to change a signal’s disposition will affect each other.</li>
<li>If not set, not shared, the child gets a copy of the parent’s signal disposition table, same as fork().</li>
</ul>
</li>
<li>CLONE_VM</li>
<li>If set, then the parent and child share the same virtual memory pages, same as vfork(). Updates to memory or calls to mmap() or munmap() by either process will be visible to the other process.</li>
<li>If not set, not shared, same as fork().</li>
</ul>
<p>Roughly speaking,</p>
<ul>
<li>fork() is clone() with flag SIGCHLD (using SIGCHLD as child termination signal)</li>
<li>vfork() is clone() with flag CLONE_VM | CLONE_VFORK | SIGCHLD</li>
<li>glibc wrapper fork() provided as part of the NPTL threading implementation bypasses the kernel’s fork() system call and invokes clone().</li>
<li>LinuxThreads threading implementation uses clone() with CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND<pre><code class="language-C++"><div><span class="hljs-built_in">clone</span>(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="hljs-number">0</span>);
</div></code></pre>
This results in behavior identical to a normal fork(), except that the
address space, filesystem resources, file descriptors, and signal handlers are shared.</li>
<li>NPTL threading implementation uses clone() (with all seven arguments): CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</li>
</ul>
<h3 id="clone-kernel-implementation">clone() kernel implementation</h3>
<p>The bulk of the work in forking is handled by do_fork(), which is defined in
<code>kernel/fork.c</code>.This function calls <code>copy_process()</code> and then starts the process running.</p>
<p>The interesting work is done by <code>copy_process()</code>:</p>
<ol>
<li>It calls dup_task_struct(), which creates a new kernel stack, thread_info structure,
and task_struct for the new process.The new values are identical to those of
the current task. At this point, the child and parent process descriptors are identical.</li>
<li>It then checks that the new child will not exceed the resource limits on the number
of processes for the current user.</li>
<li>The child needs to differentiate itself from its parent.Various members of the
process descriptor are cleared or set to initial values. Members of the process
descriptor not inherited are primarily statistically information.The bulk of the values
in task_struct remain unchanged.</li>
<li>The child’s state is set to TASK_UNINTERRUPTIBLE to ensure that it does not yet run.</li>
<li>copy_process() calls copy_flags() to update the flags member of the
task_struct.The PF_SUPERPRIV flag, which denotes whether a task used superuser
privileges, is cleared.The PF_FORKNOEXEC flag, which denotes a process that has
not called exec(), is set.</li>
<li>It calls alloc_pid() to assign an available PID to the new task.</li>
<li>Depending on the flags passed to clone(), copy_process() either duplicates or
shares open files, filesystem information, signal handlers, process address space, and
namespace.These resources are typically shared between threads in a given process;
otherwise they are unique and thus copied here.</li>
<li>Finally, copy_process() cleans up and returns to the caller a pointer to the new
child.</li>
</ol>
<p>Back in do_fork(), if copy_process() returns successfully, the new child is woken up
and run. Deliberately, the kernel runs the child process first.8 In the common case of the
child simply calling exec() immediately, this eliminates any copy-on-write overhead that
would occur if the parent ran first and began writing to the address space.</p>
<h2 id="do_exit-kernel-implementation">do_exit() kernel implementation</h2>
<p>Regardless of how a process terminates, the bulk of the work is handled by do_exit(), defined in
<code>&lt;kernel/exit.c&gt;</code>, which completes a number of chores:</p>
<ol>
<li>It sets the PF_EXITING flag in the flags member of the task_struct.</li>
<li>It calls del_timer_sync() to remove any kernel timers. Upon return, it is guaranteed
that no timer is queued and that no timer handler is running.</li>
<li>If BSD process accounting is enabled, do_exit() calls acct_update_integrals()
to write out accounting information.</li>
<li>It calls exit_mm() to release the mm_struct held by this process. If no other process
is using this address space—that it, if the address space is not shared—the kernel
then destroys it.</li>
<li>It calls exit_sem(). If the process is queued waiting for an IPC semaphore, it is
dequeued here.</li>
<li>It then calls exit_files() and exit_fs() to decrement the usage count of objects
related to file descriptors and filesystem data, respectively. If either usage counts
reach zero, the object is no longer in use by any process, and it is destroyed.</li>
<li>It sets the task’s exit code, stored in the exit_code member of the task_struct, to
the code provided by exit() or whatever kernel mechanism forced the termination.
The exit code is stored here for optional retrieval by the parent.</li>
<li>It calls exit_notify() to send signals to the task’s parent, reparents any of the task’s
children to another thread in their thread group or the init process, and sets the
task’s exit state, stored in exit_state in the task_struct structure, to EXIT_ZOMBIE.</li>
<li>do_exit() calls schedule() to switch to a new process. Because
the process is now not-schedulable, this is the last code the task will ever execute.
do_exit() never returns.</li>
</ol>
<p>At this point, all objects associated with the task (assuming the task was the sole user)
are freed. The task is not runnable (and no longer has an address space in which to run)
and is in the EXIT_ZOMBIE exit state. The only memory it occupies is its kernel stack, the
thread_info structure, and the task_struct structure. The task exists solely to provide
information to its parent. After the parent retrieves the information, or notifies the kernel
that it is uninterested, the remaining memory held by the process is freed and returned to
the system for use.</p>
<h2 id="wait-kernel-implementation">wait() kernel implementation</h2>
<p>The wait() family of functions are implemented via a single (and complicated) system
call, wait4().</p>
<p>The standard behavior is to suspend execution of the calling task until one
of its children exits, at which time the function returns with the PID of the exited child.
Additionally, a pointer is provided to the function that on return holds the exit code of
the terminated child.</p>
<p>When it is time to finally deallocate the process descriptor, release_task() is
invoked. It does the following:</p>
<ol>
<li>It calls __exit_signal(), which calls __unhash_process(), which in turns calls
detach_pid() to remove the process from the pidhash and remove the process
from the task list.</li>
<li>__exit_signal() releases any remaining resources used by the now dead process
and finalizes statistics and bookkeeping.</li>
<li>If the task was the last member of a thread group, and the leader is a zombie, then
release_task() notifies the zombie leader’s parent.</li>
<li>release_task() calls put_task_struct() to free the pages containing the
process’s kernel stack and thread_info structure and deallocate the slab cache containing
the task_struct.</li>
</ol>
<p>At this point, the process descriptor and all resources belonging solely to the process
have been freed.</p>
<h2 id="kernel-threads">Kernel threads</h2>
<p>It is often useful for the kernel to perform some operations in the background as demons. The kernel
accomplishes this via kernel threads — standard processes that exist solely in kernel space.</p>
<ul>
<li>In ‘ps’ output, the names are surrounded by square brackets ([]).</li>
<li>Example: pdflush - it periodically flush dirty pages from buffer cache to disk.</li>
<li>They operate only in kernel-space and do not context switch into user-space.</li>
<li>However, they are schedulable and preemptable, the same as normal processes.</li>
</ul>
<p>kernel threads do not have an address space.</p>
<ul>
<li>Their <code>mm</code> pointer, which points at their address space, is NULL. The <code>active_mm</code> points to the <code>mm</code> of the previous runnig process so that it can use that page table.</li>
</ul>
<p>A kernel thread is created by forking off of the <code>kthreadd</code> kernel process, the PID of <code>kthreadd</code> is 2.</p>
<p>The interface declared in <code>&lt;linux/kthread.h&gt;</code> for spawning a new kernel thread from an existing one:</p>
<pre><code class="language-C++"><div><span class="hljs-function">struct task_struct *<span class="hljs-title">kthread_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*threadfn)(<span class="hljs-keyword">void</span> *data),
                                    <span class="hljs-keyword">void</span> *data,
                                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> namefmt[],
                                    ...)</span>
</span></div></code></pre>
<p>The new task is created via the clone() system call by the kthread kernel process.The
new process will run the threadfn function, which is passed the data argument.The
process will be named namefmt, which takes printf-style formatting arguments in the variable
argument list. The process is created in an unrunnable state; it will not start running
until explicitly woken up via wake_up_process(). A routine, <code>kthread_run()</code>, implemented as a macro, simply calls both kthread_create() and wake_up_process():</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> kthread_run(threadfn, data, namefmt, ...) \
({ \
    struct task_struct *k; \
    k = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \
    <span class="hljs-meta-keyword">if</span> (!IS_ERR(k)) \
      wake_up_process(k); \
    k; \
})</span>
</div></code></pre>

        
        
    </body>
    </html>