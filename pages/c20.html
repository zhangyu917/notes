<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>C&plus;&plus;20</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.13.24"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
#button { display: inline-block; background-color: #FF9800; width: 50px; height: 50px; text-align: center; border-radius: 4px; position: fixed; bottom: 30px; right: 30px; transition: background-color .3s, opacity .5s, visibility .5s; opacity: 0; /*visibility: hidden;*/ z-index: 1000; } #button::after { content: "\f077"; font-family: FontAwesome; font-weight: normal; font-style: normal; font-size: 2em; line-height: 50px; color: #fff; } #button:hover { cursor: pointer; background-color: #333; } #button:active { background-color: #555; } #button.show { opacity: 1; visibility: visible; } #btn-back-to-top { position: fixed; bottom: 20px; right: 20px; display: none; } .to-top { background: white; position: fixed; bottom: 16px; right:32px; width:50px; height:50px; border-radius: 50%; border-color: white; display: flex; align-items: center; justify-content: center; font-size:32px; color:#1f1f1f; text-decoration: none; opacity: 0.5; pointer-events: auto; transition: all .4s; transform: rotate(270deg); } 
</style>
    </head>
    <body class="vscode-body vscode-light">
        <!-- title: C++20 -->
<h1>C++20 Features</h1>
<p><a href="#" class="to-top">➤</i></a></p>
<ul>
<li><a href="#operator-"><code>Operator &lt;=&gt;()</code></a>
<ul>
<li><a href="#overload-resolution-with-rewritten-expressions">Overload Resolution with Rewritten Expressions</a></li>
</ul>
</li>
<li><a href="#auto-for-function-parameters"><code>auto</code> for function parameters</a></li>
<li><a href="#concepts">Concepts</a>
<ul>
<li><a href="#constraints">Constraints</a></li>
<li><a href="#concepts-1">Concepts</a></li>
</ul>
</li>
<li><a href="#std-concepts">std concepts</a></li>
<li><a href="#ranges-and-views">Ranges and Views</a></li>
<li><a href="#spans">Spans</a></li>
<li><a href="#module">Module</a>
<ul>
<li><a href="#modules-with-multiple-files">Modules with Multiple Files</a></li>
</ul>
</li>
<li><a href="#lambda-extensions">Lambda Extensions</a></li>
<li><a href="#stdformat"><code>std::format</code></a></li>
<li><a href="#constinit-consteval-and-compile-time-computing"><code>constinit</code>, <code>consteval</code>, and Compile-Time Computing</a>
<ul>
<li><a href="#constint"><code>constint</code></a></li>
<li><a href="#consteval"><code>consteval</code></a></li>
<li><a href="#stdis_constant_evaluated"><code>std::is_constant_evaluated()</code></a></li>
<li><a href="#compile-time-stdvector-and-stdstring">Compile-time <code>std::vector</code> and <code>std::string</code></a></li>
</ul>
</li>
<li><a href="#non-type-template-parameter-nttp-extensions">Non-Type Template Parameter (NTTP) Extensions</a></li>
<li><a href="#new-type-traits">New Type Traits</a></li>
<li><a href="#small-language-improvements">Small Language Improvements</a>
<ul>
<li><a href="#range-based-for-loop-with-initialization">Range-Based <code>for</code> Loop with Initialization</a></li>
<li><a href="#using-for-enumeration-values"><code>using</code> for Enumeration Values</a></li>
<li><a href="#char8_t-and-stdu8string"><code>char8_t</code> and <code>std::u8string</code></a></li>
<li><a href="#designated-initializers-for-aggregates">Designated Initializers for Aggregates</a></li>
<li><a href="#aggregate-initialization-with-parentheses">Aggregate Initialization with Parentheses</a></li>
<li><a href="#attributes-likely-and-unlikely">Attributes<code> [[likely]]</code> and <code>[[unlikely]]</code></a></li>
<li><a href="#attribute-no_unique_address">Attribute <code>[[no_unique_address]]</code></a></li>
<li><a href="#implicit-typename-for-type-members-of-template-parameters">Implicit <code>typename</code> for Type Members of Template Parameters</a></li>
<li><a href="#ctad-for-aggregates"><em>CTAD</em> for Aggregates</a></li>
<li><a href="#conditional-explicit">conditional <code>explicit</code></a></li>
</ul>
</li>
<li><a href="#stl-improvements">STL improvements</a></li>
<li><a href="#corouties">Corouties</a></li>
<li><a href="#concurrency-features">Concurrency features</a>
<ul>
<li><a href="#stdjthread-and-stop-tokens"><code>std::jthread</code> and stop tokens</a></li>
<li><a href="#stdlatch"><code>std::latch</code></a></li>
<li><a href="#stdbarrier"><code>std::barrier&lt;&gt;</code></a></li>
<li><a href="#stdcounting_semaphorestdptrdiff_t-leastmaxvalue-and-stdbinary_semaphore"><code>std::counting_semaphore&lt;std::ptrdiff_t LeastMaxValue&gt;</code> and <code>std::binary_semaphore</code></a></li>
<li><a href="#stdatom_ref"><code>std::atom_ref&lt;&gt;</code></a></li>
<li><a href="#stdatomicstdshared_ptrt">std::atomic&lt;std::shared_ptr<T>&gt;</a></li>
<li><a href="#atomic-floating-point-types">Atomic Floating-Point Types</a></li>
<li><a href="#stdatomic-wait-and-notify_"><code>std::atomic</code> <code>wait()</code> and <code>notify_*()</code></a></li>
<li><a href="#stdosyncstream"><code>std::osyncstream</code></a></li>
</ul>
</li>
</ul>
<p><img src="images/2022-04-05-13-29-37.png" alt=""></p>
<p>C++20 draft (post Prague, March 2020 draft):
<a href="https://timsong-cpp.github.io/cppwp/n4861/">https://timsong-cpp.github.io/cppwp/n4861/</a></p>
<p>compiler support at C++ Reference:
<a href="https://en.cppreference.com/w/cpp/compiler_support#cpp20">https://en.cppreference.com/w/cpp/compiler_support#cpp20</a></p>
<p>comparison of changes between C++17 and C++20:
<a href="https://wg21.link/P2131">P2131</a> by Thomas Köppe</p>
<br>
<h1 id="operator-"><code>Operator &lt;=&gt;()</code></h1>
<p><a href="http://wg21.link/p0768r1">http://wg21.link/p0768r1</a>, <a href="http://wg21.link/p1185r2">http://wg21.link/p1185r2</a> and <a href="http://wg21.link/p1630r1">http://wg21.link/p1630r1</a></p>
<p>Before C++20 you had to define six operators (<code>operator==</code>, <code>operator!=</code>, <code>operator&lt;</code>, <code>operator&lt;=</code>, <code>operator&gt;</code>, <code>operator&gt;=</code>) for a type to provide full support for all possible comparisons of its objects.</p>
<p>Every type should either</p>
<ul>
<li>overload <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code> (ordering)</li>
<li>overload only <code>==</code>, <code>!=</code> (equality)</li>
<li>overload none of these</li>
</ul>
<p>Copying and equality is closely related. What is compared should be a subset of what is copied (in copy constructor)</p>
<ul>
<li>strong equality: everything that is copied is compared</li>
<li>weak equality (rare in practice): a proper subset of what is copied is compared</li>
</ul>
<p>Since C++20:</p>
<p><strong><code>Operator==</code> Implies <code>Operator!=</code></strong></p>
<p>When the compiler finds no implementation for an expression a!=b, the compiler will try below expressions, in order.</p>
<pre><code class="language-C++"><div>a != b <span class="hljs-comment">// tries: a!=b, !(a==b), and !(b==a)</span>
</div></code></pre>
<p><strong>default <code>operator&lt;=&gt;()</code></strong></p>
<p>by declaring an <code>operator&lt;=&gt;</code> with <code>=default</code>, compiler generates an implicit member <code>operator==</code>. Both default operators compare objects member by member. This means that the <strong>order of the members matters</strong>.</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span> {</span>
  ...
  <span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>&lt;=&gt; (<span class="hljs-keyword">const</span> Value&amp; rhs) <span class="hljs-keyword">const</span>  = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// return type is one of Comparison Category, eg,  std::strong_ordering. implicit constexpr.</span>
  <span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-keyword">const</span> Value&amp; rhs) <span class="hljs-keyword">const</span>  = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// implicitly generated, return type: bool, implicit constexpr.</span>
};

Value a, b;
a &lt; b ; <span class="hljs-comment">// compiler converts to a.operator&lt;=&gt;(b) &lt; 0</span>
a &gt;= b; <span class="hljs-comment">// compiler converts to a.operator&lt;=&gt;(b) &gt;= 0</span>
</div></code></pre>
<p><strong>Simple user-defined <code>operator&lt;=&gt;()</code></strong></p>
<p>When user defines a user-defined <code>opeartor&lt;=&gt;</code>, the equality operator <code>operator==</code> is not implicitly generated anymore. User has to provide its own <code>operator==</code>, otherwise it won't compile when you check equality. The reason is compiler doesn't want to imply <code>==</code> from <code>&lt;=&gt;</code> as <code>==</code> can potentially be more efficiently implemented (such as when comparing two ranges).</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;compare&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span> {</span>
 <span class="hljs-keyword">private</span>:
  <span class="hljs-keyword">long</span> id;
  <span class="hljs-comment">//...</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Value</span><span class="hljs-params">(<span class="hljs-keyword">long</span> i)</span> <span class="hljs-keyword">noexcept</span>
   : id{</span>i} {
  }

  <span class="hljs-comment">// for equality operators:</span>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-keyword">const</span> Value&amp; rhs) <span class="hljs-keyword">const</span> { 
    <span class="hljs-keyword">return</span> id == rhs.id;      <span class="hljs-comment">// defines equality (== and !=)</span>
  }
  <span class="hljs-comment">// for relational operators:</span>
  <span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>&lt;=&gt; (<span class="hljs-keyword">const</span> Value&amp; rhs) <span class="hljs-keyword">const</span> { 
    <span class="hljs-keyword">return</span> id &lt;=&gt; rhs.id;     <span class="hljs-comment">// defines ordering (&lt;, &lt;=, &gt;, and &gt;=)</span>
  }
};
</div></code></pre>
<p>Comparison Category (defined in header <code>&lt;compare&gt;</code>):</p>
<ul>
<li><code>std::strong_ordering</code>: a value of a given type is either less than or equal to or greater than any other value. Typical example: integer types and string types.</li>
<li><code>std::weak_ordering</code>: a value of a given type is either less than or <em>equivalent</em> to or greater than any other value. <em>Equivalent</em> values do not have to be equal. Example: case-insensitive strings. &quot;hello&quot; and &quot;HELLO&quot; are equivalent but not equal.
<ul>
<li>you can sort weak ordering objects in ascending or descending order (with equivalent values having any order among each other).</li>
</ul>
</li>
<li><code>std::partial_ordering</code>: a value of a given type <em>could</em> either be less than or equivalent to or greater than any other value of this type.
<ul>
<li>A typical example of this category is a floating-point type. Because it has the special value NaN (“not a number”). Any comparison with NaN yields false.</li>
<li>multiple partial ordering objects are not able to be sorted in ascending or descending order (unless you ensure that values that cannot be ordered are not there).</li>
</ul>
</li>
</ul>
<p>You can think of the comparsion category as below <em>conceptually</em> (not how it is really implemented):</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">weak_ordering</span> {</span> <span class="hljs-comment">// this type can only compare with 0</span>
  less = <span class="hljs-number">-1</span>,
  equivalent = <span class="hljs-number">0</span>,
  greater = <span class="hljs-number">1</span>
}

<span class="hljs-keyword">enum</span> class strong_ordering { <span class="hljs-comment">// this type can only compare with 0</span>
  less = <span class="hljs-number">-1</span>,
  equal = <span class="hljs-number">0</span>,
  equivalent = <span class="hljs-number">0</span>,
  greater = <span class="hljs-number">1</span>
}
</div></code></pre>
<p>The new <code>operator &lt;=&gt;</code> returns a value of one of the comparison category types, representing the result
of the comparison combined with the information whether this result is able to create a strong/total, weak, or partial ordering.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">int</span> x = <span class="hljs-number">17</span>, y = <span class="hljs-number">42</span>;
x &lt;=&gt; y <span class="hljs-comment">// yields std::strong_ordering::less</span>
x &lt;=&gt; <span class="hljs-number">17.0</span> <span class="hljs-comment">// yields std::partial_ordering::equivalent</span>
&amp;x &lt;=&gt; &amp;x <span class="hljs-comment">// yields std::strong_ordering::equal</span>
&amp;x &lt;=&gt; <span class="hljs-literal">nullptr</span> <span class="hljs-comment">// ERROR: relational comparison with nullptr not supported</span>
std::string{<span class="hljs-string">&quot;hi&quot;</span>} &lt;=&gt; <span class="hljs-string">&quot;hi&quot;</span> <span class="hljs-comment">// yields std::strong_ordering::equal;</span>
std::pair{<span class="hljs-number">42</span>, <span class="hljs-number">0.0</span>} &lt;=&gt; std::pair{<span class="hljs-number">42</span>, <span class="hljs-number">7.7</span>} <span class="hljs-comment">// yields std::partial_ordering::less</span>
</div></code></pre>
<p><strong>user-defined <code>operator&lt;=&gt;()</code> with comparsion category</strong></p>
<p>if all sub-comparsions have same comparsion categories, we can use <code>auto</code> return.</p>
<pre><code class="language-C++"><div>  <span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>&lt;=&gt; (<span class="hljs-keyword">const</span> Person&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">auto</span> cmp1 = lastname &lt;=&gt; rhs.lastname;    <span class="hljs-comment">// primary member for ordering</span>
    <span class="hljs-keyword">if</span> (cmp1 != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cmp1;               <span class="hljs-comment">// return result if not equal</span>
    <span class="hljs-keyword">auto</span> cmp2 = firstname &lt;=&gt; rhs.firstname;  <span class="hljs-comment">// secondary member for ordering</span>
    <span class="hljs-keyword">if</span> (cmp2 != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cmp2;               <span class="hljs-comment">// return result if not equal</span>
    <span class="hljs-keyword">return</span> value &lt;=&gt; rhs.value;               <span class="hljs-comment">// final member for ordering</span>
  }
</div></code></pre>
<p>If sub-comparsions have different comparsion categories, we need to return to weekeast comparsion type.</p>
<pre><code class="language-C++"><div>  std::partial_ordering <span class="hljs-keyword">operator</span>&lt;=&gt; (<span class="hljs-keyword">const</span> Person&amp; rhs) <span class="hljs-keyword">const</span> {  <span class="hljs-comment">// OK</span>
    <span class="hljs-keyword">auto</span> cmp1 = name &lt;=&gt; rhs.name;
    <span class="hljs-keyword">if</span> (cmp1 != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cmp1;    <span class="hljs-comment">// strong_ordering converted to return type</span>
    <span class="hljs-keyword">return</span> value &lt;=&gt; rhs.value;    <span class="hljs-comment">// value is double here, partial_ordering used as the return type</span>
  }
</div></code></pre>
<p>If we don't know the comparsion type (eg. type is a template parameter) you can use a new type
trait <code>std::common_comparison_category&lt;&gt;</code> that computes the strongest comparison category</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>&lt;=&gt; (<span class="hljs-keyword">const</span> Person&amp; rhs) <span class="hljs-keyword">const</span>    <span class="hljs-comment">// OK</span>
   -&gt; std::<span class="hljs-keyword">common_comparison_category_t</span>&lt;<span class="hljs-keyword">decltype</span>(name &lt;=&gt; rhs.name),
                                        <span class="hljs-keyword">decltype</span>(value &lt;=&gt; rhs.value)&gt; {
    <span class="hljs-keyword">auto</span> cmp1 = name &lt;=&gt; rhs.name;
    <span class="hljs-keyword">if</span> (cmp1 != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cmp1;    <span class="hljs-comment">// used as or converted to common comparison type</span>
    <span class="hljs-keyword">return</span> value &lt;=&gt; rhs.value;    <span class="hljs-comment">// used as or converted to common comparison type</span>
  }
</div></code></pre>
<p>If you want to force the <code>std::strong_ordering</code> return, C++ standard library provides some helper function. eg, to map floating-point
values you can call <code>std::strong_order()</code> for the two values to compare.</p>
<pre><code class="language-C++"><div>  std::strong_ordering <span class="hljs-keyword">operator</span>&lt;=&gt; (<span class="hljs-keyword">const</span> Person&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">auto</span> cmp1 = name &lt;=&gt; rhs.name;
    <span class="hljs-keyword">if</span> (cmp1 != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cmp1;      <span class="hljs-comment">// return strong_ordering for std::string</span>
    <span class="hljs-comment">// value is double here, map floating-point comparison result to strong ordering:</span>
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">strong_order</span>(value, rhs.value);
  }
</div></code></pre>
<p>Note that <code>std::string</code>, for the sake of performance, has a custom implemented <code>operator==</code> (provides == and !=) and <code>operator&lt;=&gt;</code> (provides the rest). All comparisons are done via the <code>compare()</code> member function (which itself is defined in terms of <code>Traits::compare()</code>):</p>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string/operator_cmp">https://en.cppreference.com/w/cpp/string/basic_string/operator_cmp</a></p>
<h2 id="overload-resolution-with-rewritten-expressions">Overload Resolution with Rewritten Expressions</h2>
<p>To compile</p>
<ul>
<li><code>x != y</code></li>
</ul>
<p>the compiler now might try all of the following:</p>
<pre><code class="language-C++"><div>x.<span class="hljs-keyword">operator</span>!=(y)      <span class="hljs-comment">// calling member operator!= for x</span>
<span class="hljs-keyword">operator</span>!=(x, y)     <span class="hljs-comment">// calling a free-standing operator!= for x and y</span>

!x.<span class="hljs-keyword">operator</span>==(y)     <span class="hljs-comment">// calling member operator== for x, rewrite as !(x==y)</span>
!<span class="hljs-keyword">operator</span>==(x, y)    <span class="hljs-comment">// calling a free-standing operator== for x and y, rewrite as !(x==y)</span>

<span class="hljs-comment">// If an implicit type conversion for the first operand x (to v) is necessary</span>
<span class="hljs-keyword">operator</span>!=(v, y)     <span class="hljs-comment">// calling a free-standing operator!=</span>
!<span class="hljs-keyword">operator</span>==(v, y)    <span class="hljs-comment">// calling a free-standing operator==</span>

!y.<span class="hljs-keyword">operator</span>==(v)     <span class="hljs-comment">// calling member operator== for y</span>
</div></code></pre>
<p>An example:</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> {</span>
  <span class="hljs-keyword">int</span> x, y;
  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">int</span> rhs) <span class="hljs-keyword">const</span>
  { <span class="hljs-keyword">return</span> rhs == x &amp;&amp; rhs == y; }
};

<span class="hljs-keyword">constexpr</span> Point a{<span class="hljs-number">3</span>, <span class="hljs-number">3</span>};
<span class="hljs-built_in"><span class="hljs-keyword">static_assert</span></span>(b==<span class="hljs-number">3</span>); <span class="hljs-comment">// always works</span>
<span class="hljs-built_in"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-number">3</span>==b); <span class="hljs-comment">// Doesn&#x27;t work before, works since C++20</span>
</div></code></pre>
<p>To compile</p>
<ul>
<li><code>x &lt;= y</code></li>
</ul>
<p>The compiler now might try all of the following</p>
<pre><code class="language-C++"><div>x.<span class="hljs-keyword">operator</span>&lt;=(y)          <span class="hljs-comment">// calling member operator&lt;= for x</span>
<span class="hljs-keyword">operator</span>&lt;=(x, y)         <span class="hljs-comment">// calling a free-standing operator&lt;= for x and y</span>

x.<span class="hljs-keyword">operator</span>&lt;=&gt;(y) &lt;= <span class="hljs-number">0</span>    <span class="hljs-comment">// calling member operator&lt;=&gt; for x</span>
<span class="hljs-keyword">operator</span>&lt;=&gt;(x, y) &lt;= <span class="hljs-number">0</span>   <span class="hljs-comment">// calling a free-standing operator&lt;=&gt; for x and y</span>

<span class="hljs-number">0</span> &lt;= y.<span class="hljs-keyword">operator</span>&lt;=&gt;(x)    <span class="hljs-comment">// calling member operator&lt;=&gt; for y, this form is to support an implicit type conversion for the first operand, for which it has to become a parameter.</span>
</div></code></pre>
<p><strong>Guideline</strong>: In C++20, make comparsion operator overloads member functions:</p>
<ul>
<li>it just works now</li>
<li>no <code>friend</code> needed</li>
<li>fewer overload resolution candidates</li>
</ul>
<br>
<br>
<h1 id="auto-for-function-parameters"><code>auto</code> for function parameters</h1>
<p><a href="http://wg21.link/p1141r2">http://wg21.link/p1141r2</a>.</p>
<p>Since C++20, you can use placeholders such as auto for all functions (including member functions and operators)</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printColl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; coll)</span>  <span class="hljs-comment">// generic function</span>
</span>{
    ...
}

<span class="hljs-comment">// above is a shortcut to declare/define a template such as the following:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">printColl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; coll)</span>     <span class="hljs-comment">// equivalent generic function</span>
</span>{
    ...
}

<span class="hljs-comment">// member function with auto parameter</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyType</span> {</span>
  ...
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; newVal)</span></span>;
};

<span class="hljs-comment">// is equivalent to:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyType</span> {</span>
  ...
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; newVal)</span></span>;
};
</div></code></pre>
<p><strong><code>auto</code> function vs lambda</strong></p>
<p>auto function is really just function template.</p>
<br>
<br>
<h1 id="concepts">Concepts</h1>
<p><a href="http://wg21.link/p0734r0">http://wg21.link/p0734r0</a></p>
<p><em>concepts</em> are a milestone for C++, because concepts provide a language feature for something we need a lot when writing generic code: specifying <em>requirements</em>.</p>
<h2 id="constraints">Constraints</h2>
<p>To specify requirements for template parameters you need <em>constraints</em>. It is a Boolean expression that
evaluates to true or false at compiler time. It can be</p>
<ul>
<li>an ad-hoc Boolean compile-time expression (it might need parentheses around to avoid ambiguities)</li>
<li>a <code>requires</code> expressions specifying required operations and types</li>
<li>a concept (by using the keyword <code>concept</code>)</li>
</ul>
<p>The basic application of a constraint is a <span style="color:red"><em>requires clause</em></span></p>
<pre><code class="language-C++"><div><span class="hljs-comment">// use &amp;&amp; to combine multiple constraints</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(T) &gt; <span class="hljs-number">4</span>)</span>                         <span class="hljs-comment">// ad-hoc Boolean expression</span>
         &amp;&amp; <span class="hljs-keyword">requires</span> </span>{ <span class="hljs-keyword">typename</span> T::value_type; } <span class="hljs-comment">// requires expression</span>
         &amp;&amp; std::input_iterator&lt;T&gt;               <span class="hljs-comment">// concept</span>

<span class="hljs-comment">// use || to express &quot;alternative&quot; constraints (alternative constraints is rarely needed and should not be done too casually because it may slow down compilation noticeably)</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">requires</span> std::integral&lt;T&gt; || <span class="hljs-function">std::floating_point&lt;T&gt;
T <span class="hljs-title">power</span><span class="hljs-params">(T b, T p)</span></span>;
</div></code></pre>
<p><strong>Boolean Expressions</strong></p>
<p>The first way to formulate constraints for templates is to use compile-time expressions that convert to true
or false. Typically, they are:</p>
<ul>
<li>Type predicates, such as type traits</li>
<li>Compile-time variables (defined with <code>constexpr</code> or <code>constinit const</code>)</li>
<li>Compile-time functions (defined with <code>constexpr</code> or <code>consteval</code>)</li>
</ul>
<p>Some examples:</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(T) &lt;= <span class="hljs-number">64</span>)</span> <span class="hljs-comment">//</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">requires</span> <span class="hljs-params">(std::is_pointer_v&lt;T&gt; || std::same_as&lt;T, std::<span class="hljs-keyword">nullptr_t</span>&gt;)</span> <span class="hljs-comment">// raw pointers or nullptr</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">requires</span> <span class="hljs-params">(std::is_pointer_v&lt;T&gt; || std::is_same_v&lt;T, std::<span class="hljs-keyword">nullptr_t</span>&gt;)</span> <span class="hljs-comment">// same as above</span>

<span class="hljs-comment">// if the argument cannot be used as a string</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">requires</span> <span class="hljs-params">(!std::convertible_to&lt;T, std::string&gt;)</span>   <span class="hljs-comment">// std::convertible_to is a concept introduced in C++20</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">requires</span> <span class="hljs-params">(!std::is_convertible_v&lt;T, std::string&gt;)</span> <span class="hljs-comment">// std::is_convertible is type_trait since C++17, &quot;_v&quot; is introduced in C++17</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">requires</span> std::integral&lt;std::<span class="hljs-keyword">remove_reference_t</span>&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(*std::declval&lt;T&gt;())</span>&gt;&gt; <span class="hljs-comment">// if the argument is a pointer-like object to an integral value</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">gcd</span><span class="hljs-params">(T a, T b)</span></span>; <span class="hljs-comment">// greatest common divisor (forward declaration)</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">int</span> Min, <span class="hljs-keyword">int</span> Max&gt;
<span class="hljs-title">requires</span> <span class="hljs-params">(gcd(Min, Max) &gt; <span class="hljs-number">1</span>)</span> <span class="hljs-comment">// available if there is a GCD greater than 1</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">requires</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// disable the template</span>
</span></div></code></pre>
<p><strong><code>requires</code> Expressions</strong></p>
<p><em>Requires expressions</em> (which are distinct from <em>requires clauses</em>) provide a simple but flexible syntax to
specify multiple requirements on one or multiple template parameters.</p>
<p>A <em>requires expression</em> starts with <code>requires</code> followed by an optional parameter list and then a block of
requirements (all ending with semicolons).</p>
<p>The optional parameter list allows you to introduce a set of “dummy variables” usable to express requirements in the body of the requires expression. These parameters are never replaced by arguments. Therefore, it usually does not matter whether you declare them by value or by reference.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
... <span class="hljs-built_in"><span class="hljs-keyword">requires</span></span> (T x, T y) {
     x + y;   <span class="hljs-comment">// supports +</span>
     x - y;   <span class="hljs-comment">// supports -</span>
   }
</div></code></pre>
<p><strong>Simple requirements</strong> are just expressions that have to be well-formed. That means the calls have to compile.</p>
<p>The calls are not performed, so it does not matter whether the operations have defined behavior or yield
true.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
... <span class="hljs-built_in"><span class="hljs-keyword">requires</span></span>(T1 val, T2 p) {
    *p;         <span class="hljs-comment">// operator* has to be supported for T2</span>
    p[<span class="hljs-number">0</span>];       <span class="hljs-comment">// operator[] has to be supported for int as index</span>
    p-&gt;<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// calling a member function value() without arguments has to be possible</span>
    *p &gt; val;   <span class="hljs-comment">// support that we can compare the result of operator* with T1</span>
    
    <span class="hljs-comment">// This does not require that p is the nullptr (to require that, you have to check whether T2 is type</span>
std::<span class="hljs-keyword">nullptr_t</span>). 
    <span class="hljs-comment">// Instead, we require that we can compare an object of type T2 with an object of type std::nullptr_t.</span>
    p == <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// support that we can compare a T2 with a nullptr</span>
}
</div></code></pre>
<p>Another Example:</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// OOPS: does not require T to be integral. </span>
<span class="hljs-comment">// It only requires that the expression std::integral&lt;T&gt; is valid, which is the case for all types.</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
... <span class="hljs-keyword">requires</span> {
    std::integral&lt;T&gt;; <span class="hljs-comment">// OOPS</span>
};

<span class="hljs-comment">// Instead, you should do below</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
... std::integral&lt;T&gt; &amp;&amp; <span class="hljs-comment">// OK, does require T to be integral</span>
    <span class="hljs-keyword">requires</span> {
        ...
    };
<span class="hljs-comment">// OR</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
... <span class="hljs-keyword">requires</span> {
    <span class="hljs-keyword">requires</span> std::integral&lt;T&gt;; <span class="hljs-comment">// OK, does require T to be integral</span>
    ...
};
</div></code></pre>
<p><strong>Type requirements</strong> are expressions that have to be well-formed when using a name of a type. That means
the specified name has to be defined as a valid type.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
... <span class="hljs-keyword">requires</span> {
    <span class="hljs-keyword">typename</span> T1::value_type;                <span class="hljs-comment">// type member value_type required for T1</span>
    <span class="hljs-keyword">typename</span> std::ranges::<span class="hljs-keyword">iterator_t</span>&lt;T1&gt;;   <span class="hljs-comment">// iterator type required for T1</span>
    <span class="hljs-keyword">typename</span> std::ranges::<span class="hljs-keyword">iterator_t</span>&lt;std::vector&lt;T1&gt;&gt;;
    <span class="hljs-keyword">typename</span> std::<span class="hljs-keyword">common_type_t</span>&lt;T1, T2&gt;;    <span class="hljs-comment">// T1 and T2 have to have a common type</span>
}
</div></code></pre>
<p>Note it <em>doesn't</em> make sense (useful) to check for other type declarations using the type.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> StdHash = <span class="hljs-keyword">requires</span> {
    <span class="hljs-keyword">typename</span> std::hash&lt;T&gt;; <span class="hljs-comment">// does not check whether std::hash&lt;&gt; is defined for T</span>
};
<span class="hljs-comment">// The way to do that is to try to create or use it:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> StdHash = <span class="hljs-keyword">requires</span> {
    std::hash&lt;T&gt;{}; <span class="hljs-comment">// OK, checks whether we can create a standard hasher for T</span>
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
... <span class="hljs-keyword">requires</span> {
    <span class="hljs-keyword">typename</span> std::<span class="hljs-keyword">remove_const_t</span>&lt;T&gt;; <span class="hljs-comment">// not useful: always valid (yields a type)</span>
}
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
... <span class="hljs-keyword">requires</span> {
    std::is_const_v&lt;T&gt;; <span class="hljs-comment">// not useful: always valid (doesn’t matter what it yields)</span>
}
</div></code></pre>
<p><strong>Compound requirements</strong> allow us to combine the abilities of <em>simple</em> and <em>type</em> requirements. In this case you can specify an expression (inside a block of braces) and then add one or both of the following:</p>
<ul>
<li><code>noexcept</code> to require that the expression guarantees not to throw</li>
<li><code>-&gt; type-constraint</code> to apply a concept on what the expression evaluates to</li>
</ul>
<p>Some examples:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
... <span class="hljs-built_in"><span class="hljs-keyword">requires</span></span>(T x) {
    <span class="hljs-comment">// require that the concept std::input_or_output_iterator is satisfied when using operator&amp; for an object of type T</span>
    { &amp;x } -&gt; std::input_or_output_iterator;
    { x == x }
    <span class="hljs-comment">// require that we can use the result of operator== for two objects of type T as bool</span>
    { x == x } -&gt; std::convertible_to&lt;<span class="hljs-keyword">bool</span>&gt;;
    { x == x }<span class="hljs-keyword">noexcept</span>
    { x == x }<span class="hljs-keyword">noexcept</span> -&gt; std::convertible_to&lt;<span class="hljs-keyword">bool</span>&gt;;
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
... <span class="hljs-built_in"><span class="hljs-keyword">requires</span></span>(T coll) {
    { *coll.<span class="hljs-built_in">begin</span>() } -&gt; std::convertible_to&lt;T::value_type&gt;;
}
</div></code></pre>
<br>
<h2 id="concepts-1">Concepts</h2>
<p>By defining a concept you can introduce a name for one or more <span style="color:red"><em>constraints</em></span>.</p>
<p>Templates (function, class, and variable templates) can use concepts to constrain their ability (via a <span style="color:red">requires clause</span> or as a direct <span style="color:red">type constraint</span> for a template parameter).</p>
<p><strong>boolean variable template vs. concept</strong></p>
<p>Concepts are much like <code>constexpr</code> variable templates of type bool, at compile-time or runtime you can always use a concept where the value of a Boolean expression
is needed.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> IsOrHasThisOrThat = ... ;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> IsOrHasThisOrThat = ... ;
</div></code></pre>
<ul>
<li>Concepts do not represent code. They have no type, storage, lifetime. By instantiating them at compile time for specific template parameters, their instantiation just becomes literal true or false.</li>
<li>Concepts do not have to be declared as inline, they implicitly are.</li>
<li>Concepts can be used as type constraints: <code>template&lt;IsOrHasThisOrThat T&gt;</code>, while variable templates cannot be used that way.</li>
<li>Concepts are the only way to give constraints a name, which means that you need them to decide whether
a constraint is a special case of another constraint. To decide whether a constraint <span style="color:red">subsumes</span> you need concepts to compare the constraint with.</li>
</ul>
<p><strong>Where can concepts be used</strong></p>
<p>concepts can be used as type constraints. There are different places where type constraints can be used:</p>
<ul>
<li>In the declaration of a template type parameter</li>
<li>In the declaration of a call parameter declared with auto</li>
<li>As requirement in a compound requirements</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;std::integral T&gt;                      <span class="hljs-comment">// type constraint for a template parameter</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> {</span>
  ...
};

<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::integral <span class="hljs-keyword">auto</span>&amp; val)</span> </span>{   <span class="hljs-comment">// type constraint for an auto parameter</span>
  ...
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> MyConcept = <span class="hljs-built_in"><span class="hljs-keyword">requires</span></span>(T x) {
    { x + x } -&gt; std::integral;                <span class="hljs-comment">// type constraint for return type</span>
  };
</div></code></pre>
<p>Type constraints can be used in all places where auto can be used:</p>
<pre><code class="language-C++"><div>std::integral <span class="hljs-keyword">auto</span> val1 = <span class="hljs-number">42</span>; <span class="hljs-comment">// OK</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> std::integral <span class="hljs-keyword">auto</span>&amp; elem : coll) { ... }

<span class="hljs-comment">// To constrain return types</span>
<span class="hljs-function">std::integral <span class="hljs-keyword">auto</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{ ... }

<span class="hljs-comment">// to constrain non-type template parameters:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::integral <span class="hljs-keyword">auto</span> max&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizedColl</span> {</span> ... };

<span class="hljs-comment">// another example</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::convertible_to&lt;T&gt; <span class="hljs-keyword">auto</span> <span class="hljs-keyword">default</span>&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyType</span> {</span> ... };
</div></code></pre>
<p><strong>Constraints and Concepts Subsume</strong></p>
<p>Two concepts can have a subsuming relation. That is, one concept can be specified that it restricts one or
more other concepts. The benefit is that overload resolution then prefers the more constrained generic code</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> GeoObject = <span class="hljs-built_in"><span class="hljs-keyword">requires</span></span>(T obj) {
    { obj.<span class="hljs-built_in">width</span>() } -&gt; std::integral;
    { obj.<span class="hljs-built_in">height</span>() } -&gt; std::integral;
    obj.<span class="hljs-built_in">draw</span>();
  };

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> ColoredGeoObject =
  GeoObject&lt;T&gt; &amp;&amp;             <span class="hljs-comment">// subsumes concept GeoObject</span>
  <span class="hljs-built_in"><span class="hljs-keyword">requires</span></span>(T obj) {           <span class="hljs-comment">// additional constraints</span>
    obj.<span class="hljs-built_in">setColor</span>(Color{});
    { obj.<span class="hljs-built_in">getColor</span>() } -&gt; std::convertible_to&lt;Color&gt;;
  };

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;GeoObject T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T)</span> </span>{ ... }       <span class="hljs-comment">// called for objects not providing setColor() and getColor()</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;ColoredGeoObject T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T)</span> </span>{ ... }       <span class="hljs-comment">// called for objects providing setColor() and getColor()</span>
</div></code></pre>
<p>subsumptions is only evaluated among concepts, overloading with different constraints is ambiguous if no concepts are used.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// When using constraints (with boolean expression)</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">requires</span> std::is_convertible_v&lt;T, <span class="hljs-keyword">int</span>&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T)</span> </span>{ ... }

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">requires</span> <span class="hljs-params">(std::is_convertible_v&lt;T, <span class="hljs-keyword">int</span>&gt; &amp;&amp; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) &gt;= <span class="hljs-number">4</span>)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T)</span> </span>{ ... }

<span class="hljs-built_in">print</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// ERROR: ambiguous (if both constraints are true)</span>

<span class="hljs-comment">// When using concepts instead, this code works:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">requires</span> std::convertible_to&lt;T, <span class="hljs-keyword">int</span>&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T)</span> </span>{ ... }

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">requires</span> <span class="hljs-params">(std::convertible_to&lt;T, <span class="hljs-keyword">int</span>&gt; &amp;&amp; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) &gt;= <span class="hljs-number">4</span>)</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T)</span> </span>{ ... }

<span class="hljs-built_in">print</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// OK</span>
</div></code></pre>
<br>
<br>
<h1 id="std-concepts">std concepts</h1>
<p>C++20 standard library provides a bunch of pre-defined <code>concepts</code>.</p>
<p>Almost all concepts are defined in header <code>&lt;concepts&gt;</code>, which is included by <code>&lt;ranges&gt;</code> and <code>&lt;iterator&gt;</code>.
The only exceptions are:</p>
<ul>
<li><code>std::three_way_comparable</code> concepts, which are defined in <code>&lt;compare&gt;</code> (which is included by almost every
other header file)</li>
<li><code>std::uniform_random_bit_generator</code>, which is defined in <code>&lt;random&gt;</code></li>
</ul>
<p>Almost all concepts are defined in namespace <code>std</code>. The only exception are the ranges concepts, which are
defined in namespace <code>std::ranges</code>.</p>
<br>
<br>
<h1 id="ranges-and-views">Ranges and Views</h1>
<p>C++20 introduces the concept of a range, which is a <strong>single object</strong> representing a sequence of values, and you can pass the range as a whole as a single parameter.</p>
<p>C++20 provides several new features to deal with ranges:</p>
<ul>
<li>New overloads or variations of standard algorithms take ranges as single arguments.</li>
<li>Helper functions to create range objects</li>
<li>Helper functions to deal with range objects</li>
<li><em>Concepts</em> for ranges</li>
</ul>
<p>To use ranges,</p>
<ul>
<li>you need the header file <ranges></li>
<li>Almost all features of the ranges library are defined in the namespace <code>std::ranges</code>. This is necessary to avoid ambiguities and conflicts with existing APIs.</li>
<li>It is pretty common to introduce a shortcut for the namespace <code>std::ranges</code></li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ranges&gt;</span></span>
<span class="hljs-keyword">namespace</span> rng = std::ranges;
std::vector&lt;<span class="hljs-keyword">int</span>&gt; coll;
rng::<span class="hljs-built_in">sort</span>(coll);
</div></code></pre>
<p><strong>views</strong></p>
<p>To deal with ranges, C++20 also introduces views. Views are lightweight ranges that</p>
<ul>
<li>can refer to ranges and subranges</li>
<li>can iterate over the elements of range by filtering out some elements or performing some transformations
of their values</li>
<li>can represent a sequence of values themselves</li>
</ul>
<p>The view provides the usual API of range so that <code>begin()</code>, <code>end()</code>, and <code>operator++</code> can be used to iterate over the elements and <code>operators *</code> and <code>-&gt;</code> can be used.</p>
<p>Views have their own namespace, <code>std::ranges::views</code>, for which the namespace alias <code>std::views</code> is defined:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">namespace</span> views = ranges::views;
}
</div></code></pre>
<p>Below examples use the <em>range adaptor</em> <code>std::views::take()</code> to create a view. Range adaptors are helper functions defined in namespace std::views that creates views.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// use a view to iterate only over the first 5 elements of a range:</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; elem : std::views::<span class="hljs-built_in">take</span>(coll, <span class="hljs-number">5</span>)) { ... }

<span class="hljs-comment">// a view can also be used to sort only the first 5 elements:</span>
std::ranges::<span class="hljs-built_in">sort</span>(std::views::<span class="hljs-built_in">take</span>(coll, <span class="hljs-number">5</span>)); <span class="hljs-comment">// sort the first 5 elements of coll</span>

<span class="hljs-comment">// a view can also generate a sequence of values themselves. </span>
<span class="hljs-comment">// For example, with the iota view, we can iterator over all values from 1 to 10 as follows:</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : std::views::<span class="hljs-built_in">iota</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)) {...}
</div></code></pre>
<p>views enable using <code>operator |</code> to pipe in the underlying range that should be processed</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// view with elements of coll that are multiples of 3:</span>
std::views::<span class="hljs-built_in">filter</span>(coll, [] (<span class="hljs-keyword">auto</span> elem) {
                           <span class="hljs-keyword">return</span> elem % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>;
                         })

<span class="hljs-comment">// view with squared elements of coll:</span>
std::views::<span class="hljs-built_in">transform</span>(coll, [] (<span class="hljs-keyword">auto</span> elem) {
                              <span class="hljs-keyword">return</span> elem * elem;
                            })

<span class="hljs-comment">// view with first 3 elements of coll:</span>
std::views::<span class="hljs-built_in">take</span>(coll, <span class="hljs-number">3</span>)

<span class="hljs-comment">// view with first 3 squared values of of the elements in coll that are multiples of 3:</span>
<span class="hljs-keyword">auto</span> v = coll
          | std::views::<span class="hljs-built_in">filter</span>([] (<span class="hljs-keyword">auto</span> elem) { <span class="hljs-keyword">return</span> elem % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>; })
          | std::views::<span class="hljs-built_in">transform</span>([] (<span class="hljs-keyword">auto</span> elem) { <span class="hljs-keyword">return</span> elem * elem; })
          | std::views::<span class="hljs-built_in">take</span>(<span class="hljs-number">3</span>);


<span class="hljs-comment">// Another example:</span>
<span class="hljs-comment">// iterate over the names of the first 3 composers born since 1700:</span>
std::map&lt;std::string, <span class="hljs-keyword">int</span>&gt; composers;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; elem : composers
                        | vws::<span class="hljs-built_in">filter</span>([](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; y) {   <span class="hljs-comment">// since 1700</span>
                                        <span class="hljs-keyword">return</span> y.second &gt;= <span class="hljs-number">1700</span>;
                                        })
                        | vws::<span class="hljs-built_in">take</span>(<span class="hljs-number">3</span>)                      <span class="hljs-comment">// first 3</span>
                        | vws::keys                         <span class="hljs-comment">// keys/names only</span>
                        ) 
</div></code></pre>
<p><strong>views and const</strong></p>
<p>When using views (and the ranges library in general), there are a few thing that are surprising or even broken regarding constness:</p>
<ul>
<li>Views remove the propagation of constness to elements.</li>
<li>Functions like <code>cbegin()</code> and <code>cend()</code>, which have the goal to ensure that elements are const while iterating over them, are either not provided or even broken.
<ul>
<li><a href="http://wg21.link/p2278">http://wg21.link/p2278</a> provides an approach to fix this broken constness for C++23</li>
</ul>
</li>
<li>It might not be possible to iterate over a view when it is const.</li>
</ul>
<p>Containers have <span style="color:red"><em>deep constness</em></span>. Because they have <em>value semantics</em> and own their elements, they propagate any constness to their elements. When a containers is const, its elements are const.</p>
<p>Views have <span style="color:red"><em>shallow constness</em></span>. Because they have <em>reference semantics</em> as they only refer to elements stored somewhere else and usually do not own any elements or values. As a consequence, views do not propagate constness to their elements.</p>
<p>Example:</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">constfunc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; range)</span> </span>{
    range.<span class="hljs-built_in">front</span>() += <span class="hljs-number">1</span>; <span class="hljs-comment">// modify an element of a const range</span>
}

std::array&lt;<span class="hljs-keyword">int</span>, 10&gt; coll{};         <span class="hljs-comment">// array of 10 ints with value 0</span>
<span class="hljs-built_in">constfunc</span>(coll);                    <span class="hljs-comment">// compile-time ERROR</span>
std::ranges::take_view tv{coll, <span class="hljs-number">5</span>}; <span class="hljs-comment">// view to first 5 elements of coll</span>
<span class="hljs-built_in">constfunc</span>(tv);                      <span class="hljs-comment">// OK, modifies the first element of coll</span>
</div></code></pre>
<pre><code class="language-C++"><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">cbegin</span>(range); pos != std::<span class="hljs-built_in">cend</span>(range); ++pos) {
    <span class="hljs-built_in">elemfunc</span>(*pos); <span class="hljs-comment">// !!! does not provide constness for the values</span>
}   
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = std::ranges::<span class="hljs-built_in">cbegin</span>(range); pos != std::ranges::<span class="hljs-built_in">cend</span>(range); ++pos) {
    <span class="hljs-built_in">elemfunc</span>(*pos); <span class="hljs-comment">// !!! does not provide constness for the values</span>
}

<span class="hljs-comment">// Instead, we should do </span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; elem : range) {  <span class="hljs-comment">// using const in the range-based for loop:</span>
    ...
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = range.<span class="hljs-built_in">begin</span>(); pos != range.<span class="hljs-built_in">end</span>(); ++pos) {
    <span class="hljs-built_in">elemfunc</span>(std::<span class="hljs-built_in">as_const</span>(*pos)); <span class="hljs-comment">// passing elements converted to const</span>
}
</div></code></pre>
<p><strong>sentinels</strong></p>
<p>C++20 introduces a new term, <em>sentinels</em>, which represent the end of a range.</p>
<p>Unlike STL end iterator, range sentinels doesn't have to be the same type as iterators iterating over the collection. They can signal “until '\0'”, “until EOF”, or until any other value.</p>
<p><strong>subrange</strong></p>
<p>The subrange class template combines together an iterator and a sentinel into a single view. A subrange can be defined with:</p>
<ul>
<li>A begin iterator and an end iterator of the same type</li>
<li>A begin iterator and a sentinel (an end marker of a maybe different type)</li>
<li>A begin iterator and a count</li>
<li>Arrays</li>
</ul>
<p>A subrange is <em>the</em> generic type that can be used to convert an iterator and a sentinel into a single object
representing it as a view. That means subranges have reference semantics and are cheap to copy them around.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// define an end iterator sentinel</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NullTerm</span> {</span>
  <span class="hljs-comment">// Note this is C++20 auto template function </span>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-keyword">auto</span> pos) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> *pos == <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// end is where iterator points to \verb+&#x27;\0&#x27;+</span>
  }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* rawString = <span class="hljs-string">&quot;hello world&quot;</span>;

  <span class="hljs-comment">// Using Sentinels Directly </span>
  <span class="hljs-comment">// iterate over the range of the begin of rawString and its end:</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = rawString; pos != NullTerm{}; ++pos) {
    std::cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; *pos;
  }

  <span class="hljs-comment">// call range algorithm with iterator and sentinel:</span>
  std::ranges::for_each(rawString, <span class="hljs-comment">// begin of range</span>
                        NullTerm{}, <span class="hljs-comment">// end is null terminator</span>
                        [] (<span class="hljs-keyword">char</span> c) {
                            std::cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; c;
                        });

  <span class="hljs-comment">// define a sub-range of a raw string and a null terminator:</span>
  std::ranges::subrange rawStringRange{rawString, NullTerm{}};
  std::ranges::for_each(rawStringRange,
                        [] (<span class="hljs-keyword">char</span> c) {
                          std::cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; c;
                        });
  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;

  <span class="hljs-comment">// range-based for loop also supports iterator/sentinel:</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : rawStringRange) {
    std::cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; c;
  }
  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
}
</div></code></pre>
<p><strong>Projections</strong></p>
<p><code>sort()</code> and many other algorithms for ranges usually have an additional optional template parameter, a
<em>projection</em>: it allows you to specify a transformation (<em>projection</em>) for each element
before the algorithm processes it further.</p>
<p>The default projection is <code>std::identity()</code>, which yields a passed argument as is (it is defined as a
function object in <code>&lt;functional&gt;</code>).</p>
<pre><code class="language-C++"><div>std::ranges::<span class="hljs-built_in">sort</span>(coll,
                  std::ranges::less{},   <span class="hljs-comment">// still compare with &lt;</span>
                  [] (<span class="hljs-keyword">auto</span> val) {        <span class="hljs-comment">// projection: use the absolute value</span>
                    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(val);
                  });
<span class="hljs-comment">//This might be more readable or easier to program than:</span>
std::ranges::<span class="hljs-built_in">sort</span>(coll,
                  [] (<span class="hljs-keyword">auto</span> val1, <span class="hljs-keyword">auto</span> val2) {
                    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(val1) &lt; std::<span class="hljs-built_in">abs</span>(val2);
                  });
</div></code></pre>
<p><strong>Range Adaptors</strong></p>
<p>C++ provides several range adaptors to easily create views with the best performance.</p>
<p>some major range adaptors:</p>
<ul>
<li><code>std::views::all()</code>, which is the primary adaptor to yield a view for a passed range</li>
<li><code>std::views::counted()</code>, is the primary adaptor to convert a begin and a count into a view</li>
<li><code>std::views::common()</code>, which yields a view with harmonized types for the begin iterator and the
sentinel (end iterator) to be able to pass the range/view to traditional range parameters</li>
</ul>
<p>All these major adaptors always yield a <em>borrowed range</em>. That is, the lifetime of iterators from these
adaptors only depends on the lifetime of the argument passed to them. In other words: Using these adaptors
does not introduce additional lifetime issues.</p>
<br>
<br>
<h1 id="spans">Spans</h1>
<p>Objects of type <code>std::span&lt;&gt;</code> refer to external sequences of elements. All elements have to be stored one
after another in contiguous memory.</p>
<p>A <code>span</code> object is in fact just as raw pointer to a sequence of elements combined with a size for the number
of elements. Using a <code>span</code> is cheap and fast (you should always pass it by value). However, it is also potentially dangerous because it is up to the programmer to ensure that the referred element sequence is still valid when using a <code>span</code>.</p>
<p>A span where the number of elements might change is called a span with <em>dynamic extent</em>.</p>
<br>
<br>
<h1 id="module">Module</h1>
<p>Modules provide a way to combine code from multiple files into one logical entity (module, component). As a side effect, it is possible to ensure that module code does not have to be compiled multiple times.</p>
<p>Modules allow programs to define an API that might consist of multiple classes, multiple files, several functions, and various auxiliary utilities including templates.</p>
<p>Each module must have exactly one primary module interface unit file with its specified name.</p>
<ul>
<li>The public API of a module is defined by everything that is explicitly exported using the keyword <code>export</code>.</li>
<li>Everything else is <em>not</em> exported and cannot be used directly by code importing the module. They are not <em>visible</em>.</li>
</ul>
<p>C++ modules do <em>not</em> automatically introduce a namespace for a module. You can add namespace in the module file, the namepsace symbol will be exported even not marked with <code>export</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// file: mod0.cppm // note, there is no require of module file naming and extension. </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> Square;  <span class="hljs-comment">// declare module Square. This is the key entry for the primary module interface.</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> {</span>
 <span class="hljs-keyword">private</span>:
   <span class="hljs-keyword">int</span> value;
 <span class="hljs-keyword">public</span>:
   <span class="hljs-built_in">Square</span>(<span class="hljs-keyword">int</span> i) 
    : value{<span class="hljs-built_in">square</span>(i)} {
   }
   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
     <span class="hljs-keyword">return</span> value;
   }
};

<span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
Square <span class="hljs-title">toSquare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; x)</span> </span>{
  <span class="hljs-keyword">return</span> Square{x};
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
  <span class="hljs-keyword">return</span> i * i;
}
</div></code></pre>
<pre><code class="language-C++"><div><span class="hljs-comment">// file: main.cpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">import</span> Square; <span class="hljs-comment">// import module “Square”</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Square x = <span class="hljs-built_in">toSquare</span>(<span class="hljs-number">42</span>);
    std::cout &lt;&lt; v.<span class="hljs-built_in">getValue</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
}
</div></code></pre>
<p><strong>Not visible but reachable</strong></p>
<p>Symbols that are reachable but not visible can occur, when an exported API provides access to a type that
is not exported.</p>
<p>Exampe:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> ModReach;   <span class="hljs-comment">// declare module ModReach</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> {</span>             <span class="hljs-comment">// declare a type not exported</span>
  <span class="hljs-keyword">int</span> value;
};

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Customer</span> {</span>  <span class="hljs-comment">// declare an exported type</span>
 <span class="hljs-keyword">private</span>:
  Data data;
 <span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">Customer</span>(<span class="hljs-keyword">int</span> i)
   : data{i} {
  }
  <span class="hljs-function">Data <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{  <span class="hljs-comment">// yield not exported  type</span>
    <span class="hljs-keyword">return</span> data;
  }
};
</div></code></pre>
<pre><code class="language-C++"><div><span class="hljs-keyword">import</span> ModReach;

Data d{<span class="hljs-number">11</span>};                    <span class="hljs-comment">// ERROR: type Data not exported</span>
Customer c{<span class="hljs-number">42</span>};
<span class="hljs-keyword">const</span> Data&amp; dr = c.<span class="hljs-built_in">getData</span>();  <span class="hljs-comment">// ERROR: type Data not exported</span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; dr = c.<span class="hljs-built_in">getData</span>();  <span class="hljs-comment">// OK: type Data is used</span>
<span class="hljs-keyword">auto</span> d = c.<span class="hljs-built_in">getData</span>();          <span class="hljs-comment">// OK: d has type Data</span>
std::cout &lt;&lt; d.value &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  <span class="hljs-comment">// OK: type Data is used</span>
<span class="hljs-comment">//You can even declare an object of type Data as follows:</span>
<span class="hljs-keyword">decltype</span>(std::declval&lt;Customer&gt;().<span class="hljs-built_in">getData</span>()) d;  <span class="hljs-comment">// d has non-exported type Data</span>
</div></code></pre>
<h2 id="modules-with-multiple-files">Modules with Multiple Files</h2>
<p>The purpose of modules is to deal with code of significant size distributed over multiple files.</p>
<p>In general modules consist out of multiple <em>module units</em>. Module units are translation units that belong to a module. we have different ways to split a module into multiple files:</p>
<ul>
<li><span style="color:red"><em>Module implementation units</em></span> allow programmers to provide code (such as implementation of a class) that is compiled in the traditional way into object files.</li>
<li><span style="color:red"><em>Internal partitions</em></span> allow programmers to provide declarations and definitions that are only visible inside a module. However, even when only declared, they are pre-compiled to avoid multiple compilations.</li>
<li><span style="color:red"><em>Interface partitions</em></span> allow programmers to split the exported module API even in multiple files.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-comment">// file: mod1.cppm</span>
<span class="hljs-keyword">module</span>; <span class="hljs-comment">// start module unit with global module fragment</span>
<span class="hljs-comment">// a global module fragment where we can place preprocessor commands like #define and #include. Everything from this area is not exported</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> Mod1; <span class="hljs-comment">// The main module declaration.</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Order</span> {</span>
    ...
};

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> {</span>
    ...
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sumPrice</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
};
</div></code></pre>
<p>Example of a <strong>module implementation unit</strong>. You can have multiple separate cpp files to define some other implementation as well.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// file: mod1price.cpp</span>
<span class="hljs-keyword">module</span> Mod1; <span class="hljs-comment">// implementation unit of module Mod1, this indicates it is a module unit.</span>
<span class="hljs-comment">// This declaration implicitly imports the primary module interface (but nothing else).</span>

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Customer::sumPrice</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{
    ... <span class="hljs-comment">// implementation</span>
}
</div></code></pre>
<p>With <strong>internal partitions</strong> (sometimes called <em>partition implementation units</em>), you can define internal stuff of a module (such as Order class in above example) in separate files.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// file: mod2order.cppp // notice the extension</span>
<span class="hljs-keyword">module</span>; <span class="hljs-comment">// start module unit with global module fragment</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">module</span> Mod2:Order; <span class="hljs-comment">// internal partition declaration</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Order</span> {</span>
 ... <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">definition</span> 
};</span>
</div></code></pre>
<pre><code class="language-C++"><div><span class="hljs-comment">// file: mod2.cppm</span>
<span class="hljs-keyword">module</span>; <span class="hljs-comment">// start module unit with global module fragment</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> Mod2; <span class="hljs-comment">// main module declaration</span>

<span class="hljs-comment">// The primary module interface has to import the internal partition because it uses type Order in Customer class.</span>
<span class="hljs-comment">// If it doesn&#x27;t, all module units that need Orders would have to import the internal partition directly.</span>
<span class="hljs-keyword">import</span> :Order; <span class="hljs-comment">// import internal partition Order</span>

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> {</span>
    ... 
};
</div></code></pre>
<p>You can declare <strong>interface partitions</strong> to split the interface of a module in multiple files. Here we define the exported Customer interface in a separate module file.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// file: mod3customor.cppm</span>
<span class="hljs-keyword">module</span>; <span class="hljs-comment">// start module unit with global module fragment</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>

<span class="hljs-comment">// As a interface partition we declare its name after the module name and a colon: Mod3:Customer</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> Mod3:Customer; <span class="hljs-comment">// interface partition declaration</span>

<span class="hljs-keyword">import</span> :Order; <span class="hljs-comment">// import internal partition to use Order</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> {</span>
 ... <span class="hljs-comment">// class definition</span>
};
</div></code></pre>
<pre><code class="language-C++"><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> Mod3; <span class="hljs-comment">// main module declaration</span>

<span class="hljs-comment">// By importing the partition interface and exporting it at the same time (you have to write both keywords).// , the primary module exports the interface of the partition Customer as its own interface:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> :Customer; <span class="hljs-comment">// import and export interface partition Customer</span>

... <span class="hljs-comment">// import and export other interface partitions</span>
</div></code></pre>
<p><strong>File extension and Compilation</strong></p>
<p>We also have no standard extension for modules.</p>
<ul>
<li>For <strong>interface files</strong> (both primary module interfaces and interface partitions), you can use the file extension <code>.cppm</code>.
<ul>
<li>– Visual C++ requires special treatment so that you cannot use .cpp. (far better than .ixx recommended by Visual C++ here currently).</li>
<li>clang requires it currently.</li>
<li>For gcc it is possible to use.</li>
</ul>
</li>
<li>For <strong>internal partition files</strong> (partition implementation files) use the file extension <code>.cppp</code>. The reason is:
<ul>
<li>Visual C++ requires special treatment so that you cannot use .cpp.</li>
<li>For gcc it is possible to use.</li>
<li>clang does not support these files currently (September 2021), at all.</li>
</ul>
</li>
<li>For <strong>module implementation files</strong> (but not not partition implementation files) use the usual file extension,
which usually <code>.cpp</code>.</li>
</ul>
<p>gcc/g++:</p>
<p>GCC does not require any special file extension or command-line option at all. So, by using special
file extensions, we have to specify that the files contain C++ code using the command-line option <code>-xc++</code>:</p>
<pre><code class="language-bash"><div><span class="hljs-comment"># Compile an interface file file.cppm as follows:</span>
g++ -c -xc++ file.cppm
<span class="hljs-comment"># Compile an internal partition file file.cppp as follows:</span>
g++ -c -xc++ file.cppp
</div></code></pre>
<p>Clang:</p>
<p>Clang currently only supports interface files. As the proposed extension <strong>.cppm</strong> for them is required
anyway, using it should just work.</p>
<p>However, you cannot use internal partition files.</p>
<br>
<br>
<h1 id="lambda-extensions">Lambda Extensions</h1>
<p><strong>Template Lambda</strong></p>
<p><a href="http://wg21.link/p0428r2">http://wg21.link/p0428r2</a></p>
<p>C++20 introduces an extension to be able to use <strong>template parameters for generic lambdas</strong>.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> foo = []&lt;<span class="hljs-keyword">typename</span> T&gt;(<span class="hljs-keyword">const</span> T&amp; param) {  <span class="hljs-comment">// OK since C++20</span>
             T tmp{};  <span class="hljs-comment">// declare object with type of the template parameter</span>
             ...
           };

[]&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">int</span> N&gt;(<span class="hljs-built_in">T</span> (&amp;arr)[N]) { <span class="hljs-comment">// OK since C++20</span>
  ...   <span class="hljs-comment">// can use T as element type and N as size of the passed array</span>
};
</div></code></pre>
<p>Explicit template parameters also help to avoid the need of decltype. For example, for perfect forwarding a generic parameter pack in a lambda you can write:</p>
<pre><code class="language-C++"><div>[]&lt;<span class="hljs-keyword">typename</span>... Types&gt;(Types&amp;&amp;... args) {
  <span class="hljs-built_in">foo</span>(std::forward&lt;Types&gt;(args)...);
};
<span class="hljs-comment">// instead of:</span>
[] (<span class="hljs-keyword">auto</span>&amp;&amp;... args) {
  <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...);
};
</div></code></pre>
<p>You have to explicitly specify the template parameter if it can't be duduced. Example:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> primeNumbers = [] &lt;<span class="hljs-keyword">int</span> Num&gt; () {
                      std::array&lt;<span class="hljs-keyword">int</span>, Num&gt; primes{};
                      ...  <span class="hljs-comment">// compute and assign first Num prime numbers</span>
                      <span class="hljs-keyword">return</span> primes;
                   };
<span class="hljs-comment">// initialize array with the first 20 prime numbers:</span>
<span class="hljs-keyword">auto</span> primes20 = primeNumbers.<span class="hljs-built_in"><span class="hljs-keyword">operator</span></span>()&lt;<span class="hljs-number">20</span>&gt;();
</div></code></pre>
<p><strong>Default Constructor of Lambdas</strong></p>
<p><a href="http://wg21.link/p0624r2">http://wg21.link/p0624r2</a>.</p>
<p>Before C++20, lambda has no callable default constructor and assignment operator. Objects of the generated closure type could only be initially created by the compiler (copying is possible, though):</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> cmp1 = [] (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; x, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; y) { <span class="hljs-keyword">return</span> x &gt; y; }

<span class="hljs-keyword">auto</span> cmp2 = cmp1;    <span class="hljs-comment">// OK, copy constructor supported</span>
<span class="hljs-keyword">decltype</span>(cmp1) cmp3; <span class="hljs-comment">// ERROR until C++20: no default constructor provided</span>
cmp1 = cmp2;         <span class="hljs-comment">// ERROR until C++20: no assignment operator provided</span>

<span class="hljs-comment">// The implication is, eg, to use lambda as `std::set` comparator, you have to pass the compiler-created lambda object in `std::set` constructor.</span>
std::set&lt;Customer, <span class="hljs-keyword">decltype</span>(cmp1)&gt; coll1{cmp1};
</div></code></pre>
<p>Since C++20, lambdas with no captures have a default constructor and an assignment operator, For this reason, it is now enough to pass the type of the lambda for the ordering criterion (or hashing function)</p>
<pre><code class="language-C++"><div>std::set&lt;Customer, <span class="hljs-keyword">decltype</span>(cmp1)&gt; coll1; <span class="hljs-comment">// OK since C++20, note no constructor parameter is needed.</span>

<span class="hljs-comment">// you can also embeded the lambda inside the declaration of the containe (with decltype).</span>
std::set&lt;Customer,
        <span class="hljs-keyword">decltype</span>([] (<span class="hljs-keyword">const</span> Customer&amp; c1, <span class="hljs-keyword">const</span> Customer&amp; c2) {
                <span class="hljs-keyword">return</span> c1.getName() &lt; c2.getName();
            })&gt; coll3; <span class="hljs-comment">// OK since C++20</span>
</div></code></pre>
<p><strong><code>consteval</code> Lambdas</strong></p>
<p><a href="http://wg21.link/p1073r3">http://wg21.link/p1073r3</a></p>
<p>By using the new <span style="color:red"><a href="#consteval"><code>consteval</code> keyword</a></span> with lambdas, you can now require that lambdas become <em>immediate functions</em> so that “function calls” of them have to be evaluated at compile time.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> hashed = [] (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str) <span class="hljs-keyword">consteval</span> {
                ...
              };

<span class="hljs-keyword">auto</span> hashWine = <span class="hljs-built_in">hashed</span>(<span class="hljs-string">&quot;wine&quot;</span>);      <span class="hljs-comment">// hash() called at compile time</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cs = <span class="hljs-string">&quot;water&quot;</span>;
<span class="hljs-keyword">auto</span> hashWater = <span class="hljs-built_in">hashed</span>(cs);         <span class="hljs-comment">// OK, called at compiler time</span>

<span class="hljs-comment">// any call has to happen at compile-time with values known at compile-time. Passing a runtime value is an error:</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s = <span class="hljs-string">&quot;beer&quot;</span>;
<span class="hljs-keyword">auto</span> hashBeer = <span class="hljs-built_in">hashed</span>(s);           <span class="hljs-comment">// ERROR</span>
</div></code></pre>
<p><strong>Capturing Parameter Packs</strong></p>
<p><a href="http://wg21.link/p0780r2">http://wg21.link/p0780r2</a>, <a href="http://wg21.link/p2095r0">http://wg21.link/p2095r0</a>.</p>
<p>Before C++20, you could capture parameter packs as follow:</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Args... args)</span>
</span>{
   <span class="hljs-keyword">auto</span> l1 = [&amp;] {
               <span class="hljs-built_in">bar</span>(args...);  <span class="hljs-comment">// OK, capture by reference, you can&#x27;t return the lambda</span>
             };
   <span class="hljs-keyword">auto</span> l2 = [args...] {      <span class="hljs-comment">// or [=]</span>
               <span class="hljs-built_in">bar</span>(args...);  <span class="hljs-comment">// OK, it is capture by copy though</span>
             };
   ...
}
</div></code></pre>
<p>C++20 introduced  <em>init-captures</em> for parameter packs</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T arg)</span>
</span>{
   <span class="hljs-keyword">auto</span> l3 = [arg = std::<span class="hljs-built_in">move</span>(arg)] {  <span class="hljs-comment">// OK since C++14 for single argument</span>
               <span class="hljs-built_in">bar</span>(arg);      <span class="hljs-comment">// OK</span>
             };
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Args... args)</span>
</span>{
   <span class="hljs-keyword">auto</span> l4 = [...args = std::<span class="hljs-built_in">move</span>(args)] {  <span class="hljs-comment">// OK since C++20</span>
               <span class="hljs-built_in">bar</span>(args...);  
             };
   <span class="hljs-comment">// You can also init-capture parameter packs by reference.</span>
   <span class="hljs-keyword">auto</span> l5 = [&amp;...fooArgs = args] {         <span class="hljs-comment">// OK since C++20</span>
               <span class="hljs-built_in">bar</span>(fooArgs...);  
             };
}
</div></code></pre>
<br>
<br>
<h1 id="stdformat"><code>std::format</code></h1>
<p><a href="http://wg21.link/p0645r10">http://wg21.link/p0645r10</a>, performance improvement: <a href="http://wg21.link/p2216r3">http://wg21.link/p2216r3</a>.</p>
<p>C-style <code>printf()</code></p>
<ul>
<li>not type safe</li>
<li>not extensible, it supports only a fixed number of types</li>
</ul>
<p><code>iostream</code></p>
<ul>
<li>type safe</li>
<li>extensible by overloading <code>operator&lt;&lt;</code> for custom types</li>
<li>less readable, string and arguments interwinded</li>
<li>hard to localize/translate</li>
</ul>
<p><code>std::format</code></p>
<ul>
<li>type safe (unlike printf), it will throw <code>std::format_error</code></li>
<li>extensible for custom types</li>
<li>faster than <code>sprintf</code> family</li>
<li>much faster than <code>iostreams</code></li>
</ul>
<p>why is <code>std::format</code> so much faster</p>
<ul>
<li>uses <code>std::charconv</code> for floating point conversions.</li>
<li>much easier for the complier to inline (especially compared to iostreams)</li>
<li>No virtual calls (or indirect calls) required for the commonly formatted (built-in) types.</li>
<li>No interaction with locales unless specified (the <code>{:L}</code> specifier)</li>
<li>No interaction with <code>errno</code></li>
<li>much better support for indexing into the variadic parameters</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;format&gt;</span></span>

std:cout &lt;&lt; std::format(<span class="hljs-string">&quot;Read {} bytes from {}&quot;</span>, n, <span class="hljs-string">&quot;file.txt&quot;</span>);

<span class="hljs-comment">// positional placeholders</span>
std:cout &lt;&lt; std::format(<span class="hljs-string">&quot;Read {0} bytes from {1}&quot;</span>, n, <span class="hljs-string">&quot;file.txt&quot;</span>);

<span class="hljs-keyword">try</span> {
  std::cout &lt;&lt; std::format(<span class="hljs-string">&quot;{:.}&quot;</span>, <span class="hljs-number">5</span>);
}
<span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword">const</span> std::format_error&amp; exception) {
  std::cout &lt;&lt; exception.<span class="hljs-built_in">what</span>(); <span class="hljs-comment">// &quot;missing precision specifier&quot;</span>
}
</div></code></pre>
<p><code>std::format_to_n()</code> writes to a preallocated array of characters, with both the buffer and its size specified.</p>
<ul>
<li><code>std::format_to_n()</code> does not write a trailing null terminator.</li>
<li>return type <code>std::format_to_n_result</code> that has two members:
<ul>
<li><code>out</code> for the position of the first character not written</li>
<li><code>size</code> for the number of characters that would have been written without truncating them to the passed
size.</li>
</ul>
</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">64</span>];
<span class="hljs-keyword">auto</span> ret = std::format_to_n(buffer, std::<span class="hljs-built_in">size</span>(buffer)<span class="hljs-number">-1</span>, <span class="hljs-string">&quot;String{} has {} chars\n&quot;</span>, str, str.<span class="hljs-built_in">size</span>());
*(ret.out) = `\<span class="hljs-number">0</span>`;
</div></code></pre>
<p><code>std::format_to()</code> with an output stream buffer iterator, you can write directly to a stream:</p>
<ul>
<li>The helper function <code>std::back_inserter()</code> creates an object that calls push_back() for each character.</li>
<li><code>std::format_to()</code> has an optimization to write multiple characters for certain containers at once so that we still have good performance.</li>
</ul>
<pre><code class="language-C++"><div>std::format_to(std::ostreambuf_iterator&lt;<span class="hljs-keyword">char</span>&gt;{std::cout}, <span class="hljs-string">&quot;String &#x27;{}&#x27; has {} chars\n&quot;</span>, str, str.<span class="hljs-built_in">size</span>());

std::string s;
std::format_to(std::<span class="hljs-built_in">back_inserter</span>(s), <span class="hljs-string">&quot;String &#x27;{}&#x27; has {} chars\n&quot;</span>, str, str.<span class="hljs-built_in">size</span>());
</div></code></pre>
<p>To use format strings computed at runtime, use <code>std::vformat()</code> and <code>std::vformat_to()</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fmt1 = <span class="hljs-string">&quot;{:d}&quot;</span>; <span class="hljs-comment">// runtime format string</span>
std::format(fmt1, <span class="hljs-number">42</span>); <span class="hljs-comment">// compile-time ERROR</span>
std::<span class="hljs-built_in">vformat</span>(fmt1, std::<span class="hljs-built_in">make_format_args</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// OK, you have to convert all arguments with std::make_format_args()</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fmt2 = <span class="hljs-string">&quot;{:d}&quot;</span>; <span class="hljs-comment">// compile-time format string</span>
std::format(fmt2, <span class="hljs-number">42</span>); <span class="hljs-comment">// OK</span>
</div></code></pre>
<p><strong>Format Specifiers</strong></p>
<ul>
<li>placeholder can contain a format specifier</li>
<li>starts with colon: as in <code>{[index]:[format_specifier]}</code></li>
<li>format specifier: <code>[[fill]align][sign][#][0][width][.precision][type]</code>
<ul>
<li>width specifier:
<ul>
<li><code>[width]</code></li>
<li>dynamic width by another <code>{}</code>, or by positional index <code>{2}</code></li>
<li><code>[0]</code> specifier:
<ul>
<li>number values: zeros are inserted (at front, after sign and prefixes such as 0x) to reach minimum [width]</li>
<li>ignored when align is specified</li>
</ul>
</li>
</ul>
</li>
<li>align specifier:
<ul>
<li><code>&lt;</code> left: default for non-integer/non-FP</li>
<li><code>&gt;</code> right: default for integer/FP</li>
<li><code>^</code> center</li>
<li><code>[fill]</code>: specify a fill charater</li>
</ul>
</li>
<li>sign specifier:
<ul>
<li><code>-</code> display sign only for negative numbers (default)</li>
<li><code>+</code> display sign for negative and positive numbers</li>
<li><code> </code> display minus sign for negative num and space for positive num.</li>
</ul>
</li>
<li>alternative formatting <code>#</code> based on type specifier:
<ul>
<li>hex: insert <code>0x</code> or <code>0X</code> at front</li>
<li>binary: insert <code>0b</code> or <code>0B</code> at front</li>
<li>octal: insert <code>0</code> at front</li>
<li>FP: always show decimal separator, even without following digits</li>
</ul>
</li>
<li>type specifier:
<ul>
<li>integer: decimal (default): <code>d</code>, binary: <code>b</code>/<code>B</code>, octal: <code>o</code>, hex: <code>x</code>/<code>X</code></li>
<li>FP: scientific: <code>e</code>/<code>E</code>, fixed notation: <code>f</code>/<code>F</code>, general notation(default, either fixed or scientific): <code>g</code>/<code>G</code>, hexdecimal notation: <code>a</code>/<code>A</code>.</li>
<li>boolean: true/false in text(default): <code>s</code>, integer (1 or 0): <code>b/B/c/d/o/x/X</code></li>
<li>char: character (default): <code>c</code>, integer: <code>b/B/d/o/x/X</code></li>
<li>string: the string: <code>s</code></li>
<li>pointers: hex notation prefixed with 0x (default): <code>p</code>
<ul>
<li>only <code>void*</code> variable (thus, <code>static_cast&lt;void*&gt;(p)</code> is usually needed) and <code>nullptr</code> and considered as pointer type</li>
</ul>
</li>
</ul>
</li>
<li>precision specifier:
<ul>
<li>only for FP (number of decimal digits) and string (characters to output)
<ul>
<li>Default FP precision after dot: 6</li>
</ul>
</li>
<li>dynamic width by another <code>{}</code>, or by positional index <code>{2}</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Supporting custom types</strong></p>
<ul>
<li>specialization of <code>formatter&lt;&gt;</code> class tempalte</li>
<li><code>formatter::parse()</code>: how to parse the format specifier</li>
<li><code>formatter::format()</code>: how to perform the actualy formatting of the user type object to the format buffer</li>
</ul>
<p>We can use the standard formatters to simplify formatting custom types by two apporaches:</p>
<ul>
<li>You can <em>delegate</em> the works to a local standard formatter.</li>
<li>You can <em>inherit</em> from a standard formatter.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;format&gt;</span></span>

<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">std</span>:</span>:formatter&lt;Always42&gt;
{
  <span class="hljs-comment">// use a standard int formatter that does the work:</span>
  std::formatter&lt;<span class="hljs-keyword">int</span>&gt; f;

  <span class="hljs-comment">// delegate parsing to the standard formatter:</span>
  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">parse</span><span class="hljs-params">(std::format_parse_context&amp; ctx)</span> </span>{ <span class="hljs-comment">// Declaring format() as const might not compile. unless the formatter is declared as mutable.</span>
    <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">parse</span>(ctx);
  }

  <span class="hljs-comment">// delegate formatting of the value to the standard formatter:</span>
  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">format</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Always42&amp; obj, std::format_context&amp; ctx)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-comment">// Declaring parse() as constexpr might not compile.</span>
    <span class="hljs-keyword">return</span> f.format(obj.<span class="hljs-built_in">getValue</span>(), ctx);
  }
};
</div></code></pre>
<br>
<br>
<h1 id="constinit-consteval-and-compile-time-computing"><code>constinit</code>, <code>consteval</code>, and Compile-Time Computing</h1>
<h2 id="constint"><code>constint</code></h2>
<p><a href="http://wg21.link/p1143r2">http://wg21.link/p1143r2</a></p>
<p>C++20 introduces new keyword <code>constinit</code>. It can be used to force and ensure that a mutable static
or global variable gets initialized at compile time. So, roughly speaking the effect is described as:</p>
<blockquote>
<p><code>constinit</code> = <span style="color:blue"><code>constexpr</code></span> - <span style="color:blue"><code>const</code></span></p>
</blockquote>
<ul>
<li>a <code>constinit</code> variable is not <code>const</code></li>
<li>the keyword would better have been named &quot;compiletimeinit&quot;.</li>
<li>You can use <code>constinit</code> whenever you declare a static or global variable.</li>
</ul>
<p>The motivation:</p>
<ul>
<li>You can require initialization of mutable global/static objects at compile-time, to avoid initialization at runtime. This especially can improve performance when using <code>thread_local</code> variables.
<ul>
<li>for <code>constinit</code> <code>thread_local</code> variables, internally no guard has to be generated to signal whether the variable is already initialized inside the thread, thus might result in performance improvement.</li>
</ul>
</li>
<li>You can ensure that a global/static object is always initialized when being used. It can be used to fix the <em>static initialization order fiasco</em>.</li>
</ul>
<p><strong>It's a good programming style</strong> that global and static variables are always declared with constinit provided the initialization does not need any runtime value/feature.</p>
<p>Some examples:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">constinit</span> <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// f() must be a compile-time function</span>

<span class="hljs-comment">// you cannot initialize a constinit value with another non-const constinit value:</span>
<span class="hljs-keyword">constinit</span> <span class="hljs-keyword">auto</span> y = x; <span class="hljs-comment">// ERROR: x is not constant initializer</span>

<span class="hljs-comment">// constinit doesn&#x27;t imply inline (unlike constexpr)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span> {</span>
    <span class="hljs-keyword">constinit</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> val1 = <span class="hljs-number">42</span>; <span class="hljs-comment">// ERROR</span>
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">constinit</span> <span class="hljs-keyword">int</span> val2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// OK</span>
};

<span class="hljs-comment">// You can use constinit together with static and thread_local. Any order of constinit, static, and thread_local is fine.</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">constinit</span> <span class="hljs-keyword">int</span> numCalls = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">constinit</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> id = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> ++id;
}
</div></code></pre>
<h2 id="consteval"><code>consteval</code></h2>
<p><a href="http://wg21.link/p1073r3">http://wg21.link/p1073r3</a>.</p>
<p>Since C++11, C++ has the keyword <code>constexpr</code> to support evaluating functions at compile time. Provided
all aspects of the functions are known at compile time, you can also use the results in compile-time contexts. However, <code>constexpr</code> functions also serve as “normal” runtime functions.</p>
<p>C++20 introduces a similar keyword <code>consteval</code>, which mandates compile-time computing. <strong>It can't be called at runtime.</strong> Because these functions are called immediately when the compiler sees them, they are also called <em>immediate functions</em>.</p>
<ul>
<li>Immediate here means that the function is evaluated at the front-end, yielding only a value, which the back-end uses. Such a function never goes into your binary.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> Num&gt;
<span class="hljs-keyword">consteval</span>
std::array&lt;<span class="hljs-keyword">int</span>, Num&gt; <span class="hljs-title">primeNumbers</span><span class="hljs-params">()</span>
</span>{
  std::array&lt;<span class="hljs-keyword">int</span>, Num&gt; primes;
  ...
  <span class="hljs-keyword">return</span> primes;
}
<span class="hljs-keyword">auto</span> primes = primeNumbers&lt;<span class="hljs-number">100</span>&gt;(); <span class="hljs-comment">// it is required that this initialization happens at compile-time, so you don&#x27;t even need to say &quot;constinit&quot;</span>
</div></code></pre>
<ul>
<li>Functions marked with <code>consteval</code> can call other functions marked with <code>constexpr</code> or <code>consteval</code>.</li>
<li>However, <code>constexpr</code> functions cannot call <code>consteval</code> functions with runtime variables.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">funcConstEval</span>(i); <span class="hljs-comment">// ERROR</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">funcConstEval</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// OK</span>
}
</div></code></pre>
<p>For a <code>consteval</code> function it is not an error to have statements that call runtime functions if they are not reached</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">compileTimeError</span><span class="hljs-params">()</span> </span>{} <span class="hljs-comment">// a runtime function</span>

<span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextTwoDigitValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>
</span>{
    <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span> || val &gt;= <span class="hljs-number">99</span>) {
        <span class="hljs-built_in">compileTimeError</span>(); <span class="hljs-comment">// call something not valid to call at compile time</span>
    }
    <span class="hljs-keyword">return</span> ++val;
}
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> i1 = <span class="hljs-built_in">nextTwoDigitValue</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// OK (initializes i1 with 1)</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> i2 = <span class="hljs-built_in">nextTwoDigitValue</span>(<span class="hljs-number">77</span>); <span class="hljs-comment">// OK (initializes i2 with 78)</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> i3 = <span class="hljs-built_in">nextTwoDigitValue</span>(<span class="hljs-number">99</span>); <span class="hljs-comment">// compile-time ERROR</span>
</div></code></pre>
<h2 id="stdis_constant_evaluated"><code>std::is_constant_evaluated()</code></h2>
<p><a href="http://wg21.link/p0595r2">http://wg21.link/p0595r2</a>.</p>
<p>C++20 provides a new helper function to switch code between compile-time and runtime computing:
<code>std::is_constant_evaluated()</code>.</p>
<p><code>std::is_constant_evaluated()</code> yields true when it called in a <em>manifestly constant-evaluated</em> expression or conversion. That is roughly the case if we call it:</p>
<ul>
<li>in a constant-expression, or</li>
<li>in a constant context (in <code>if constexpr</code>, a <code>consteval</code> function, or an constant initialization), or</li>
<li>for an initializer of a variable usable at compile time</li>
</ul>
<p>In general, it makes no sense to use <code>std::is_constant_evaluated()</code></p>
<ul>
<li>in a compile-time <code>if</code>, because that always yields true</li>
<li>Inside a pure runtime function, because that usually yields false.</li>
<li>inside a consteval function, because that always yields true.
Therefore, using std::is_constant_evaluated() usually only makes sense in constexpr functions.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s)</span>
</span>{
  <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">is_constant_evaluated</span>()) {
    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (s[idx] != <span class="hljs-string">&#x27;\0&#x27;</span>) {      <span class="hljs-comment">// compile-time friendly code </span>
      ++idx;
    }
    <span class="hljs-keyword">return</span> idx;
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">strlen</span>(s);        <span class="hljs-comment">// function called at runtime </span>
  }
}

<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> l1 = <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// uses if-then branch</span>

<span class="hljs-comment">// This goes to else branch even if the compiler decides to evaluate the call at compile-time. The important point is that the call of len() and therefore the call of std::is_constant_evaluated() happens in a runtime context.</span>
<span class="hljs-keyword">int</span> l2 = <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello&quot;</span>);            <span class="hljs-comment">// uses else branch (no required compile-time context)</span>
</div></code></pre>
<h2 id="compile-time-stdvector-and-stdstring">Compile-time <code>std::vector</code> and <code>std::string</code></h2>
<p>Since C++20, compile-time functions can allocate memory provided the memory is also released at compile
time. For this reason, you can now use strings or vectors at compile time. However, you cannot use the
compile-time created strings or vectors at runtime because memory allocated at compile time has to be
released at compile time.</p>
<ul>
<li>We can use the full API of a vector (especially inserting and removing elements).</li>
<li>Most algorithms in <code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>, and <code>&lt;utility&gt;</code> are <code>constexpr</code> now. That means that you
can use, eg, <code>sort()</code> and <code>accumulate()</code> at compile time now.</li>
</ul>
<p>Some examples:</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">returnVector</span><span class="hljs-params">()</span> </span>{
    std::vector&lt;<span class="hljs-keyword">int</span>&gt; v{<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>};
    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">42</span>);
    <span class="hljs-keyword">return</span> v;
}
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">returnVectorSize</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> coll = <span class="hljs-built_in">returnVector</span>();
    <span class="hljs-keyword">return</span> coll.<span class="hljs-built_in">size</span>();
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// constexpr auto coll = returnVector(); // ERROR</span>
    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> tmp = <span class="hljs-built_in">returnVectorSize</span>(); <span class="hljs-comment">// OK</span>
}

<span class="hljs-function"><span class="hljs-keyword">consteval</span> std::string <span class="hljs-title">returnString</span><span class="hljs-params">()</span> </span>{
    std::string s = <span class="hljs-string">&quot;Some string from compile time&quot;</span>;
    <span class="hljs-keyword">return</span> s;
}
</div></code></pre>
<p>Although you cannot return a compile-time <code>std::vector</code> or <code>std::string</code> so that they can be used at runtime, there is a trick: We can convert the string into an <code>std::array&lt;&gt;</code> of fixed size and return both the array and the size of the vector.</p>
<p>Example of returning compile-time <code>std::string()</code> in runtime.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// function template to export a compile-time string to runtime:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> MaxSize&gt;
<span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">toRuntimeString</span><span class="hljs-params">(std::string s)</span>
</span>{
  <span class="hljs-comment">// ensure the size of the exported array is large enough:</span>
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">size</span>() &lt;= MaxSize);

  <span class="hljs-comment">// create a compile-time array and copy all characters into it: </span>
  std::array&lt;<span class="hljs-keyword">char</span>, MaxSize+1&gt; arr{};  <span class="hljs-comment">// ensure all elems are initialized</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) {
    arr[i] = s[i];
  }

  <span class="hljs-comment">// return the compile-time array and the string size:</span>
  <span class="hljs-keyword">return</span> std::pair{arr, s.<span class="hljs-built_in">size</span>()};
}

<span class="hljs-comment">// The runtime function fromComptimeString() then takes the returned array and size to initialize a runtime string and returns it:</span>
<span class="hljs-function">std::string <span class="hljs-title">fromComptimeString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; dataAndSize)</span>
</span>{
  <span class="hljs-comment">// init string with exported array of chars and size:</span>
  <span class="hljs-keyword">return</span> std::string{dataAndSize.first.<span class="hljs-built_in">data</span>(),
                     dataAndSize.second};
}

<span class="hljs-comment">// test the functions:</span>
<span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">comptimeMaxStr</span><span class="hljs-params">()</span>
</span>{
  std::string s = <span class="hljs-string">&quot;max int is &quot;</span> + <span class="hljs-built_in">asString</span>(std::numeric_limits&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-built_in">max</span>())
                  + <span class="hljs-string">&quot; (&quot;</span> + <span class="hljs-built_in">asString</span>(std::numeric_limits&lt;<span class="hljs-keyword">int</span>&gt;::digits + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; bits)&quot;</span>;

  <span class="hljs-keyword">return</span> toRuntimeString&lt;<span class="hljs-number">100</span>&gt;(s);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  std::string s = <span class="hljs-built_in">fromComptimeString</span>(<span class="hljs-built_in">comptimeMaxStr</span>());
}
</div></code></pre>
<br>
<br>
<h1 id="non-type-template-parameter-nttp-extensions">Non-Type Template Parameter (NTTP) Extensions</h1>
<p><a href="http://wg21.link/p0732r2">http://wg21.link/p0732r2</a></p>
<p>As a refresher, a non-type template parameter is a template parameter that does not name a type, but rather, a constant value (e.g. <code>template&lt;int value&gt;</code>).</p>
<p>Before C++20, Non-type template parameters (NTTP) are one of these:</p>
<ul>
<li>an integral type;</li>
<li>an enumeration type;</li>
<li>a pointer type (to object or to function);</li>
<li>a pointer to member type (to member object or to member function);</li>
<li>lvalue reference type (to object or to function);</li>
<li><code>std::nullptr_t</code> (since C++11)</li>
<li>Array types can be used as NTTP, but only syntactically - like function arguments of array type, they decay to pointers.</li>
<li><code>auto</code> (since C++17)</li>
</ul>
<p>Since C++20 you can use new types for non-type template parameters:</p>
<ul>
<li>Floating-point types (such as <code>double</code>)</li>
<li>Structures and simple classes (such as <code>std::pair&lt;&gt;</code>), which indirectly also allows us to use <strong>string literals</strong> as template parameters</li>
<li>Lambdas</li>
</ul>
<p><strong>Floating-points</strong> NTTP</p>
<p><a href="http://wg21.link/p1714r0">http://wg21.link/p1714r0</a></p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> Vat&gt;
<span class="hljs-keyword">int</span> <span class="hljs-title">addTax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{}
std::cout &lt;&lt; addTax&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-number">1950</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// Vat is int</span>
std::cout &lt;&lt; addTax&lt;<span class="hljs-number">0.07</span>&gt;(<span class="hljs-number">1950</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// Vat is double</span>

<span class="hljs-comment">// can be used in class templates too</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">double</span> Vat&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tax</span> {</span>
    ...
};
</div></code></pre>
<p><strong>structural type</strong> NTTP</p>
<p>Since C++20, you can use an object of a class as a non-type template parameter. This works if the class is a <em>structural type</em>. This roughly means that it only has public data members and that it is a literal type that can be used at compile time (being either an aggregate or having a constexpr constructor).</p>
<p>An identifier that names a non-type template parameter of class type T is called a <em>template parameter object</em>, it denotes a <em>static storage duration</em> object of type const T. All such template parameters in the program of the same type with the same value denote the same template parameter object, meaning only one instance of the object exists in the program.</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tax</span> {</span>
  <span class="hljs-keyword">double</span> value;
  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Tax</span><span class="hljs-params">(<span class="hljs-keyword">double</span> v)</span> : value{</span>v} {
      <span class="hljs-built_in">assert</span>(v &gt;= <span class="hljs-number">0</span> &amp;&amp; v &lt; <span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (std::ostream&amp; strm, <span class="hljs-keyword">const</span> Tax&amp; t) { <span class="hljs-keyword">return</span> strm &lt;&lt; t.value;  }
};

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Tax Vat&gt;
<span class="hljs-keyword">int</span> <span class="hljs-title">addTax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(std::<span class="hljs-built_in">round</span>(value * (<span class="hljs-number">1</span> + Vat.value))); 
}

<span class="hljs-keyword">constexpr</span> Tax tax{<span class="hljs-number">0.19</span>};
std::cout &lt;&lt; addTax&lt;tax&gt;(<span class="hljs-number">100</span>) 
std::cout &lt;&lt; addTax&lt;Tax{<span class="hljs-number">0.07</span>}&gt;(<span class="hljs-number">1950</span>);
</div></code></pre>
<p><strong>string literal</strong> NTTP</p>
<p>String literal isn't directly supported, it works by wrapping the constant expression string in a structural class literal, which would store its characters in a fixed-length array (e.g. <code>char[N]</code>).</p>
<p>This is because string literals don't have linkage, so it'd be unclear whether <code>foo&lt;&quot;bar&quot;&gt;</code> in one TU is the same entity as <code>foo&lt;&quot;bar&quot;&gt;</code> in another TU.</p>
<p>Example:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">size_t</span> N&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StringLiteral</span> {</span>
    <span class="hljs-comment">// constexpr constructor, we can use deduction guide instead as well.</span>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">StringLiteral</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> (&amp;str)[N])</span> </span>{
        std::<span class="hljs-built_in">copy_n</span>(str, N, value);
    }  
    <span class="hljs-keyword">char</span> value[N];
};

<span class="hljs-comment">// If we dont write out the constructor, we can have deduction guide</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-keyword">size_t</span> N&gt; <span class="hljs-title">StringLiteral</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>(&amp;)[N])</span> -&gt; Str&lt;N&gt;</span>; <span class="hljs-comment">// deduction guide</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;StringLiteral lit&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> size = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(lit.value); <span class="hljs-comment">// The size of the string is available as a constant expression.</span>
    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> contents = lit.value;     <span class="hljs-comment">// and so is the string&#x27;s content.</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;Size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot;, Contents: &quot;</span> &lt;&lt; contents &lt;&lt; std::endl;
}

Print&lt;<span class="hljs-string">&quot;literal string&quot;</span>&gt;(); <span class="hljs-comment">// Prints &quot;Size: 15, Contents: literal string&quot;</span>
</div></code></pre>
<p><strong>lambda</strong> NTTP</p>
<p>Because lambdas are just shortcuts for function objects, they can also be used now as NTTP if</p>
<ul>
<li>The lambda may not capture anything.</li>
<li>The lambda must be usable at compile time.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::invocable <span class="hljs-keyword">auto</span> GetVat&gt;
<span class="hljs-keyword">int</span> <span class="hljs-title">addTax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(std::<span class="hljs-built_in">round</span>(value * (<span class="hljs-number">1</span> + <span class="hljs-built_in">GetVat</span>()))); 
}

<span class="hljs-keyword">auto</span> getDefaultTax = [] {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0.19</span>;
}
std::cout &lt;&lt; addTax&lt;getDefaultTax&gt;(<span class="hljs-number">1950</span>);
std::cout &lt;&lt; addTax&lt;[]{ <span class="hljs-keyword">return</span> <span class="hljs-number">0.19</span>; }&gt;(<span class="hljs-number">100</span>);
}
</div></code></pre>
<p>Note the different below two declaration</p>
<ul>
<li>the first with &quot;<code>auto</code>&quot; is a <em>NTTP</em>: Non-Type template parameter. We use <code>std::invocable</code> as type constraint of the declaration of an object, which here is callable (function, function object, or lambda) to call.</li>
<li>the one without &quot;<code>auto</code>&quot; is a ordinary <em>type</em> template parameter, it is just constrained with <code>std::invocable</code> concept.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;std::invocable <span class="hljs-keyword">auto</span> GetVat&gt; <span class="hljs-comment">// GetVat is type-constrained function/lambda to call</span>

<span class="hljs-keyword">template</span>&lt;std::invocable GetVat&gt; <span class="hljs-comment">// GetVat is a constrained type</span>
</div></code></pre>
<br>
<br>
<h1 id="new-type-traits">New Type Traits</h1>
<p><strong><code>is_bounded_array_v&lt;T&gt;</code> and <code>is_unbounded_array_v&lt;T&gt;</code></strong></p>
<p>yields whether type <code>T</code> is a bounded/unbounded array (extent known/unknown).</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>];
std::is_bounded_array_v&lt;<span class="hljs-keyword">decltype</span>(a)&gt; <span class="hljs-comment">// true</span>
std::is_unbounded_array_v&lt;<span class="hljs-keyword">decltype</span>(a)&gt; <span class="hljs-comment">// false</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> b[];
std::is_bounded_array_v&lt;<span class="hljs-keyword">decltype</span>(b)&gt; <span class="hljs-comment">// false</span>
std::is_unbounded_array_v&lt;<span class="hljs-keyword">decltype</span>(b)&gt; <span class="hljs-comment">// true</span>
</div></code></pre>
<p><strong><code>remove_cvref_t&lt;T&gt;</code></strong></p>
<p>yields type <code>T</code> without being a reference, const, and volatile.</p>
<p>It is equivalent to:</p>
<ul>
<li><code>std::remove_cv_t&lt;remove_reference_t&lt;T&gt;&gt;.</code></li>
</ul>
<p><strong><code>unwrap_reference_t&lt;T&gt;</code> and <code>unwrap_ref_decay_t&lt;T&gt;</code></strong></p>
<ul>
<li>yields the wrapped type of T if it is a <code>std::reference_wrapper&lt;&gt;</code> (created with <code>std::ref()</code> or <code>std::cref()</code>) or otherwise T.</li>
<li>yields the wrapped type of T if it is a <code>std::reference_wrapper&lt;&gt;</code> (created with <code>std::ref()</code> or <code>std::cref()</code>) or otherwise the <em>decayed</em> type of T.</li>
</ul>
<p><strong><code>std::common_reference_t&lt;T...&gt;</code></strong></p>
<p><strong><code>std::type_identity_t&lt;T&gt;</code></strong></p>
<p>yields just type T.</p>
<p>You can disable that a parameter is used to deduce a template parameter. For example:</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::vector&lt;T&gt;&amp; coll, <span class="hljs-keyword">const</span> std::<span class="hljs-keyword">type_identity_t</span>&lt;T&gt;&amp; value)</span>
</span>{
    coll.<span class="hljs-built_in">push_back</span>(value);
}

std::vector&lt;<span class="hljs-keyword">double</span>&gt; coll;
<span class="hljs-built_in">insert</span>(coll, <span class="hljs-number">42</span>);    <span class="hljs-comment">// OK: type of 42 not used to deduce type T</span>
<span class="hljs-comment">// If the parameter value would be declared just with const T&amp;, the compiler would raise an error because it would deduce two different types for type T.</span>
</div></code></pre>
<p>You can use it as building block to define type traits that yield types. For example, you could define a type trait that removes constness simply as follows:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_const</span> :</span> std::type_identity&lt;T&gt; {
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_const</span>&lt;</span><span class="hljs-keyword">const</span> T&gt; : std::type_identity&lt;T&gt; {
};
</div></code></pre>
<p><strong><code>std::iter_difference_t&lt;T&gt;</code></strong></p>
<p>yields the difference type that corresponds to the incrementable/iterator type T. The trait is especially provided to deal with the value type of two objects of a <em>indirectly readable</em> type.</p>
<ul>
<li>concept <code>std::indirectly_readable&lt;P&gt;</code>: guarantees that P is a pointer-like object supporting operator * for read access. Satisfied by raw pointers, smart pointers, and iterators.</li>
</ul>
<p>Note that there is no corresponding data structure <code>std::iter_difference</code> with a member named type.
Instead, the type trait is defined by trying to use the member difference_type of the new auxiliary type
<code>std::incrementable_traits&lt;&gt;</code>, which is already defined as follows:</p>
<ul>
<li>If specialized, <code>std::incrementable_traits&lt;T&gt;::difference_type</code> is used.</li>
<li>For raw pointers <code>std::ptrdiff_t</code> is used.</li>
<li>Otherwise, if defined, <code>T::difference_type</code> is used.</li>
<li>Otherwise, the signed integral difference type of the difference of two T’s is used</li>
<li>For a const T the difference type of T is used.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-keyword">using</span> T1 = std::<span class="hljs-keyword">iter_difference_t</span>&lt;<span class="hljs-keyword">int</span>*&gt;;                    <span class="hljs-comment">// std::ptrdiff_t</span>
<span class="hljs-keyword">using</span> T2 = std::<span class="hljs-keyword">iter_difference_t</span>&lt;std::string&gt;;             <span class="hljs-comment">// std::ptrdiff_t</span>
<span class="hljs-keyword">using</span> T3 = std::<span class="hljs-keyword">iter_difference_t</span>&lt;std::vector&lt;<span class="hljs-keyword">long</span>&gt;&gt;;       <span class="hljs-comment">// std::ptrdiff_t</span>
<span class="hljs-keyword">using</span> T4 = std::<span class="hljs-keyword">iter_difference_t</span>&lt;<span class="hljs-keyword">int</span>&gt;;                     <span class="hljs-comment">// int</span>
<span class="hljs-keyword">using</span> T5 = std::<span class="hljs-keyword">iter_difference_t</span>&lt;std::chrono::sys_seconds&gt;; <span class="hljs-comment">// ERROR</span>
</div></code></pre>
<p><strong><code>std::iter_value_t&lt;T&gt;</code></strong></p>
<p>yields the non-const value/element type that corresponds to the pointer/iterator type T. The trait is especially provided to deal with the value type of an <em>indirectly readable</em> type.</p>
<ul>
<li>If specialized, <code>std::indirectly_readable_traits&lt;T&gt;::value_type</code> is used.</li>
<li>For raw pointers the non-const/volatile type it refers to is used.</li>
<li>Otherwise, if defined, <code>remove_cv_t&lt;T::value_type&gt;</code> is used.</li>
<li>Otherwise, if defined, <code>remove_cv_t&lt;T::element_type&gt;</code> is used.</li>
<li>For a <code>const T</code> the value type of <code>T</code> is used.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-keyword">using</span> T1 = std::<span class="hljs-keyword">iter_value_t</span>&lt;<span class="hljs-keyword">int</span>*&gt;;             <span class="hljs-comment">// int</span>
<span class="hljs-keyword">using</span> T2 = std::<span class="hljs-keyword">iter_value_t</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* <span class="hljs-keyword">const</span>&gt;; <span class="hljs-comment">// int</span>
<span class="hljs-keyword">using</span> T3 = std::<span class="hljs-keyword">iter_value_t</span>&lt;std::string&gt;;      <span class="hljs-comment">// char</span>
<span class="hljs-keyword">using</span> T4 = std::<span class="hljs-keyword">iter_value_t</span>&lt;std::vector&lt;<span class="hljs-keyword">long</span>&gt;&gt;; <span class="hljs-comment">// long</span>
<span class="hljs-keyword">using</span> T5 = std::<span class="hljs-keyword">iter_value_t</span>&lt;<span class="hljs-keyword">int</span>&gt;;              <span class="hljs-comment">// ERROR</span>
</div></code></pre>
<p><strong><code>iter_reference_t&lt;T&gt;</code> and <code>iter_rvalue_reference_t&lt;T&gt;</code></strong></p>
<ul>
<li>yields the lvalue reference type that corresponds to the dereferenceable pointer/iterator type T. It is equivalent to: <code>decltype(*declval&lt;T&amp;&gt;())</code></li>
<li>yields the rvalue value type that corresponds to the dereferenceable pointer/iterator type T. It is equivalent to: <code>decltype(std::ranges::iter_move(declval&lt;T&amp;&gt;()))</code></li>
<li>The traits are especially provided to deal with the value type of an <em>indirectly writable</em> type.</li>
</ul>
<p><code>std::indirectly_writable&lt;P, Val&gt;</code></p>
<ul>
<li>guarantees that <code>P</code> is a pointer-like object supporting <code>operator *</code> to assign a <code>Val</code>.</li>
<li>satisfied by non-const raw pointers, smart pointers, and iterators provided <code>Val</code> can be assigned to where <code>P</code> refers to.</li>
</ul>
<p><strong><code>std::is_layout_compatible_v&lt;T1, T2&gt;</code></strong></p>
<p>yields whether types T1 and T2 are layout compatible so that you can safely convert pointers to them with
reinterpret_cast.</p>
<p><strong><code>std::is_layout_pointer_interconvertible_base_of&lt;Base, Der&gt;</code></strong></p>
<p>yields true if a pointer to type <code>Der</code> can safely be converted to a pointer to its base type <code>Base</code> with
<code>reinterpret_cast</code>.
If both are the same types the trait always yields true.</p>
<br>
<br>
<h1 id="small-language-improvements">Small Language Improvements</h1>
<h2 id="range-based-for-loop-with-initialization">Range-Based <code>for</code> Loop with Initialization</h2>
<p><a href="http://wg21.link/p0614r1">http://wg21.link/p0614r1</a>.</p>
<p>C++17 introduced optional initialization for the <code>if</code> and <code>switch</code> control structures. C++20, now introduced such an optional initialization for the range-based <code>for</code> loop.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; elem : coll) {
  std::cout &lt;&lt; std::format(<span class="hljs-string">&quot;{:3}: {}\n&quot;</span>, i, elem);
  ++i;
}

<span class="hljs-keyword">for</span> (std::lock_guard lg{collMx}; <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; elem : coll) {
  std::cout &lt;&lt; elem: &lt;&lt; elem &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
}

<span class="hljs-comment">// the initializer needs to declare a variable with a name. Otherwise, the initialization itself is an expression that creates and immediately destroys a temporary object. </span>
<span class="hljs-keyword">for</span> (std::lock_guard{collMx}; <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; elem : coll) {  <span class="hljs-comment">// runtime ERROR</span>
  std::cout &lt;&lt; elem: &lt;&lt; elem &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;                     <span class="hljs-comment">// - no longer locked</span>
}
</div></code></pre>
<p>This can work-around a bug in iteration on temporary objects.</p>
<pre><code class="language-C++"><div>std::optional&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">getValues</span>();                <span class="hljs-comment">// forward declaration</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : <span class="hljs-built_in">getValues</span>().<span class="hljs-built_in">value</span>()) {  ... }                  <span class="hljs-comment">// fatal runtime ERROR (undefined behavior)</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; optColl = <span class="hljs-built_in">getValues</span>(); <span class="hljs-keyword">int</span> i : optColl) { ... } <span class="hljs-comment">// OK</span>
</div></code></pre>
<h2 id="using-for-enumeration-values"><code>using</code> for Enumeration Values</h2>
<p><a href="http://wg21.link/p1099r5">http://wg21.link/p1099r5</a>.</p>
<p>To make the use of scoped enumeration types more convenient, you can now use a
<code>using enum declaration</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>{</span>open, progress, done = <span class="hljs-number">9</span>};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Status s)</span> </span>{
  <span class="hljs-keyword">using</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Status</span>;</span>  <span class="hljs-comment">// make enum values available in current scope</span>
  <span class="hljs-comment">// using Status::open, Status::progress, Status::done; // this also OK</span>
  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (s) {
   <span class="hljs-keyword">case</span> open:
    std::cout &lt;&lt; <span class="hljs-string">&quot;open&quot;</span>;
    <span class="hljs-keyword">break</span>;
    ...
  }
}
</div></code></pre>
<p>Using enum declarations can also be used to delegate enumeration values to different scopes.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">namespace</span> MyProject {
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> {</span>
   <span class="hljs-keyword">public</span>:
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Status</span>{</span>open, progress, done = <span class="hljs-number">9</span>};
  };

  <span class="hljs-keyword">using</span> Status = Task::Status;  <span class="hljs-comment">// expose the type Task::Status</span>
  <span class="hljs-keyword">using</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Task</span>:</span>:Status;      <span class="hljs-comment">// expose the values of Task::Status</span>
}

MyProject::Status s = MyProject::done;  <span class="hljs-comment">// OK</span>
</div></code></pre>
<h2 id="char8_t-and-stdu8string"><code>char8_t</code> and <code>std::u8string</code></h2>
<p><a href="http://wg21.link/p0482r6">http://wg21.link/p0482r6</a>.</p>
<p>For better UTF-8 support, C++20 introduces the new character type <code>char8_t</code> and a new corresponding
string type <code>std::u8string</code>.</p>
<h2 id="designated-initializers-for-aggregates">Designated Initializers for Aggregates</h2>
<p><a href="http://wg21.link/p0329r0">http://wg21.link/p0329r0</a>.</p>
<p>Since C++20, C++ provides a way to specify for initializers of aggregates, which member should be initialized with a value.</p>
<ul>
<li>You have pass the initial value with = or {}.</li>
<li>You can skip members, but you have to follow their order.</li>
<li>You either have to use designated initializers for all or none of the arguments. Mixed initialization is not allowed.</li>
<li>Using designated initialization for arrays is not supported.</li>
<li>Nested initialization with designated initializers is possible, but not directly using <code>.mem.mem</code>.</li>
<li>You cannot use designated initializers when initializing aggregates with parentheses.</li>
<li>Designated initializers can also be used in unions.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Value</span> {</span>
  <span class="hljs-keyword">double</span> amount = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> precision = <span class="hljs-number">2</span>;
  std::string unit = <span class="hljs-string">&quot;Dollar&quot;</span>;
};
Value v1{<span class="hljs-number">100</span>};                             <span class="hljs-comment">// OK (not designated initializers)</span>
Value v2{.amount = <span class="hljs-number">100</span>, .unit = <span class="hljs-string">&quot;Euro&quot;</span>};   <span class="hljs-comment">// OK (second member has default value)</span>
Value v3{.precision = <span class="hljs-number">8</span>, .unit = <span class="hljs-string">&quot;$&quot;</span>};     <span class="hljs-comment">// OK (first member has default value)</span>
Value v4{<span class="hljs-number">100</span>, .unit = <span class="hljs-string">&quot;Euro&quot;</span>};             <span class="hljs-comment">// ERROR: all or none designated</span>
Value v5{.unit = <span class="hljs-string">&quot;$&quot;</span>, .amount = <span class="hljs-number">20</span>};       <span class="hljs-comment">// ERROR: invalid order</span>
<span class="hljs-function">Value <span class="hljs-title">v6</span><span class="hljs-params">(.amount = <span class="hljs-number">29.9</span>, .unit = <span class="hljs-string">&quot;Euro&quot;</span>)</span></span>;  <span class="hljs-comment">// ERROR: only supported for curly braces</span>

<span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Sub</span> {</span>
  <span class="hljs-keyword">double</span> x = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> {</span>
  std::string name;
  Sub val;
};
Data d1{.val{.y=<span class="hljs-number">42</span>}};       <span class="hljs-comment">// OK</span>
Data d2{.val = {.y{<span class="hljs-number">42</span>}}};   <span class="hljs-comment">// OK</span>
Data d2{.val.y = <span class="hljs-number">42</span>};       <span class="hljs-comment">// ERROR</span>
</div></code></pre>
<h2 id="aggregate-initialization-with-parentheses">Aggregate Initialization with Parentheses</h2>
<p><a href="http://wg21.link/p0960r3">http://wg21.link/p0960r3</a>.</p>
<h2 id="attributes-likely-and-unlikely">Attributes<code> [[likely]]</code> and <code>[[unlikely]]</code></h2>
<p>The new attributes [[likely]] and [[unlikely]] were introduced by C++20 to be able to help the
compiler when performing branch optimizations.</p>
<ul>
<li>The effect of these attributes is compiler-specific and there is no guarantee that the attributes have any impact at all.</li>
<li>Often compilers know better how to optimize code so that excessive usage of these attributes might be counter-productive.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) [[unlikely]] {  <span class="hljs-comment">// n &lt;= 0 is considered to be arbitrarily unlikely</span>
    <span class="hljs-keyword">return</span> n;
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> n * n;
  }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (n) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">break</span>;
    [[likely]] <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        <span class="hljs-comment">// n == 2 is considered to be arbitrarily most likely</span>
      ...
      <span class="hljs-keyword">break</span>;
  }
}
</div></code></pre>
<h2 id="attribute-no_unique_address">Attribute <code>[[no_unique_address]]</code></h2>
<p><a href="http://wg21.link/p0840r2">http://wg21.link/p0840r2</a>.</p>
<p>Classes often have members that impact the behavior but do not provide state. Example are the hash function of an unordered container, the deleter of a <code>std::unique_ptr</code> , or a standard allocator of containers or strings are members: All they provide are member functions (and static members), but no non-static data members.</p>
<p>However, members usually need memory although they do not store anything</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Empty</span> {</span>};   <span class="hljs-comment">// empty class: size is usually 1</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">I</span> {</span>         <span class="hljs-comment">// size is e.g. 4  (same as sizeof(int))</span>
  Type i;
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EandI</span> {</span>     <span class="hljs-comment">// size is e.g. 8 (sum of members with alignment)</span>
  Empty e;
  <span class="hljs-keyword">int</span> i;
};
</div></code></pre>
<p>Before C++20, you could use the <em>empty base class optimization</em> (EBCO) to avoid the unnecessary overhead. But it is clumsy. Since C++20, you only have to declare the members that provide not state with the attribute <code>[[no_unique_address]]</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EattrI</span> {</span>             <span class="hljs-comment">// same effect as EBCO, size is e.g. 4</span>
  [[no_unique_address]] Empty e;
  <span class="hljs-keyword">int</span> i;
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IattrE</span> {</span>             <span class="hljs-comment">// same effect as EBCO, size is e.g. 4</span>
  <span class="hljs-keyword">int</span> i;
  [[no_unique_address]] Empty e;
};

<span class="hljs-comment">// The member marked with [[no_unique_address]] still counts as member for initialization:</span>
EattrI ei = {<span class="hljs-number">42</span>};           <span class="hljs-comment">// ERROR: can&#x27;t initialize member e with 42</span>
EattrI ei = {{},<span class="hljs-number">42</span>};        <span class="hljs-comment">// OK</span>
</div></code></pre>
<p>This optimization also means that the address of the member <code>e</code> gets same address as the member <code>i</code> of the same object.</p>
<h2 id="implicit-typename-for-type-members-of-template-parameters">Implicit <code>typename</code> for Type Members of Template Parameters</h2>
<p><a href="http://wg21.link/p0634r3">http://wg21.link/p0634r3</a>.</p>
<p>Since C++20, you can skip typename in contexts where it is clear that a type is passed. In this case this applies to the specification of the return type and the type used in the alias declaration (where using introduces a new name for a type):</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-comment">/*typename omitted*/</span> <span class="hljs-function">T::value_type <span class="hljs-title">getElem</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; cont, <span class="hljs-keyword">typename</span> T::iterator pos <span class="hljs-comment">/*still need typename*/</span>)</span>
</span>{
  <span class="hljs-keyword">using</span> Itor = <span class="hljs-comment">/*typename omitted*/</span> T::iterator;
  <span class="hljs-keyword">typename</span> T::value_type elem; <span class="hljs-comment">// still need typename</span>
  ...
  <span class="hljs-keyword">return</span> elem;
}
</div></code></pre>
<p>However, because the rules for implicit typename are partially pretty subtle, you might simply still always
use typename when using the type member of a template parameter (at least outside class templates).</p>
<h2 id="ctad-for-aggregates"><em>CTAD</em> for Aggregates</h2>
<p><a href="http://wg21.link/p2082r1">http://wg21.link/p2082r1</a>.</p>
<p><a href="c17.html#class-template-argument-deduction-ctad">Since C++17, constructors can be used to deduce template parameters of class templates</a>, but this doesn't work for aggregate in C++17, you have to provide a deduction guide. The need for the deduction guide is gone since C++20.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Aggr</span> {</span>
  T value;
};

<span class="hljs-comment">// deduction guide not needed since C++20</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">Aggr</span><span class="hljs-params">(T)</span> -&gt; Aggr&lt;T&gt;</span>;

Aggr&lt;<span class="hljs-keyword">int</span>&gt; a1{<span class="hljs-number">42</span>};  <span class="hljs-comment">// OK</span>
Aggr a2{<span class="hljs-number">42</span>};       <span class="hljs-comment">// OK since C++17</span>
Aggr a2{<span class="hljs-number">42</span>};       <span class="hljs-comment">// OK since C++20 even without deduction guide</span>
<span class="hljs-comment">// this feature also works when using parentheses to initialize aggregates:</span>
<span class="hljs-function">Aggr <span class="hljs-title">a3</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;       <span class="hljs-comment">// OK since C++20 even without deduction guide</span>
</div></code></pre>
<h2 id="conditional-explicit">conditional <code>explicit</code></h2>
<p><a href="http://wg21.link/p0892r2">http://wg21.link/p0892r2</a>.</p>
<p>To disable implicit type conversions, constructors can be declared as <code>explicit</code>. However, for generic code, you might want to make the constructors <code>explicit</code> if and only if a type parameter has <code>explicit</code> constructors. That way you can perfectly delegate type conversion support to a wrapper type.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span> {</span>
    T value;
  <span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// If there is no implicit conversion from U to T, the constructor is explicit.</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-title">explicit</span><span class="hljs-params">(!std::is_convertible_v&lt;U, T&gt;)</span>
    <span class="hljs-title">Wrapper</span><span class="hljs-params">(<span class="hljs-keyword">const</span> U&amp; val)</span> 
     :value{</span>val} {
    }
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printVectorWrapper</span><span class="hljs-params">(Wrapper&lt;std::vector&lt;std::string&gt;&gt;)</span> </span>{ ... }

<span class="hljs-comment">// NO implicit conversion from size to vector&lt;string&gt;:</span>
std::vector&lt;std::string&gt; v1{<span class="hljs-number">42u</span>};
std::vector&lt;std::string&gt; v2 = <span class="hljs-number">42u</span>;              <span class="hljs-comment">// ERROR: explicit</span>
Wrapper&lt;std::vector&lt;std::string&gt;&gt; wv1{<span class="hljs-number">42u</span>};
Wrapper&lt;std::vector&lt;std::string&gt;&gt; wv2 = <span class="hljs-number">4u</span>2;    <span class="hljs-comment">// ERROR: explicit</span>
<span class="hljs-built_in">printVectorWrapper</span>(<span class="hljs-number">42u</span>);                        <span class="hljs-comment">// ERROR: explicit</span>
</div></code></pre>
<p>For <code>std::vector&lt;&gt;</code>, its constructor taking an unsigned size is declared as <code>explicit</code> in STL. For that reason, <code>std::is_convertible&lt;&gt;</code> from a size to the vector is false and the <code>Wrapper&lt;&gt;</code> constructor becomes <code>explicit</code>. Therefore, we also cannot pass a size to initialize a wrapper of vector of string or pass a size to a function taking that wrapper type.</p>
<p>The C++ standard library uses <em>conditional <code>explicit</code></em> in a couple of places. For example, <code>std::pair&lt;&gt;</code> and <code>std::tuple&lt;&gt;</code> use it to support assignments of pairs and tuples of slightly different types only if there are implicit conversion available.</p>
<ul>
<li>This behavior of <code>std::pair&lt;&gt;</code> is not new. However, before C++20, implementations of the standard library
had to use SFINAE to implement the conditional behavior of <code>explicit</code> (declaring two constructors and
disabling one of them if the condition is not met).</li>
<li>The <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0892r2.html">propsoal</a> has the example of conditional <code>explicit</code> simplifying the constructor of <code>std::pair&lt;&gt;</code> as the motivation of the change.</li>
</ul>
<h1 id="stl-improvements">STL improvements</h1>
<p><strong>std::string improvements</strong></p>
<p>In fact, C++20 introduces the following improvements for string types:</p>
<ul>
<li>All string types now support the spaceship <code>operator &lt;=&gt;</code>. For this, they now declare only <code>operator==</code>
and <code>operator&lt;=&gt;</code> and no longer declare <code>operator!=</code>, <code>operator&lt;</code>, <code>operator&lt;=</code>, <code>operator&gt;</code>, and
<code>operator&gt;=</code>.</li>
<li>All string types now provide the new member functions <code>starts_with()</code> and <code>end_with()</code>. <a href="http://wg21.link/p0457r2">http://wg21.link/p0457r2</a>.</li>
<li>For strings, the member function <code>reserve()</code> can no longer be used to request to shrink the capacity
(memory allocated for the value) of strings. For this reason, you can no longer pass no argument to
<code>reserve()</code>. Use <code>shrink_to_fit()</code> for this purpose. <a href="http://wg21.link/p0966r1">http://wg21.link/p0966r1</a>.</li>
<li>For UTF-8 characters, C++ provides now the string types <code>std::u8string</code> and <code>std::u8string_view</code>.
They are defined as <code>std::basic_string&lt;&gt;</code> and <code>std::basic_string_view&lt;&gt;</code> for the new UTF-8
character type char8_t. For this reason, library functions returning a UTF-8 string now have the return
type <code>std::u8string</code>. Note that this change might break existing code when switching to C++20.</li>
<li>Strings (<code>std::string</code> and other instantiations of <code>std::basic_string&lt;&gt;</code>) are <code>constexpr</code> now so that
you can use strings at compile time.
<ul>
<li>Note that you cannot use a std::string at both compile time and runtime. However, there are ways
to export a compile-time string to the runtime.</li>
</ul>
</li>
<li>String views are now marked as views and borrowed ranges.</li>
</ul>
<p><strong><code>std::ssize()</code></strong></p>
<p>The <code>ssize()</code> functions were discussed for a long time as a fix to the problem of comparing signed
indexes with unsigned sizes.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; coll.<span class="hljs-built_in">size</span>(); ++coll) { ... }<span class="hljs-comment">// possible warning</span>

<span class="hljs-comment">// A helper function std::ssize() was introduced that allows the following use instead:</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; std::<span class="hljs-built_in">ssize</span>(coll); ++coll) { ... } <span class="hljs-comment">// usually no warning</span>

<span class="hljs-comment">// Thanks to ADL, it is enough to write the following when a standard container or other standard types</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">ssize</span>(coll); ++coll) { ... } <span class="hljs-comment">// OK for std types</span>
</div></code></pre>
<p><strong><code>std::source_location</code></strong></p>
<p><a href="http://wg21.link/p1208r6">http://wg21.link/p1208r6</a>.</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;source_location&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// The static consteval function std::source_location::current() yields an object for the current source location of type std::source_location</span>
  <span class="hljs-keyword">auto</span> sl = std::source_location::<span class="hljs-built_in">current</span>();
  std::cout &lt;&lt; <span class="hljs-string">&quot;file:     &quot;</span> &lt;&lt; sl.<span class="hljs-built_in">file_name</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
  std::cout &lt;&lt; <span class="hljs-string">&quot;function: &quot;</span> &lt;&lt; sl.<span class="hljs-built_in">function_name</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
  std::cout &lt;&lt; <span class="hljs-string">&quot;line/col: &quot;</span> &lt;&lt; sl.<span class="hljs-built_in">line</span>() &lt;&lt; <span class="hljs-string">&#x27;/&#x27;</span> &lt;&lt; sl.<span class="hljs-built_in">column</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
}
</div></code></pre>
<p><strong>Mathematical Constants</strong></p>
<p><a href="http://wg21.link/p0631r8">http://wg21.link/p0631r8</a>.</p>
<p>The constants are provided in header <code>&lt;numbers&gt;</code> in namespace <code>std::numbers</code>.</p>
<p>The constants are specializations for type double of corresponding variable templates that have the suffix <code>_v</code>. The values are the nearest representable values of the corresponding type. For example:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">namespace</span> std::number {
  <span class="hljs-comment">// the variable template definitions use the istd::floating_point concept</span>
  <span class="hljs-keyword">template</span>&lt;std::floating_point T&gt; 
  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> T pi_v&lt;T&gt; = ...; 

  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">double</span> pi = pi_v&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// a speciailization for type double</span>
}

<span class="hljs-comment">// use it</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numbers&gt;</span></span>
<span class="hljs-keyword">double</span> area1 = rad * rad * std::numbers::pi;
<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> area2 = rad * rad * std::numbers::pi_v&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt;;
</div></code></pre>
<p><strong>Bit Operations</strong></p>
<p>C++20 introduces bit operations provide a direct API to the bit instructions of the underlying CPU.</p>
<p>They are provided in header file <code>&lt;bit&gt;</code> as free-standing functions in namespace std.</p>
<ul>
<li>only works on unsigned type (like <code>uint8_t</code>, <code>uint16_t</code>, etc, including <code>unsigned char</code>)</li>
<li>All functions returning a count have the return type <code>int</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Meaning</th>
<th>Intel/AMD</th>
<th>ARM</th>
</tr>
</thead>
<tbody>
<tr>
<td>rotl(val, n)</td>
<td>Yields val with n bits rotated to the left</td>
<td>ROL</td>
<td>-</td>
</tr>
<tr>
<td>rotr(val, n)</td>
<td>Yields val with n bits rotated to the right</td>
<td>ROR</td>
<td>ROR, EXTR</td>
</tr>
<tr>
<td>countl_zero(val)</td>
<td>Yields number of leading (most significant) 0 bits</td>
<td>BSR, LZCNT</td>
<td>CLZ</td>
</tr>
<tr>
<td>countl_one(val)</td>
<td>Yields number of leading (most significant) 1 bits</td>
<td>-</td>
<td>CLS</td>
</tr>
<tr>
<td>countr_zero(val)</td>
<td>Yields number of trailing (least significant) 0 bits</td>
<td>BSF, TZCNT</td>
<td>-</td>
</tr>
<tr>
<td>countr_one(val)</td>
<td>Yields number of trailing (least significant) 1 bits</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>popcount(val)</td>
<td>Yields number of 1 bits in the value</td>
<td>POPCNT</td>
<td>-</td>
</tr>
<tr>
<td>has_single_bit(val)</td>
<td>Yields whether val is a power of 2 (one bit set)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bit_floor(val)</td>
<td>Yields previous power-of-two value</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bit_ceil(val)</td>
<td>Yields next power-of-two value</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bit_width(val)</td>
<td>Yields number of bits necessary to store the value</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong><code>std::bit_cast&lt;&gt;()</code></strong></p>
<p><a href="http://wg21.link/p0476r2">http://wg21.link/p0476r2</a>.</p>
<p><code>std::bit_cast&lt;&gt;()</code> to change the type of a sequence of bits. Unlike when using
<code>reinterpret_cast&lt;&gt;</code> or union’s, the new operator <code>std::bit_cast&lt;&gt;</code> ensures that the number of bits
fits, a standard layout is used, and no pointer type is used.</p>
<pre><code class="language-C++"><div>std::<span class="hljs-keyword">uint8_t</span> b8 = <span class="hljs-number">0b0000&#x27;1101</span>;
<span class="hljs-keyword">auto</span> bc = std::bit_cast&lt;<span class="hljs-keyword">char</span>&gt;(b8);      <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">auto</span> by = std::bit_cast&lt;std::byte&gt;(b8); <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">auto</span> bi = std::bit_cast&lt;<span class="hljs-keyword">int</span>&gt;(b8);       <span class="hljs-comment">// ERROR: wrong number of bits</span>
</div></code></pre>
<p><strong><code>std::endian</code></strong></p>
<p><a href="http://wg21.link/p0463r1">http://wg21.link/p0463r1</a>. <a href="http://wg21.link/p1612r1">http://wg21.link/p1612r1</a>.</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bit&gt;</span></span>
<span class="hljs-comment">// As enumeration values these values can be used at compile-time.</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::endian::native == std::endian::big)</span> </span>{
  ...     <span class="hljs-comment">// handle big-endian</span>
}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in"><span class="hljs-keyword">constexpr</span></span> (std::endian::native == std::endian::little) {
  ...     <span class="hljs-comment">// handle little-endian</span>
}
<span class="hljs-keyword">else</span> {
  ...     <span class="hljs-comment">// handle mixed endian</span>
}
</div></code></pre>
<br>
<br>
<h1 id="corouties">Corouties</h1>
<p>Coroutines, in general, are functions that can be interrupted and resumed.</p>
<ul>
<li>they can greatly simplify writing event-driven programs</li>
<li>they are almost unavoidable for work-stealing thread pools</li>
<li>they make writing asynchronous I/O and other asynchronous code much easier</li>
</ul>
<p>Stackful coroutines (fiber)</p>
<ul>
<li>their state is allocated on the stack</li>
<li>more powerful and flexible</li>
</ul>
<p>Stackless coroutines (what C++ 20 supports)</p>
<ul>
<li>have no corresponding stack allocations, their state is stored on the heap</li>
<li>more efficient</li>
</ul>
<p>As of Sep 2021,</p>
<ul>
<li>For GCC, you need version 11 or later, with -std=c++20 and –fcoroutines options, with #include <coroutine> headers</li>
<li>For Clang, partial support was added in version 10 and was improved in later versions, and with
<code>-stdlib=libc++ -fcoroutines-ts</code> options, with <code>&lt;experimental/coroutine&gt;</code> headers, and std::experimental namespace.</li>
</ul>
<br>
<br>
<h1 id="concurrency-features">Concurrency features</h1>
<p><strong>Motivation</strong></p>
<p><code>std::thread</code> is not an RAII type. You either <code>join()</code> (to wait for the end for the running thread) or <code>detach()</code> (to let it run in the background). If neither is called when <code>std::thread</code> is destructed (eg, goes out of scope), the program calls <code>std::terminate()</code>, which calls <code>std::abort()</code> and usually causes a core dump.</p>
<ul>
<li>Even you have <code>t.join()</code> in the code, if <code>t.join()</code> is not called on an exception (or any other reason to leave the scope without reaching the call to <code>join()</code>), this code may also cause an abnormal program termination.</li>
<li>Another issue is calling <code>join()</code> might take significant time (or even take forever), there is no standard way to request for cancel for the thread.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// start thread calling task() with name and val as arguments:</span>
    std::thread t{task, name, val};
    ... <span class="hljs-comment">// neither t.join() nor t.detach() called</span>
} <span class="hljs-comment">// std::terminate() called</span>
</div></code></pre>
<h2 id="stdjthread-and-stop-tokens"><code>std::jthread</code> and stop tokens</h2>
<p>std::jthread is an RAII type. The destructor calls <code>join()</code> if the thread is joinable (the “j” stands for “joining”).</p>
<p>It also provides a mechanism to signal cancellation.</p>
<p>To react to the request, the callable has to add a new optional first parameter of type <code>std::stop_token</code> and check from time to time whether a stop was requested:</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">task</span> <span class="hljs-params">(std::stop_token st,
            std::string s, <span class="hljs-keyword">double</span> value)</span>
</span>{
    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">stop_requested</span>()) {  <span class="hljs-comment">// stop requested (e.g., by the destructor)?</span>
        ...  <span class="hljs-comment">// ensure we check from time to time</span>
    }
}
</div></code></pre>
<p>That means, <code>std::jthread</code> provides a <em>cooperative</em> mechanism to signal that a thread should no longer run. It is “cooperative” because the mechanism does not kill the running thread (again, in general you cannot kill threads). You can actively poll whether there is a stop requested or register a callback of type std::stop_callback which will be called when a stop is/was requested.</p>
<p>You can also manually request a started thread to stop. For example:</p>
<pre><code class="language-C++"><div>{
    <span class="hljs-comment">// start thread calling task() with name and val as arguments:</span>
    std::jthread t{task, name, val};
    t.<span class="hljs-built_in">request_stop</span>();  <span class="hljs-comment">// explicitly request task() to stop its execution</span>
    <span class="hljs-comment">// wait for thread to finish:</span>
    t.<span class="hljs-built_in">join</span>();
}
</div></code></pre>
<p>Another way is register callbacks for a stop token, which are automatically called when a stop is requested (whether it is an explicit call of <code>request_stop()</code> or caused by the destructor). The callback is called by the thread requesting the stop.</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">task</span> <span class="hljs-params">(std::stop_token st,
           std::string s, <span class="hljs-keyword">double</span> value)</span>
</span>{
  <span class="hljs-comment">// The std::stop_callback constructor registers a callable (function, function object, or lambda) to be called when a stop is requested for a specified stop token</span>
  std::stop_callback cb{st, [] {
                              ...  <span class="hljs-comment">// called on a stop request</span>
                            }};
} <span class="hljs-comment">// callback is unregistered at std::stop_callback destructor.</span>
</div></code></pre>
<h2 id="stdlatch"><code>std::latch</code></h2>
<p>A latch is a new synchronization mechanism that support a single-use asynchronous
countdown. Starting with an initial integral value various thread can atomically count this value down to
zero. The moment the counter reaches zero, all threads waiting for this countdown continue.</p>
<p>Common usages:</p>
<ul>
<li>Main thread waits (calls <code>l.wait()</code>) all child-threads finishing some work (each calls <code>l.count_down()</code>),then main thread can continue.</li>
<li>all threads synchronize at a specific point (each calls <code>l.arrive_and_wait()</code>) and then continue.</li>
</ul>
<p>Compared to C++11 with futures, threads, or condition variables combined with locks, Latches and barriers address no new use cases, but they are a lot easier to use. They are also more performant because they often use a lock-free mechanism internally.</p>
<table>
<thead>
<tr>
<th>Latch Operation</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>latch l{counter}</code></td>
<td>Creates a latch with counter as starting value for the countdown. The constructor takes a std::ptrdiff_t, which is signed. <br> Note Copy constructor is deleted. latch is neither copyable nor movable.</td>
</tr>
<tr>
<td><code>l.count_down()</code></td>
<td>Atomically decrements the counter (if not 0 yet) <br> <code>std::latch</code> can be decremented by a participating thread more than once.</td>
</tr>
<tr>
<td><code>l.count_down(val)</code></td>
<td>Atomically decrements the counter by val</td>
</tr>
<tr>
<td><code>l.wait()  </code></td>
<td>Blocks until the counter of the latch is 0</td>
</tr>
<tr>
<td><code>l.try_wait()</code></td>
<td>Yields whether the counter of the latch is 0</td>
</tr>
<tr>
<td><code>l.arrive_and_wait()</code></td>
<td>Calls <code>count_down()</code> and <code>wait()</code></td>
</tr>
<tr>
<td><code>l.arrive_and_wait(val)</code></td>
<td>Calls <code>count_down(val)</code> and <code>wait()</code></td>
</tr>
<tr>
<td><code>max()</code></td>
<td>Static function that yields the maximum possible value for counter</td>
</tr>
</tbody>
</table>
<h2 id="stdbarrier"><code>std::barrier&lt;&gt;</code></h2>
<p>A barrier is a new synchronization mechanism that allows you to synchronize multiple asynchronous tasks <em>multiple times</em>. Setting an initial counter multiple threads can count it down and wait until the counter reaches 0. However, in contrast to std::latch, an optional call back is called and the counter resets to the initial counter again.</p>
<p>The completion step performs the following steps:</p>
<ul>
<li>All threads are blocked.</li>
<li>An arbitrary thread is unblocked and executes the callable.</li>
<li>If the completion step is done, all threads are unblocked.</li>
</ul>
<p><code>std::barrier&lt;&gt;</code> is a class template with the type of the callback as template parameter. Usually the
type is deduced by <em>CTAD</em>.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// Note that the function has to be declared with noexcept to be used as barrier callback, because C++ standard requires that callbacks for barriers guarantees not to throw.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callback</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// forward declaration</span>
...
std::barrier b{<span class="hljs-number">6</span>, callback}; <span class="hljs-comment">// deduces std::barrier&lt;decltype(callback)&gt;</span>
</div></code></pre>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>barrier b{num}</code></td>
<td>Creates a barrier for num asynchronous tasks <br> if no callback is passed, a default <code>CompletionFunction()</code> is used, which does nothing. <br> Copy constructor is deleted. barrier is neither copyable nor movable.</td>
</tr>
<tr>
<td><code>barrier b{num, cb}</code></td>
<td>Creates a barrier for num asynchronous tasks and cb as callback</td>
</tr>
<tr>
<td><code>b.arrive() </code></td>
<td>Marks one task as done and yields an arrival token</td>
</tr>
<tr>
<td><code>b.arrive(val) </code></td>
<td>Marks val tasks as done and yields an arrival token</td>
</tr>
<tr>
<td><code>b.wait(arrivalToken)</code></td>
<td>Blocks until all tasks are done and the callback was called (if any)</td>
</tr>
<tr>
<td><code>b.arrive_and_wait()</code></td>
<td>Marks one task as done and blocks until all tasks are done and the callback was called (if any)</td>
</tr>
<tr>
<td><code>b.arrive_and_drop()</code></td>
<td>Marks one task as done and decrements the number of tasks to repeatedly perform. Essentially, next phase's starting value is decremented.</td>
</tr>
<tr>
<td><code>max()</code></td>
<td>Static function that yields the maximum possible value for num</td>
</tr>
</tbody>
</table>
<h2 id="stdcounting_semaphorestdptrdiff_t-leastmaxvalue-and-stdbinary_semaphore"><code>std::counting_semaphore&lt;std::ptrdiff_t LeastMaxValue&gt;</code> and <code>std::binary_semaphore</code></h2>
<p>Semaphores are lightweight synchronization primitive, which allow you to synchronize or restrict access to one or a group of resources.</p>
<p>a <code>counting_semaphore</code> allows more than one concurrent access to the same resource, for at least <code>LeastMaxValue</code> concurrent accessors.</p>
<ul>
<li>As its name indicates, the <code>LeastMaxValue</code> is the <em>minimum</em> max value, not the actual max value. Thus <code>max()</code> can yield a number larger than <code>LeastMaxValue</code>.</li>
<li>By specifying this LeastMaxValue as compile-time value, the library can decide to switch to the most efficient implementation possible</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> numThreads = <span class="hljs-number">10</span>;
std::counting_semaphore&lt;numThreads&gt; sem{<span class="hljs-number">0</span>};

sem.<span class="hljs-built_in">acquire</span>(); <span class="hljs-comment">// request thread to become one of the enabled threads</span>
sem.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// remove thread from the set of enabled threads</span>
</div></code></pre>
<p><code>std::binary_semaphore</code> is an alias for specialization of <code>std::counting_semaphore&lt;1&gt;</code> so that it can only enable or disable the use of a single resource.</p>
<ul>
<li>a more typical application is a mechanism to signal/notify a thread from another. In contrast to condition variables you can to that multiple times.</li>
</ul>
<h2 id="stdatom_ref"><code>std::atom_ref&lt;&gt;</code></h2>
<p>C++20 introduces the class template std::atomic_ref&lt;&gt; to provide trivially copyable reference types. That way you can provide a temporary atomic API to an existing object that is usually not atomic.</p>
<p>Constness is not propagated to the wrapped object. That means you can assign a new value to a const
<code>std::atomic_ref&lt;&gt;</code>:</p>
<pre><code class="language-C++"><div>MyType x, y;
<span class="hljs-keyword">const</span> std::atomic_ref cr{x};
cr = y; <span class="hljs-comment">// OK (would not be OK for const std::atomic&lt;&gt;)</span>
</div></code></pre>
<p>Note also that the different threads do not use the same <code>atomic_ref&lt;&gt;</code> objects. This is fine. <code>std::atomic_ref&lt;&gt;</code> guarantees that all concurrent access to a specific object through any <code>atomic_ref&lt;&gt;</code> created for it is synchronized.</p>
<h2 id="stdatomicstdshared_ptrt">std::atomic&lt;std::shared_ptr<T>&gt;</h2>
<p>C++11 introduced shared pointers with an optional atomic interface with functions like <code>atomic_load()</code>,
<code>atomic_store()</code>, and <code>atomic_exchange()</code>.</p>
<p>C++20 now provides partial specializations for shared pointers and weak pointers:</p>
<ul>
<li>std::atomic&lt;std::shared_ptr<T>&gt;</li>
<li>std::atomic&lt;std::weak_ptr<T>&gt;</li>
</ul>
<h2 id="atomic-floating-point-types">Atomic Floating-Point Types</h2>
<p>Both std::atomic&lt;&gt; and std::atomic_ref&lt;&gt; now provide full specializations for floating-point types <code>float</code>, <code>double</code>, and <code>long double</code>.</p>
<p>including <code>fetch_*</code> family, <code>+=</code>, <code>-=</code>, <code>|=</code>, <code>&amp;=</code>, <code>^=</code>, not <code>++</code>, <code>--</code></p>
<h2 id="stdatomic-wait-and-notify_"><code>std::atomic</code> <code>wait()</code> and <code>notify_*()</code></h2>
<p>All atomic types (<code>std::atomic&lt;&gt;</code>, <code>std::atomic_ref&lt;&gt;</code>, and <code>std::atomic_flag</code>) now provide a simple
API to let threads block and wait for changes of their values caused by other threads.</p>
<pre><code class="language-C++"><div>std::atomic&lt;<span class="hljs-keyword">int</span>&gt; aVal{<span class="hljs-number">100</span>};

<span class="hljs-comment">// Thread1: wait until the referenced value has changed:</span>
<span class="hljs-keyword">int</span> lastValue = aVal.<span class="hljs-built_in">load</span>();
<span class="hljs-comment">// If the value of the referenced object does not fit the passed argument, it immediately returns. </span>
<span class="hljs-comment">// Otherwise, it returns if the value changes AND notify_one() or notify_all() was called:</span>
aVal.<span class="hljs-built_in">wait</span>(lastValue); <span class="hljs-comment">// block unless/until value changed (and notified)</span>

<span class="hljs-comment">// Thread 2: </span>
--aVal; <span class="hljs-comment">// atomically modify the (referenced) value</span>
aVal.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// notify all threads waiting for a change</span>
</div></code></pre>
<p>Compared to mutex, atomic <code>wait()</code> and notifications maybe prefered, because using mutexes might be more expensive.</p>
<h2 id="stdosyncstream"><code>std::osyncstream</code></h2>
<p>By using synchronized output streams, we can now synchronize the concurrent output of multiple threads
to the same stream. We only have to use a <code>std::osyncstream</code> initialized with the wanted output
stream.</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;syncstream&gt;</span></span>
std::osyncstream coutSync{std::cout};
coutSync &lt;&lt; <span class="hljs-string">&quot;something to print&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
</div></code></pre>
<p>Note that neither <code>'\n'</code> nor <code>std::endl</code> now <code>std::flush</code> writes the output. If we create the synchronized output stream outside the loop, the whole output of any thread is printed
together when the destructor is reached.</p>
<p>However, there is a new manipulator to write the output before the destructor gets called: <code>std::flush_emit</code>.</p>
<p>Example: you can create and initialize the synchronized output stream and emit your output line-by-line also as follows:</p>
<pre><code class="language-C++"><div>std::osyncstream coutSync{std::cout};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num ; ++i) {
    coutSync &lt;&lt; <span class="hljs-string">&quot;something to print&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; std::flush_emit;
}
</div></code></pre>
<br>
<br>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>