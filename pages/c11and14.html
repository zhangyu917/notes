<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>C&plus;&plus;11&sol;14</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.13.24"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
#button { display: inline-block; background-color: #FF9800; width: 50px; height: 50px; text-align: center; border-radius: 4px; position: fixed; bottom: 30px; right: 30px; transition: background-color .3s, opacity .5s, visibility .5s; opacity: 0; /*visibility: hidden;*/ z-index: 1000; } #button::after { content: "\f077"; font-family: FontAwesome; font-weight: normal; font-style: normal; font-size: 2em; line-height: 50px; color: #fff; } #button:hover { cursor: pointer; background-color: #333; } #button:active { background-color: #555; } #button.show { opacity: 1; visibility: visible; } #btn-back-to-top { position: fixed; bottom: 20px; right: 20px; display: none; } .to-top { background: white; position: fixed; bottom: 16px; right:32px; width:50px; height:50px; border-radius: 50%; border-color: white; display: flex; align-items: center; justify-content: center; font-size:32px; color:#1f1f1f; text-decoration: none; opacity: 0.5; pointer-events: auto; transition: all .4s; transform: rotate(270deg); } 
</style>
    </head>
    <body class="vscode-body vscode-light">
        <!-- title: C++11/14 -->
<h1>C++11/14 Features</h1>
<p><a href="#" class="to-top">➤</i></a></p>
<ul>
<li><a href="#type-deduction">type deduction</a>
<ul>
<li><a href="#function-template-deduction">function template deduction</a></li>
<li><a href="#auto-deduction"><code>auto</code> deduction</a></li>
</ul>
</li>
<li><a href="#stdmove"><code>std::move</code></a></li>
<li><a href="#stdforward"><code>std::forward</code></a></li>
<li><a href="#forwarding-references-and-rvalue-references">Forwarding references and rvalue references</a></li>
<li><a href="#lambda">lambda</a>
<ul>
<li><a href="#generic-lambda">generic lambda</a></li>
</ul>
</li>
<li><a href="#stdinitializer_list"><code>std::initializer_list</code></a></li>
<li><a href="#noexcept"><code>noexcept</code></a></li>
<li><a href="#stdunique_ptr"><code>std::unique_ptr&lt;&gt;</code></a></li>
<li><a href="#stdshared_ptr"><code>std::shared_ptr&lt;&gt;</code></a>
<ul>
<li><a href="#stdweak_ptr"><code>std::weak_ptr</code></a></li>
</ul>
</li>
<li><a href="#stdfunction"><code>std::function</code></a></li>
<li><a href="#ref-qualifiers-on-member-functions">Ref-qualifiers on member functions</a></li>
</ul>
<h1 id="type-deduction">type deduction</h1>
<p>type deduction happens in:</p>
<ul>
<li><a href="#function-template-deduction">function template (C++98)</a></li>
<li><a href="#auto-deduction"><code>auto</code> (C++11)</a></li>
<li><a href="templates.html#decltype"><code>decltype</code> (C++11) and <code>decltype(auto)</code> (C++14)</a></li>
<li><a href="c17.html#class-template-argument-deduction-ctad">class template (C++17)</a></li>
</ul>
<h2 id="function-template-deduction">function template deduction</h2>
<p>we can think of a function template as looking like this:</p>
<p>template&lt;typename <span style="color:red"><strong>T</strong></span>&gt;
<br>void f(<span style="color:red"><em><strong>ParamType</strong></em></span> param);</p>
<p>A call can look like this:<br></p>
<p>f(<span style="color:red"><em><strong>expr</strong></em></span>); // call f with some expression</p>
<p>During compilation, compilers use <em><strong>expr</strong></em> to deduce two types: one for <strong>T</strong> and one for <em><strong>ParamType</strong></em>.</p>
<p><strong>Case 1</strong>: <em><strong>ParamType</strong></em> is a reference or pointer type.</p>
<ol>
<li>If <em><strong>expr</strong></em>’s type is a reference, ignore the reference part.</li>
<li>Then pattern-match <em><strong>expr</strong></em>’s type against <em><strong>ParamType</strong></em> to determine <strong>T</strong>.
<br>When you pass a <code>const</code> object to a reference parameter, the const-ness is preserved. The constness of the object becomes part of the type deduced for <strong>T</strong>.</li>
</ol>
<p><strong>Case 2</strong>: <em><strong>ParamType</strong></em> is a forwarding (universal) reference.</p>
<ol>
<li>If the <em><strong>expr</strong></em> is an lvalue, <strong>T</strong> is deduced as lvalue reference, the forwarding reference corresponds to an lvalue reference.</li>
<li>If the <em><strong>expr</strong></em> is an rvalue, <strong>T</strong> is deduced as non-reference, the forwarding reference corresponds to an rvalue reference.</li>
</ol>
<p>Refer to: <a href="#forwarding-references-and-rvalue-references">forwarding reference</a></p>
<p><strong>Case 3</strong>: <em><strong>ParamType</strong></em> is not a pointer/reference. Then we are dealing with pass-by-value.</p>
<ol>
<li>If <em><strong>expr</strong></em>’s type is a reference, ignore the reference part.</li>
<li>If, after ignoring <em><strong>expr</strong></em>’ reference-ness, expr is <code>const</code>/<code>volatile</code>, ignore them too.
<br>It’s important to recognize that <code>const</code> (and <code>volatile</code>) is ignored for by-value parameters.</li>
</ol>
<p>In summary:</p>
<blockquote>
<ul>
<li>argument (expression)'s reference is ignored</li>
<li>forward reference parameter differentiates lvalue and rvalue</li>
<li>by-value parameter drops <code>const</code> and <code>volatile</code></li>
</ul>
</blockquote>
<p><strong>Array arguments</strong></p>
<ul>
<li>Because functions can't declar parameters as arrays, the type of an array that’s passed to a template function <em>by value</em> is deduced (decay'ed) to be a pointer type.</li>
<li>However, function paramters can be declared as references to array. The array passed to a template function by reference is deduced just as array.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>; <span class="hljs-comment">// template with by-value parameter</span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> name[] = <span class="hljs-string">&quot;J. P. Briggs&quot;</span>; <span class="hljs-comment">// name&#x27;s type is const char[13]</span>
<span class="hljs-built_in">f</span>(name); <span class="hljs-comment">// name is char array, T deduced (decay&#x27;ed) as const char*</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>; <span class="hljs-comment">// template with by-reference parameter</span>
<span class="hljs-comment">// T is deduced as the actual type of the array! ie &quot;const char [13]&quot;,  </span>
<span class="hljs-comment">// param is deduced as a reference to this array, ie, &quot;const char (&amp;)[13]&quot;.</span>
<span class="hljs-built_in">f</span>(name); 
</div></code></pre>
<h2 id="auto-deduction"><code>auto</code> deduction</h2>
<p><em>auto type deduction</em>, with only one exception, is the same as <em>template type deduction</em>.</p>
<p>Compared to function template, When a variable is declared using <code>auto</code>, <code>auto</code> plays the role of <code>T</code> in the template, and the type specifier (<code>&amp;</code>, <code>const</code>, <code>volatile</code>) for the variable acts as <code>ParamType</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;        <span class="hljs-comment">// case 3 (x is neither ptr nor reference)</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> cx = x;  <span class="hljs-comment">// case 3 (cx isn&#x27;t either)</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; rx = x; <span class="hljs-comment">// case 1 (rx is a non-universal ref.)</span>
</div></code></pre>
<p>Same applies to array: array decays into pointers for non-reference type specifiers, and keep as array for reference type specifiers.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> name[] = <span class="hljs-string">&quot;R. N. Briggs&quot;</span>; <span class="hljs-comment">// name&#x27;s type is const char[13]</span>
<span class="hljs-keyword">auto</span> arr1 = name;   <span class="hljs-comment">// arr1&#x27;s type is const char* (decay&#x27;ed from array)</span>
<span class="hljs-keyword">auto</span>&amp; arr2 = name;  <span class="hljs-comment">// arr2&#x27;s type is const char (&amp;)[13]</span>
</div></code></pre>
<p><strong>A special type deduction rule for <code>auto</code> initialization</strong></p>
<p>When the initializer for an auto-declared variable is enclosed in braces, the deduced type is a <code>std::initializer_list&lt;&gt;</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;initializer_list&gt;</span> <span class="hljs-comment">// needed to get third line compiled</span></span>
<span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">27</span>;       <span class="hljs-comment">// type is int, value is 27</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">x2</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span></span>;        <span class="hljs-comment">// ditto</span>
<span class="hljs-keyword">auto</span> x3 = { <span class="hljs-number">27</span> };   <span class="hljs-comment">// type is std::initializer_list&lt;int&gt;,  value is { 27 }</span>
<span class="hljs-keyword">auto</span> x4{ <span class="hljs-number">27</span> };      <span class="hljs-comment">// ditto</span>
</div></code></pre>
<p>Note, passing a braced initializer to a function template parameter that’s not declared to be a <code>std::initializer_list</code> is not allowed by the standard. (thats the difference between auto and function argument deduction).</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fwd</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>{
    <span class="hljs-built_in">f</span>(std::forward&lt;T&gt;(param)); 
}
<span class="hljs-built_in">fwd</span>({ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> }); <span class="hljs-comment">// ERROR! doesn&#x27;t compile because function template deduction involved.</span>

<span class="hljs-keyword">auto</span> il = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> }; <span class="hljs-comment">// il&#x27;s type deduced to be std::initializer_list&lt;int&gt;</span>
<span class="hljs-built_in">fwd</span>(il);               <span class="hljs-comment">// fine, perfect-forwards il to f</span>
</div></code></pre>
<blockquote>
<p><code>auto</code> in a function return type or a lambda parameter implies <em>template type deduction</em>, not <em>auto type deduction</em>.</p>
</blockquote>
<br>
<br>
<h1 id="stdmove"><code>std::move</code></h1>
<p><code>std::move</code> unconditionally casts its argument to an rvalue (in particular, it produces an xvalue). It is used to indicate that an object may be &quot;moved from&quot;. Neither <code>std::move</code> nor <code>std::forward</code> do anything at runtime.</p>
<p>A pseudo <strong>implementation</strong>. In C++14, <code>std::move</code> is <code>constexpr</code>.
<a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/move.h">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/move.h</a></p>
<pre><code class="language-C++"><div><span class="hljs-comment">// C++11</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(param);
}
<span class="hljs-comment">// C++14</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;&gt;(param);
}
</div></code></pre>
<p><code>std::move</code> not only doesn’t actually move anything, it doesn’t even guarantee that the object it’s casting will be eligible to be moved. The only thing you know for sure about the result of applying <code>std::move</code> to an object is that it’s an rvalue.</p>
<p>Don’t declare objects <code>const</code> if you want to be able to move from them. Move requests on <code>const</code> objects are silently transformed into copy operations.</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotation</span> {</span>
<span class="hljs-keyword">public</span>:
   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Annotation</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string text)</span>
   : value(std::move(text)) // because text is const, even <span class="hljs-string">&quot;std::move&quot;</span> casts it to const std::string&amp;&amp;, it still matches string’s copy constructor better, ie., string(const string&amp; rhs);</span> 
   { … } 
<span class="hljs-keyword">private</span>:
    std::string value;
};
</div></code></pre>
<br>
<br>
<h1 id="stdforward"><code>std::forward</code></h1>
<p><code>std::forward</code> casts its argument to an rvalue only if that argument is bound to an rvalue.  Neither <code>std::move</code> nor <code>std::forward</code> do anything at runtime.</p>
<p><code>std::forward</code> is typically used in a function template taking a forwarding reference parameter
that is to be passed to another function:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>{
    <span class="hljs-comment">// param is an lvalue here. If the actual argument to foo was an</span>
    <span class="hljs-comment">// rvalue, pass static_cast&lt;T&amp;&amp;&gt;(param) to g; otherwise, pass param.</span>
    <span class="hljs-built_in">g</span>( std::forward&lt;T&gt;(param) );
}
<span class="hljs-built_in">foo</span>(w) <span class="hljs-comment">// call with lvalue</span>
<span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">mvoe</span>(w)) <span class="hljs-comment">// call with rvalue</span>

<span class="hljs-comment">// variadic version</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo1</span><span class="hljs-params">(Ts&amp;&amp;... params)</span> </span>{ <span class="hljs-comment">// accept any arguments</span>
    <span class="hljs-built_in">g1</span>(std::forward&lt;Ts&gt;(params)...); <span class="hljs-comment">// forward them to f</span>
}
</div></code></pre>
<p>The <strong>implementation</strong> in <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/move.h">libc++</a> uses <code>std::remove_reference</code> (overload each rvalue / lvalue instance of forward), and note that in C++14, <code>std::forward</code> is <code>constexpr</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span>
<span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; t)</span> <span class="hljs-keyword">noexcept</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;(t);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span>
<span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="hljs-keyword">noexcept</span>
</span>{
    <span class="hljs-comment">//static_assert(!std::is_lvalue_reference&lt;T&gt;::value,</span>
    <span class="hljs-comment">//              &quot;std::forward must not used to convert an rvalue as an lvalue.&quot;);</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;(t);
}
</div></code></pre>
<p>Note that <code>std::move</code> requires only a function argument, while <code>std::forward</code> requires both a function argument and a template type argument. Then note that the type we pass to <code>std::forward</code> should be a non-reference, because that’s the convention for encoding that the argument being passed is an rvalue.</p>
<br>
<br>
<h1 id="forwarding-references-and-rvalue-references">Forwarding references and rvalue references</h1>
<p><strong><code>T&amp;&amp;</code></strong> has two different meanings.</p>
<ul>
<li>One is rvalue reference, of course. Such references behave exactly the way you expect: they bind only to rvalues, and their primary raison d’être is to identify objects that may be moved from.</li>
<li>One is universal reference (by Scott) or forwarding reference. It can bind to either rvalues (like rvalue references) or lvalues (like lvalue references). Furthermore, they can bind to const or non-const objects, to volatile or non-volatile objects.</li>
</ul>
<p>forwarding references arise in two contexts, what they have in common is the presence of type deduction.</p>
<p>The most common is function template parameters, such as</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>; <span class="hljs-comment">// param is a universal reference</span>

<span class="hljs-comment">// C++14 lambda expressions may declare auto&amp;&amp; parameters</span>
<span class="hljs-keyword">auto</span> v2 = [](<span class="hljs-keyword">auto</span>&amp;&amp; x) -&gt; <span class="hljs-keyword">auto</span>&amp;&amp; { <span class="hljs-keyword">return</span> std::forward&lt;<span class="hljs-keyword">decltype</span>(x)&gt;(x); };
</div></code></pre>
<p>The second context is auto declarations, like this:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span>&amp;&amp; var2 = var1; <span class="hljs-comment">// var2 is a universal reference</span>
</div></code></pre>
<p>Because forwarding references are references, they must be initialized. The initializer (an expression) for a forwarding reference determines whether it represents an rvalue reference or an lvalue reference.</p>
<ul>
<li>If the initializer is an rvalue, the forwarding reference corresponds to an rvalue reference.</li>
<li>If the initializer is an lvalue, the forwarding reference corresponds to an lvalue reference.</li>
</ul>
<br>
<br>
<h1 id="lambda">lambda</h1>
<p><img src="images/2022-04-11-10-33-03.png" alt=""></p>
<ul>
<li>lambda type is called <strong>closure type</strong></li>
<li>myFunctor is a run-time object called a <strong>closure object</strong>.</li>
<li>Anything inside the <code>[]</code> is turned into constructor parameters and members of the closure object,</li>
<li>Parameters inside <code>()</code> are turned into parameters for the closure's <code>operator()</code>.</li>
</ul>
<p>The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type’s function call operator.</p>
<p><strong>Common lambda usage:</strong></p>
<ul>
<li>std::algorithms
<ul>
<li><code>*_if</code> (<code>find_if</code>, <code>remove_if</code>, <code>count_if</code>)</li>
</ul>
</li>
<li>Comparison functions (<code>std::sort</code>, <code>std::nth_element</code>, <code>std::lower_bound</code>)</li>
<li>Custom deleters for <code>std::unique_ptr</code>, <code>std::shared_ptr</code></li>
<li>Predicates for condition variables in the threading API</li>
<li>On-the-fly callback functions</li>
<li>Interface adaption functions</li>
<li>Context-specific functions for one-off calls</li>
</ul>
<p><strong>Difference between plain function, functors, and lambdas</strong></p>
<p>C++ lambdas and functors are more similar than they are different. A lambda expression creates an nameless functor, it's syntactic sugar. This is to be expected; the main goal of lambdas is to be a syntactically simple means of creating functions and closures.</p>
<p>lambdas and functors differ slightly from plain functions, even when no variables are being captured. To summarize the key differences:</p>
<ul>
<li>Functors and lambdas are always passed a <code>this</code> pointer, whereas plain functions naturally are not. This consumes an extra register and 8 bytes of stack space.</li>
<li>Lambda &quot;constructors&quot; are inlined into the function in which the lambda is created. This significantly reduces the amount of copying performed (2 instructions for lambdas, 5 for functors), as well as avoiding a function call setup and teardown.</li>
</ul>
<p>Overall, the costs for #1 are minor, and are probably eliminated by an optimization pass in the compiler. The costs for #2 are somewhat higher, but they are cheaper for lambdas! Again, I suspect that an optimization pass would eliminate the difference between the two.</p>
<p><strong>Does lambda allocate?</strong></p>
<p>Never.</p>
<p>Lambdas are a language feature. The compiler will create a closure object representing the function literal you write. The closure object is a value type, created as a prvalue and with automatic storage when assigned to auto (as you must, because its type is unutterable). The only way heap allocation can occur is if you by-value capture a variable whose copy constructor does heap allocation (and this isn’t a consequence of the lambda per se, as I hope you can see)</p>
<p>However, if you assign lambda to <code>std::function</code>, <code>std::function</code> could allocate.</p>
<p><strong>lambda doesn’t need to capture global or static variables</strong></p>
<p>Only objects with automatic storage duration can be captured by a lambda in C++11 (i.e. local variables and function parameters). You don't need to (and can't) capture global or static variables, they can be accessed directly.</p>
<p>&quot;To capture&quot; means to put a copy or a reference to a variable into a lambda object itself.
Global and static variables have fixed memory locations. You don't need to store copies or references to them to use them since their location is known at compile-time and doesn't change.</p>
<p><strong>Capture <code>this</code> pointer</strong></p>
<p><a href="https://www.nextptr.com/tutorial/ta1430524603/capture-this-in-lambda-expression-timeline-of-change">https://www.nextptr.com/tutorial/ta1430524603/capture-this-in-lambda-expression-timeline-of-change</a></p>
<ul>
<li><code>[this]</code> — Captures <code>this</code> by reference.</li>
<li><code>[&amp;]</code> — The reference-capture-default can implicitly capture <code>this</code> by reference.</li>
<li><code>[=]</code> — The value-capture-default can implicitly capture <code>this</code> by copy. However, the implicit capture of this through [=] is deprecated in C++20.</li>
<li><code>[*this]</code> — Captures <code>*this</code> by value. <a href="c17.html#passing-copies-of-this-to-lambdas">By-value capture of <code>this</code> object is introduced in C++17</a>.</li>
<li><code>[=, *this]</code> — Valid since C++17.</li>
<li><code>[=, this]</code> — Valid only since C++20. C++20 deprecates the implicit capture of <code>this</code> via [=] and allows the explicit capture of <code>this</code> in combination with [=].<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bagel</span> {</span>
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//OK until C++20. Warning in C++20.</span>
        [=]() { std::cout &lt;&lt; x; }();

        <span class="hljs-comment">//Error/warning until C++20. OK in C++20.</span>
        [=, <span class="hljs-keyword">this</span>]() { std::cout &lt;&lt; x; }();
    }
};
</div></code></pre>
</li>
</ul>
<p><strong>Capture class members</strong></p>
<ul>
<li>Capturing <code>this</code> pointer will automatically capture all the member variables for this object inside lambda.<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> lambda = [<span class="hljs-keyword">this</span>](){ <span class="hljs-comment">/* ... use a here... */</span> };
</div></code></pre>
</li>
<li>Use a local reference to the class member<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span>&amp; a = <span class="hljs-keyword">this</span>-&gt;a;
<span class="hljs-keyword">auto</span> lambda = [ a](){}; <span class="hljs-comment">// capture this-&gt;a by (a single) copy</span>
<span class="hljs-keyword">auto</span> lambda = [&amp;a](){}; <span class="hljs-comment">// capture this-&gt;a by ref</span>
</div></code></pre>
</li>
<li>You can use C++14's <em>init capture</em> to simplify above<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> lambda = [ a = <span class="hljs-keyword">this</span>-&gt;a](){}; <span class="hljs-comment">// capture data member by copy</span>
<span class="hljs-keyword">auto</span> lambda = [&amp;a = <span class="hljs-keyword">this</span>-&gt;a](){}; <span class="hljs-comment">// capture data member by ref</span>
</div></code></pre>
</li>
</ul>
<p><strong>init capture</strong></p>
<p>C++14 introduced lambda init capture, also called general lambda capture.</p>
<p>Using an init capture makes it possible for you to specify</p>
<ul>
<li>the name of a data member in the closure class generated from the lambda and</li>
<li>an expression initializing that data member.<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> lambda = [pw = std::<span class="hljs-built_in">move</span>(pw)]();
<span class="hljs-keyword">auto</span> lambda = [pw = std::make_unique&lt;Widget&gt;()]();
</div></code></pre>
</li>
<li>Also default capture variable values<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> lambda = [age = <span class="hljs-number">18</span>]()
</div></code></pre>
</li>
</ul>
<p><strong>Mutable lambda</strong></p>
<p>lambda’s <code>operator()</code> is <code>const</code> by-default, meaning it can’t modify the variables it captured by-value (which are analogous to class members). To change this default add <code>mutable</code>:</p>
<p><strong>Define an explicit return type</strong></p>
<p>Using alternative function syntax. Here, the return type is on the right-hand side of the function rather than the left. You can use this in regular functions, member functions on classes, and lambdas too.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> getAge = []() -&gt; <span class="hljs-keyword">int</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;
  };
</div></code></pre>
<p>A good article talking about pros/cons of alternative function return syntax
<a href="https://blog.petrzemek.net/2017/01/17/pros-and-cons-of-alternative-function-syntax-in-cpp/">https://blog.petrzemek.net/2017/01/17/pros-and-cons-of-alternative-function-syntax-in-cpp/</a></p>
<ul>
<li>Simplification of generic code where return type depends on type of parameters operations</li>
<li>Elimination of repetition in function declaration with return type depending on class</li>
</ul>
<p><strong>Prefer lambdas to <code>std::bind</code></strong></p>
<p>In C++14, there are no reasonable use cases for <code>std::bind</code>. Always prefer lambda.</p>
<p>Compared to lambdas, code using std::bind is less readable, less expressive, and possibly less efficient.</p>
<p>In C++11, however, <code>std::bind</code> can be justified in two constrained situations:</p>
<ul>
<li>Move capture. C++11 lambdas don’t offer move capture. (but resolved in C++14 with init capture list, item 32)</li>
<li>Polymorphic function objects. Because the function call operator on a bind object uses perfect forwarding. This can be useful when you want to bind an object with a templatized function call operator. (resolved in C++14 generic lambdas, item 33)</li>
</ul>
<p><strong>Capture-less lambda can decay to function pointer</strong></p>
<p>you can assign capture-less lambda to function pointer. <a href="https://cppinsights.io/lnk?code=aW50ICgqZnApKGludCwgY2hhcikgPSBbXShpbnQgYSwgY2hhciBiKSAge3JldHVybiBhICsgYjsgfSA7&amp;insightsOptions=cpp17&amp;std=cpp17&amp;rev=1.0">Cpp insights</a></p>
<pre><code class="language-C++"><div><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*fp)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>) = [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">char</span> b)  {<span class="hljs-keyword">return</span> a + b; } ;

<span class="hljs-comment">// Compiler converts above line to something like below:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_1_24</span>
{</span>
  <span class="hljs-keyword">public</span>: 
  <span class="hljs-keyword">inline</span> <span class="hljs-comment">/*constexpr */</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">char</span> b)</span> <span class="hljs-keyword">const</span>
  </span>{
    <span class="hljs-keyword">return</span> a + <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(b);
  }
  
  <span class="hljs-keyword">using</span> retType_1_24 = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>);
  <span class="hljs-keyword">inline</span> <span class="hljs-comment">/*constexpr */</span> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">retType_1_24</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> __invoke;
  }
  
  <span class="hljs-keyword">private</span>: 
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> __invoke(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">char</span> b)
  {
    <span class="hljs-keyword">return</span> a + <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(b);
  }
  
} __lambda_1_24{};

<span class="hljs-keyword">using</span> FuncPtr_1 = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>);
FuncPtr_1 fp = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>)&gt;(__lambda_1_24.<span class="hljs-keyword">operator</span> __lambda_1_24::<span class="hljs-built_in">retType_1_24</span>());
</div></code></pre>
<h2 id="generic-lambda">generic lambda</h2>
<p>C++14 introduced generic lambdas - lambdas that use auto in their parameter specifications.</p>
<p>The implementation of this feature is straightforward: <code>operator()</code> in the lambda’s closure class is a template.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> x) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(x)); };

<span class="hljs-comment">// given above lambda, the closure class’s function call operator looks like this:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeCompilerGeneratedClassName</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; 
    <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T x)</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// auto return type</span>
    </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(x)); }
    … <span class="hljs-comment">// other closure class</span>
};
</div></code></pre>
<p>Use <code>decltype</code> on <code>auto&amp;&amp;</code> parameters to <code>std::forward</code> them.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span>&amp;&amp; param) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(param)&gt;(param)));
         };

<span class="hljs-comment">// variadic version</span>
<span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span>&amp;&amp;... params) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(params)&gt;(params)...));
         };
</div></code></pre>
<br>
<br>
<h1 id="stdinitializer_list"><code>std::initializer_list</code></h1>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> &gt;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">initializer_list</span>;</span>
</div></code></pre>
<p>An object of <code>std::initializer_list&lt;T&gt;</code> is a lightweight proxy object that provides access to an array of objects of type <code>const T</code>. <code>initializer_list</code> is used to pass a list of values to a function or constructor.</p>
<p>Initializer lists is implemented as a pointer to underlying array and length. The underlying array is a <strong>temporary array</strong> of type <code>const T[N]</code>, in which each element is <em>copy-initialized</em> (ie, copy constructed) from the corresponding element of the original initializer list.  This has a couple of implications:</p>
<ul>
<li>There is more copying involved than we can see.</li>
<li><code>initializer_list</code> will not work for move-only types (like unique_ptr or unique_lock).</li>
<li>There is a temporary involved, which might get us into memory-safety issues. The array is a temporary, so as soon as the initialization ends, it gets destroyed. Binding such temporary array to an instance of <code>std::initializer_list</code> works like binding a temporary object to a reference: in some contexts it extends the life-time of the temporary target. But if you try to store it as a class member, you will get into memory management issues.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-comment">// This generates compiler error</span>
<span class="hljs-comment">// The reason is, underneath, complier first creates a temp array, then copy constructed the vector, and copy construct is not allowed for unique_ptr</span>
std::vector&lt;std::unique_ptr&lt;<span class="hljs-keyword">int</span>&gt;&gt; data{std::make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">40</span>), std::make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>) };

<span class="hljs-comment">// conceptially, compiler converts above code to this:</span>
<span class="hljs-keyword">const</span> std::unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; __a[] {std::make_unqiue&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1</span>), std::make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>)};
<span class="hljs-function">std::vector <span class="hljs-title">data</span><span class="hljs-params">(std::initializer_list&lt;std::unique_ptr&lt;<span class="hljs-keyword">int</span>&gt;&gt;(__a, __a+<span class="hljs-number">2</span>))</span></span>; <span class="hljs-comment">// not allowed</span>


<span class="hljs-comment">// This is undefined behavior, due to temp varaible lifetime issue</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-keyword">return</span> std::initializer_list&lt;<span class="hljs-keyword">int</span>&gt;{i, j, k};
}

<span class="hljs-comment">// conceptially, compiler converts above code to this:</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> __a[] {i, j, k};
    <span class="hljs-keyword">return</span> std::initializer_list&lt;<span class="hljs-keyword">int</span>&gt;{__a, __a+<span class="hljs-number">3</span>}; <span class="hljs-comment">// return pointer to local variable!!!</span>
}
</div></code></pre>
<br>
<br>
<h1 id="noexcept"><code>noexcept</code></h1>
<p>With <code>noexcept</code> declaration:</p>
<ul>
<li>It turns an exception throw into a call to std::terminate().</li>
<li>One can make a compile-time query if the function has been declared as <code>noexcept</code>.</li>
</ul>
<p><strong>Why noexcept was introduced?</strong></p>
<p>The <code>noexcept</code> feature was introduced very late into C++11 to address one particular issue with move semantics. In short, for certain functions, like <code>vector&lt;T&gt;::push_back</code> using move constructors/assignments of <code>T</code> instead of copy constructors/assignments can dramatically increase performance. However, if this move constructor/assignment can potentially throw, <code>push_back</code> would loose the strong exception safety guarantee. Thus, there needs to be a way to determine if a given <code>move</code> operation is potentially throwing or not, and use it or alternatively fall back to good old copying. Another example is, <code>std::vector</code> will copy all elements when reallocating instead of moving them if the <code>move</code> constructor is not <code>noexcept</code> to preserve the strong exception guarantee.</p>
<br>
<br>
<h1 id="stdunique_ptr"><code>std::unique_ptr&lt;&gt;</code></h1>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Deleter</span> =</span> std::default_delete&lt;T&gt;&gt; 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unique_ptr</span>;</span>
</div></code></pre>
<p>By default, that destruction would take place via <code>delete</code>, but, during construction,
<code>std::unique_ptr</code> objects can be configured to use custom deleters</p>
<ul>
<li>Specify the custom deleter's type as the second type argument to <code>std::unique_ptr</code>.</li>
<li>Pass the deleter object as <code>std::unique_ptr</code>'s second constructor parameter.</li>
</ul>
<pre><code class="language-C++"><div> <span class="hljs-comment">// custom deleter using stateless (capture-less) lambda </span>
<span class="hljs-keyword">auto</span> delInvmt = [](Investment* pInvestment) { <span class="hljs-comment">// takes a raw pointer to object</span>
    <span class="hljs-built_in">makeLogEntry</span>(pInvestment); 
    <span class="hljs-keyword">delete</span> pInvestment; 
};
<span class="hljs-function">std::unique_ptr&lt;Investment, <span class="hljs-title">decltype</span><span class="hljs-params">(delInvmt)</span>&gt; <span class="hljs-title">pInv</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>, delInvmt)</span></span>;
</div></code></pre>
<p><strong>Size of unique_ptr</strong></p>
<ul>
<li>when using the default deleter (i.e., <code>delete</code>), <code>std::unique_ptr</code> objects are the same size as raw pointers.
<ul>
<li>The reason is that the <code>typename Deleter = default_delete&lt;T&gt;</code> is an empty class and unique_ptr employs <em>empty base class optimization</em>.</li>
</ul>
</li>
<li><strong>Delaters that are lambdas with no captures incur no size penalty</strong>.</li>
<li>Deleters that are function pointers generally cause the size of a std::unique_ptr to increase by the size of function pointer.</li>
<li>For deleters that are function objects with states (including lambda with captures), the change in size depends on how much state is stored in the function object.</li>
</ul>
<br>
<br>
<h1 id="stdshared_ptr"><code>std::shared_ptr&lt;&gt;</code></h1>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> &gt;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shared_ptr</span>;</span>
</div></code></pre>
<ul>
<li>custom deleter is not part of the type, it is passed in as second constructor parameter.
<ul>
<li>shared_ptr objects of same type can have different deleter</li>
</ul>
</li>
<li>specifying a custom deleter doesn’t change the size of a <code>std::shared_ptr</code> object.</li>
<li>Regardless of deleter, a <code>std::shared_ptr</code> object is two pointers in size.</li>
</ul>
<p><img src="images/2022-04-11-22-04-08.png" alt=""></p>
<p>Performance implications:</p>
<ul>
<li><code>std::shared_ptr</code> is twice the size of a raw pointer</li>
<li>Memory for the reference count must be dynamically allocated.</li>
<li>Increments and decrements of the reference count must be atomic</li>
<li>The virtual function machinery in the control block is generally used only once per object managed by the <code>std::shared_ptr</code>: when the object is destroyed.</li>
</ul>
<p>Control block is created when:</p>
<ul>
<li><code>std::make_shared</code> always creates a control block.</li>
<li>when a <code>std::shared_ptr</code> is constructed from a unique_ptr.</li>
<li>When a <code>std::shared_ptr</code> constructor is called with a raw pointer, it creates a control block.</li>
</ul>
<p><strong><code>std::enable_shared_from_this</code></strong></p>
<p>It is bad to construct shared_ptr from same raw pointer multiple times, this problem is particularly easy to happen for <code>this</code> pointer, so we have <code>std::enable_shared_from_this</code></p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span> <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// factory function that perfect-forwards args to a private ctor</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;
    <span class="hljs-keyword">static</span> std::shared_ptr&lt;Widget&gt; <span class="hljs-title">create</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// shared_from_this() needs to have an existing control block, otherwise it will throw exception</span>
        <span class="hljs-comment">// normally people create shared_ptr via factory function to a private constructor </span>
        processedWidgets.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">shared_from_this</span>());
    }
<span class="hljs-keyword">private</span>: 
    ... <span class="hljs-comment">// ctors</span>
};
</div></code></pre>
<p>To prevent clients from calling member functions that invoke <code>shared_from_this</code>
before a <code>std::shared_ptr</code> points to the object, classes inheriting from
<code>std::enable_shared_from_this</code> often declare their constructors private and
have clients create objects by calling factory functions that return <code>std::shared_ptr</code>s.</p>
<p><strong>Prefer <code>std::make_shared</code> and <code>std::make_unqiue</code></strong></p>
<ol>
<li>
<p>Exception safety</p>
<pre><code class="language-C++"><div><span class="hljs-comment">//  potential resource leak</span>
<span class="hljs-comment">// 1. Perform “new Widget”.</span>
<span class="hljs-comment">// 2. Execute computePriority. → if this throws, the widget generated in step1 is leaked</span>
<span class="hljs-comment">// 3. Run std::shared_ptr constructor.</span>
<span class="hljs-built_in">processWidget</span>(std::shared_ptr&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">computePriority</span>()); 

<span class="hljs-comment">// instead, this has no potential resource leak</span>
<span class="hljs-built_in">processWidget</span>(std::make_shared&lt;Widget&gt;(), <span class="hljs-built_in">computePriority</span>()); 
</div></code></pre>
</li>
<li>
<p><code>std::make_shared</code> allocates a single chunk of memory to hold both the Widget object and the control block. This optimization:</p>
<ul>
<li>it increases the speed of the executable code, because memory is allocated only once.</li>
<li>reduces the static size of the program, because the code contains only one memory allocation call</li>
<li>Furthermore, using <code>std::make_shared</code> obviates the need for some of the bookkeeping information in the control block, potentially reducing the total memory footprint for the program.</li>
</ul>
</li>
</ol>
<p>Limitations:</p>
<ol>
<li>
<p>No way to pass in custom deleter.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">auto</span> widgetDeleter = [](Widget* pw) { … };
<span class="hljs-function">std::unique_ptr&lt;Widget, <span class="hljs-title">decltype</span><span class="hljs-params">(widgetDeleter)</span>&gt; <span class="hljs-title">upw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, widgetDeleter)</span></span>;
<span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, widgetDeleter)</span></span>;
</div></code></pre>
</li>
<li>
<p><code>make_*</code> doesn't work with braced initializers.</p>
<p>Braced initializers can’t be perfect-forwarded. Within the make functions, the perfect forwarding code uses parentheses, not braces.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// Create std::vectors with 10 elements, each of value 20</span>
<span class="hljs-keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); 

<span class="hljs-comment">// Workaround is use auto to create a std::initializer_list object from a braced initializer, then pass it to make_* function</span>
<span class="hljs-keyword">auto</span> initList = { <span class="hljs-number">10</span>, <span class="hljs-number">20</span> };
<span class="hljs-comment">// create std::vector using std::initializer_list ctor, std::vector with two elements, 10 and 20.</span>
<span class="hljs-keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(initList);
</div></code></pre>
</li>
<li>
<p>In the case where an object has its own <code>operator new</code> and <code>operator delete</code>, it doesn’t fit well with <code>make_shared</code> because the amount of memory that <code>std::make_shared</code> requests isn’t the size of the dynamically allocated object, it’s the size of that object plus the size of a control block.</p>
</li>
<li>
<p>Memory issue when <code>weak_ptr</code> outlives shared_ptr for long time.</p>
<p>When using <code>std::make_shared</code>, <code>std::shared_ptr</code>’s control block being placed in the same chunk of memory as the managed object. When that object’s reference count goes to zero, the object is destroyed (i.e., its destructor is called). However, the memory it occupies can’t be released until the control block has also been destroyed, because the same chunk of dynamically allocated memory contains both.</p>
<p>As long as std::weak_ptrs refer to a control block (i.e., the weak count is greater than zero), that control block must continue to exist. And as long as a control block exists, the memory containing it must remain allocated. The memory allocated by a <code>std::make_shared</code>, then, can’t be deallocated until the last <code>std::shared_ptr</code> and the last <code>std::weak_ptr</code> referring to it have been destroyed.</p>
</li>
</ol>
<p><strong>shared_ptr aliasing constructor</strong></p>
<p><a href="https://www.justsoftwaresolutions.co.uk/cplusplus/shared-ptr-secret-constructor.html">https://www.justsoftwaresolutions.co.uk/cplusplus/shared-ptr-secret-constructor.html</a></p>
<p>The aliasing constructor signature looks like this:</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Other,<span class="hljs-keyword">typename</span> Target&gt;
<span class="hljs-title">shared_ptr</span><span class="hljs-params">(shared_ptr&lt;Other&gt; <span class="hljs-keyword">const</span>&amp; other, Target* p)</span></span>;
</div></code></pre>
<p>if you're constructing a <code>shared_ptr&lt;T&gt;</code> then the pointer <code>p</code> must be convertible to a <code>T*</code>,
but there's no restriction on the type of <code>Other</code> at all. The newly constructed object shares ownership with <code>other</code>, so <code>other.use_count()</code> is increased by 1, and the value returned by <code>get()</code> on the new object is <code>static_cast&lt;T*&gt;(p)</code>.</p>
<p>Usage: It allows you to pass out sub-object of a <code>shared_ptr</code> object and keep the parent <code>shared_ptr</code> alive.</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span>{</span>
    Y y;
};
<span class="hljs-function">std::shared_ptr&lt;X&gt; <span class="hljs-title">px</span><span class="hljs-params">(std::make_shared&lt;X&gt;())</span></span>;
<span class="hljs-function">std::shared_ptr&lt;Y&gt; <span class="hljs-title">py</span><span class="hljs-params">(px, &amp;px-&gt;y)</span></span>; <span class="hljs-comment">// Now our shared_ptr&lt;Y&gt; keeps our X object alive, so the pointer it holds is still valid.</span>
</div></code></pre>
<p>This could be used for classes that use the pimpl idiom, or trees where you want to be able to pass round pointers to the child nodes, but keep the whole tree alive. Or, you could use it to keep a shared library alive as long as a pointer to a variable stored in that library was being used. If our class X loads the shared library in its constructor and unloads it in the destructor, then we can pass round <code>shared_ptr&lt;Y&gt;</code> objects that share ownership with our <code>shared_ptr&lt;X&gt;</code> object to keep the shared library from being unloaded until all the <code>shared_ptr&lt;Y&gt;</code> objects have been destroyed or reset.</p>
<p>The details</p>
<h2 id="stdweak_ptr"><code>std::weak_ptr</code></h2>
<p><code>std::weak_ptr&lt;T&gt;</code> operations</p>
<ul>
<li>Create a <code>std::weak_ptr</code> from <code>shared_ptr</code></li>
<li><code>expire()</code>: Check if <code>std::weak_ptr</code> is dangled
<ul>
<li>But you can’t use it, because <code>std::weak_ptr</code> doesn’t have dereference operator</li>
</ul>
</li>
<li>Two ways to check to see if a std::<code>std::weak_ptr</code> has expired and, if it hasn’t (i.e., if it’s not dangling), to access the object it points to.
<ul>
<li><code>lock()</code>: Check if <code>std::weak_ptr</code> is dangled and create a <code>shared_ptr</code> to use the pointer,  return null if <code>std::weak_ptr</code> is expired<pre><code class="language-C++"><div>std::shared_ptr&lt;Widget&gt; spw1 = wpw.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">// if wpw&#x27;s expired, spw1 is null</span>
<span class="hljs-keyword">auto</span> spw2 = wpw.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">// same as above, but uses auto</span>
</div></code></pre>
</li>
<li><code>shared_ptr</code> constructor takinga a <code>std::weak_ptr</code>, if <code>std::weak_ptr</code> is expired, an exception is thrown.<pre><code class="language-C++"><div><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw3</span><span class="hljs-params">(wpw)</span></span>; <span class="hljs-comment">// if wpw&#x27;s expired, throw std::bad_`std::weak_ptr`</span>
</div></code></pre>
</li>
</ul>
</li>
</ul>
<p><strong><code>std::weak_ptr</code> use cases</strong></p>
<ol>
<li>
<p>A cache implementation, where the cache keeps <code>std::weak_ptr&lt;T&gt;</code>, and can detect items expired/dangled</p>
<pre><code class="language-C++"><div><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">const</span> Widget&gt; <span class="hljs-title">fastLoadWidget</span><span class="hljs-params">(WidgetID id)</span> </span>{
    <span class="hljs-keyword">static</span> std::unordered_map&lt;WidgetID, std::weak_ptr&lt;<span class="hljs-keyword">const</span> Widget&gt;&gt; cache;

    <span class="hljs-comment">// objPtr is std::shared_ptr to cached object (or nullif object&#x27;s not in cache)</span>
    <span class="hljs-keyword">auto</span> objPtr = cache[id].<span class="hljs-built_in">lock</span>(); 

    <span class="hljs-comment">// if not in cache, load it and cache it (by creating a weak_ptr)</span>
    <span class="hljs-keyword">if</span> (!objPtr) { 
        objPtr = <span class="hljs-built_in">loadWidget</span>(id); 
        cache[id] = objPtr; <span class="hljs-comment">// cache it</span>
    }
    <span class="hljs-keyword">return</span> objPtr;
}
</div></code></pre>
</li>
<li>
<p>Observer pattern, where the main object has a list of listeners. The main object has no interest in managing the life cycle of listeners, but doesn’t want to access expired/dangled listeners, so it keeps an array of <code>std::weak_ptr&lt;T&gt;</code> of listeners.</p>
</li>
<li>
<p>Avoid <code>shared_ptr</code> cycles</p>
<p><img src="images/2022-04-12-13-17-27.png" alt=""></p>
<p>Back pointer from B -&gt; A, here <code>std::weak_ptr</code> is most appropriate.</p>
<ul>
<li>If use raw pointer, if A is gone, B can have dangle ptr to A</li>
<li>If use <code>shared_ptr</code>, A and B will never to be deleted.</li>
</ul>
</li>
</ol>
<br>
<br>
<h1 id="stdfunction"><code>std::function</code></h1>
<p><code>std::function</code> is just another example of type-erasure.</p>
<p><a href="https://blog.demofox.org/2015/02/25/avoiding-the-performance-hazzards-of-stdfunction/">https://blog.demofox.org/2015/02/25/avoiding-the-performance-hazzards-of-stdfunction/</a></p>
<p>There are two performance implications of using <code>std::function</code> that might surprise you:</p>
<ul>
<li>When calling a <code>std::function</code>, it does a virtual function call.</li>
<li>When assigning a lambda with significant captures to a <code>std::function</code>, it will do a dynamic memory allocation!</li>
</ul>
<p>The reason for the virtual function call is because under the hood, a lambda creates a class that contains the code and all the captured data you specified for capture. Since other callers of your <code>std::function</code> have no idea what the type of that object is (it’s only visible in the scope the lambda was defined in, and is not a human friendly name), the <code>std::function</code> has to use a virtual function to “blindly” call into from the outside, to perform the correct work on the inside. This technique is called “type erasure”.</p>
<p>The reason for the dynamic memory allocation is that <code>std::function</code> is generic and has no idea how much data you captured, but that captured data has to exist inside of a <code>std::function</code> and also has to be able to be copied as a <code>std::function</code> is moved around or copied to other locations. It needs the storage space for your captures.</p>
<p>On clang++ the size of all <code>std::function</code>s (regardless of return value or parameters) is always 32 bytes. It uses what is called small size optimization, much like <code>std::string</code> does on many implementations. This basically means that for small objects <code>std::function</code> can keep them as part of its memory, but for bigger objects it defers to dynamic memory allocation. In clang case, once the capture list size is larger than 16 byte, it will do dynamic allocation.</p>
<p>One way to work around <code>std::function</code> is - don’t use it, use template parameter to pass around lambdas.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RunLambda</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;lambda)</span>
</span>{
  <span class="hljs-comment">// No virtual function calls or dynamic memory allocations!</span>
  <span class="hljs-built_in">lambda</span>();
}
</div></code></pre>
<p><strong><code>std::function</code> implementation</strong></p>
<p>Good article of <code>std::function</code> impl: <a href="https://shaharmike.com/cpp/naive-std-function/">https://shaharmike.com/cpp/naive-std-function/</a></p>
<p>First, definition: <code>std::function</code> is a template specialization with a function type</p>
<pre><code class="language-C++"><div>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt;
	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">function</span>;</span> <span class="hljs-comment">// no definition</span>

	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ... Args&gt;
	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">function</span>&lt;</span><span class="hljs-built_in">R</span>(Args...)&gt; {
		<span class="hljs-comment">// ...</span>
	};
</div></code></pre>
<p><code>&lt;R(Args...)&gt;</code> is a template specialization on a function type</p>
<p>The difference between <code>&lt;Result (Arg0, Arg1)&gt;</code> and <code>&lt;Result, Arg0, Arg1&gt;</code> is the former is a single type (that of a function), with nested types in it, while the latter is 3 separate types.</p>
<p>Functions in C++ has a type. So, for a function like <code>int foo(double, char)</code>, its type is <code>int(double, char)</code>. What your specialization does is allow you to pass a function type to the template and it will deduce the parameters from that, instead of having you specify them yourself.</p>
<p>An simplified implementation (<a href="c17.html#stdany-implementation">almost same as <code>std::any</code> type erasure implementation</a>):</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">naive_function</span>;</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ReturnValue, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">naive_function</span>&lt;</span><span class="hljs-built_in">ReturnValue</span>(Args...)&gt; {
<span class="hljs-keyword">public</span>:
	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
	naive_function&amp; <span class="hljs-keyword">operator</span>=(T t) {
		callable_ = std::make_unique&lt;CallableT&lt;T&gt;&gt;(t);
		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
	}

	<span class="hljs-function">ReturnValue <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Args... args)</span> <span class="hljs-keyword">const</span> </span>{
		<span class="hljs-built_in">assert</span>(callable_);
		<span class="hljs-keyword">return</span> callable_-&gt;<span class="hljs-built_in">Invoke</span>(args...);
	}

<span class="hljs-keyword">private</span>:
	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ICallable</span> {</span>
	<span class="hljs-keyword">public</span>:
		<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ICallable</span>() = <span class="hljs-keyword">default</span>;
		<span class="hljs-function"><span class="hljs-keyword">virtual</span> ReturnValue <span class="hljs-title">Invoke</span><span class="hljs-params">(Args...)</span> </span>= <span class="hljs-number">0</span>;
	};

	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableT</span> :</span> <span class="hljs-keyword">public</span> ICallable {
	<span class="hljs-keyword">public</span>:
		<span class="hljs-built_in">CallableT</span>(<span class="hljs-keyword">const</span> T&amp; t)
			: <span class="hljs-built_in">t_</span>(t) {
		}

		~<span class="hljs-built_in">CallableT</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;

		<span class="hljs-function">ReturnValue <span class="hljs-title">Invoke</span><span class="hljs-params">(Args... args)</span> <span class="hljs-keyword">override</span> </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">t_</span>(args...);
		}

	<span class="hljs-keyword">private</span>:
		T t_;
	};

	std::unique_ptr&lt;ICallable&gt; callable_;
};
</div></code></pre>
<br>
<br>
<h1 id="ref-qualifiers-on-member-functions">Ref-qualifiers on member functions</h1>
<p>The original proposal that describes it is <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm">N2439</a>.</p>
<p>Think of each (non-static) member function as a free function with one additional special parameter in front: the implied <code>*this</code> object. Then these references apply to this implied parameter.</p>
<p>In other words, it indicates a member function is invoked on a temporary/const object.</p>
<p>Note that you can combine the cv-qualifiers (<code>const</code> and <code>volatile</code>) and ref-qualifiers (<code>&amp;</code> and <code>&amp;&amp;</code>).</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">optional</span> {</span>
  <span class="hljs-function">T&amp;       <span class="hljs-title">value</span><span class="hljs-params">()</span> &amp;</span>;
  <span class="hljs-function">T&amp;&amp;      <span class="hljs-title">value</span><span class="hljs-params">()</span> &amp;&amp;</span>;
  <span class="hljs-function">T <span class="hljs-keyword">const</span>&amp; <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>&amp;</span>;
};
</div></code></pre>
<p>Simple usage</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span>{</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> &amp;</span>{ std::cout &lt;&lt; <span class="hljs-string">&quot;lvalue object\n&quot;</span>; }
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> &amp;&amp;</span>{ std::cout &lt;&lt; <span class="hljs-string">&quot;rvalue object\n&quot;</span>; }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
  test t;
  t.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// lvalue</span>
  <span class="hljs-built_in">test</span>().<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// rvalue</span>
}
</div></code></pre>
<p>One usage of this is to prevent accidentally wrong code like this</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span> {</span>
    X&amp; <span class="hljs-keyword">operator</span>=(X x&amp;) &amp; = <span class="hljs-keyword">default</span>;
};

X x{};
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">X</span>() = x) {...} <span class="hljs-comment">// This won&#x27;t compile with l-ref-qualifier</span>
</div></code></pre>
<br>
<br>

        
        
    </body>
    </html>