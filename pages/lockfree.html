<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Publishing protocol</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.13.24"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
#button { display: inline-block; background-color: #FF9800; width: 50px; height: 50px; text-align: center; border-radius: 4px; position: fixed; bottom: 30px; right: 30px; transition: background-color .3s, opacity .5s, visibility .5s; opacity: 0; /*visibility: hidden;*/ z-index: 1000; } #button::after { content: "\f077"; font-family: FontAwesome; font-weight: normal; font-style: normal; font-size: 2em; line-height: 50px; color: #fff; } #button:hover { cursor: pointer; background-color: #333; } #button:active { background-color: #555; } #button.show { opacity: 1; visibility: visible; } #btn-back-to-top { position: fixed; bottom: 20px; right: 20px; display: none; } .to-top { background: white; position: fixed; bottom: 16px; right:32px; width:50px; height:50px; border-radius: 50%; border-color: white; display: flex; align-items: center; justify-content: center; font-size:32px; color:#1f1f1f; text-decoration: none; opacity: 0.5; pointer-events: auto; transition: all .4s; transform: rotate(270deg); } 
</style>
    </head>
    <body class="vscode-body vscode-light">
        <ul>
<li><a href="#publishing-protocol">Publishing protocol</a>
<ul>
<li><a href="#publishing-unique-pointer">Publishing unique pointer</a></li>
<li><a href="#publishing-shared-pointers">Publishing shared pointers</a></li>
</ul>
</li>
<li><a href="#rcu">RCU</a></li>
<li><a href="#thread-safe-stack">Thread-safe stack</a>
<ul>
<li><a href="#design-thread-safe-interface">Design thread-safe interface.</a></li>
<li><a href="#design-lock-free-stack">Design lock-free stack</a></li>
</ul>
</li>
<li><a href="#thread-safe-queue">Thread-safe queue</a>
<ul>
<li><a href="#one-producer-one-consumer-queue-implementation-1">One producer one consumer queue (implementation 1)</a></li>
<li><a href="#one-producer-one-consumer-queue-implementation-2">One producer one consumer queue (implementation 2)</a></li>
<li><a href="#non-sequentially-consistent-queue">Non-sequentially consistent queue</a></li>
<li><a href="#handle-the-out-of-memory-case">Handle the out-of-memory case</a></li>
</ul>
</li>
<li><a href="#thread-safe-list">Thread-safe list</a></li>
</ul>
<h1 id="publishing-protocol">Publishing protocol</h1>
<p>It allows the producer thread to publish information for other threads to consume in a way that guarantees no data races.
It can be implemented using any handle that gives access to the memory as long as this handle can be changed atomically. Pointers are the most common handle, of course, followed by array indices.</p>
<ul>
<li>When the producer wants to publish the data, it sets the root pointer to the correct address atomically and with a release barrier. After the data is published, the producer cannot change it (neither can anyone else).</li>
<li>The consumer threads must read the root pointer atomically and with an acquire barrier. If they read a non-null value, they can read the data accessible through the root pointer.</li>
</ul>
<h2 id="publishing-unique-pointer">Publishing unique pointer</h2>
<p>the key functions are publish() and get(), and they implement the publishing protocol.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ts_unique_ptr</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ts_unique_ptr</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ts_unique_ptr</span><span class="hljs-params">(T* p)</span> : p_(p) {</span>}
    <span class="hljs-built_in">ts_unique_ptr</span>(<span class="hljs-keyword">const</span> ts_unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;
    ts_unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ts_unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;
    ~<span class="hljs-built_in">ts_unique_ptr</span>() {
        <span class="hljs-keyword">delete</span> p_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(T* p)</span> <span class="hljs-keyword">noexcept</span> </span>{
        p_.<span class="hljs-built_in">store</span>(p, std::memory_order_release);
    }
    <span class="hljs-function"><span class="hljs-keyword">const</span> T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> p_.<span class="hljs-built_in">load</span>(std::memory_order_acquire);
    }
    <span class="hljs-keyword">const</span> T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get</span>(); }
        ts_unique_ptr&amp; <span class="hljs-keyword">operator</span>=(T* p) <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">publish</span>(p); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
<span class="hljs-keyword">private</span>:
    std::atomic&lt;T*&gt; p_ { <span class="hljs-literal">nullptr</span> };
};
</div></code></pre>
<h2 id="publishing-shared-pointers">Publishing shared pointers</h2>
<p><code>std::shared_ptr</code> guarantees that it is thread-safe for different threads to operate on different shared_ptr instances that point to the same underlying object. But it doesn’t guarantee that two threads access the same shared pointer.</p>
<p>We need the operations on the shared pointer itself to be atomic.</p>
<ul>
<li>In C++20, we can do just that: it lets us write <code>std::atomic&lt;std::shared_ ptr&lt;T&gt;&gt;</code>.</li>
<li>Before C++20, we can use <code>std::atomic_store_explicit/atomic_load_explicit</code></li>
</ul>
<pre><code class="language-C++"><div>std::shared_ptr&lt;T&gt; p_;
T* data = <span class="hljs-keyword">new</span> T;
… finish initializing the data …
std::<span class="hljs-built_in">atomic_store_explicit</span>(
    &amp;p_, std::shared_ptr&lt;T&gt;(data), std::memory_order_release);

std::shared_ptr&lt;T&gt; p_;
<span class="hljs-keyword">const</span> T* data = std::<span class="hljs-built_in">atomic_load_explicit</span>(
    &amp;p_, std::memory_order_acquire).<span class="hljs-built_in">get</span>();
</div></code></pre>
<br>
<br>
<h1 id="rcu">RCU</h1>
<p>RCU stands for &quot;Read, Copy, Update&quot;. It can be seen as a publishing protocol.</p>
<ul>
<li>Data is accessible via &quot;root pointer&quot; (can be a pointer, or an index into an array, or even a size variable), must be atomic</li>
<li>Reader: acquire &quot;root pointer&quot; atomically, access data</li>
<li>Write: read current data, copy to new data, update new data, and publish it</li>
<li>Some readers see old data, other readers see new data.</li>
</ul>
<br>
<br>
<h1 id="thread-safe-stack">Thread-safe stack</h1>
<p>One of the simplest data structures is stack because stack deals with the top element only.</p>
<h2 id="design-thread-safe-interface">Design thread-safe interface.</h2>
<p>std::stack has empty(), pop() and top(), they can’t be used together for multi-threaded program.</p>
<p>the entire pop operation should be a single member function: it should remove the top element from the stack and return it to the caller.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mt_stack</span> {</span>
    std::stack&lt;T&gt; s_;
    std::mutex l_;
    <span class="hljs-keyword">public</span>:
    <span class="hljs-function">std::optional&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">std::lock_guard <span class="hljs-title">g</span><span class="hljs-params">(l_)</span></span>;
        <span class="hljs-keyword">if</span> (s_.<span class="hljs-built_in">empty</span>()) {
            <span class="hljs-keyword">return</span> std::optional&lt;T&gt;(std::nullopt);
        } <span class="hljs-keyword">else</span> {
            std::optional&lt;T&gt; <span class="hljs-built_in">res</span>(std::<span class="hljs-built_in">move</span>(s_.<span class="hljs-built_in">top</span>()));
            s_.<span class="hljs-built_in">pop</span>();
            <span class="hljs-keyword">return</span> res;
        }
    }
};
</div></code></pre>
<p>For top(), it seems we can use the read-write lock to improve the performance of regular mutex lock.
In C++, the terminology is different (but the functionality is exactly the same):</p>
<ul>
<li>the reader threads use the shared lock (any number of shared locks on the same mutex can exist at the same time),</li>
<li>the writer threads need the unique lock (only one such lock can exist on a given mutex).</li>
</ul>
<p><strong>But the benchmark result proves it wrong. Read-write lock is worse in performance.</strong></p>
<ul>
<li>the more complex locks, such as the shared mutex, will have more overhead than the simple locks.</li>
<li>Read-write lock target use case: the critical section itself took much longer (say, milliseconds instead of microseconds) and most threads executed read-only code</li>
</ul>
<h2 id="design-lock-free-stack">Design lock-free stack</h2>
<p>First, we have to figure out what atomic variables are needed.</p>
<ul>
<li>For the producer threads, we need the index of the first free slot in the array.</li>
<li>For the consumer threads, we need the index of the last fully constructed element.</li>
</ul>
<p><img src="images/2022-01-24-16-20-54.png" alt=""></p>
<p>Assumption:</p>
<ul>
<li>Neither push nor pop can proceed if the two indices are currently not equal
<ul>
<li>different counts imply that either a new element is being constructed or the urrent top element is being copied out.</li>
<li>Any stack modification in this state may lead to the creation of holes in the array.</li>
</ul>
</li>
</ul>
<p>how to manipulate and check both counts atomically</p>
<ul>
<li>pack both values into a single 64-bit word</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mt_stack</span> {</span>
    std::deque&lt;T&gt; s_;
    <span class="hljs-keyword">int</span> cap_ = <span class="hljs-number">0</span>;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">counts_t</span> {</span>
        <span class="hljs-keyword">int</span> p_ = <span class="hljs-number">0</span>; <span class="hljs-comment">// Producer index</span>
        <span class="hljs-keyword">int</span> c_ = <span class="hljs-number">0</span>; <span class="hljs-comment">// Consumer index</span>
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(std::atomic&lt;<span class="hljs-keyword">counts_t</span>&gt;&amp; n)</span> </span>{
            <span class="hljs-keyword">if</span> (p_ == c_) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            *<span class="hljs-keyword">this</span> = n.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    };
    <span class="hljs-keyword">mutable</span> std::atomic&lt;<span class="hljs-keyword">counts_t</span>&gt; n_;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">mt_stack</span>(<span class="hljs-keyword">size_t</span> n = <span class="hljs-number">100000000</span>) : <span class="hljs-built_in">s_</span>(n), <span class="hljs-built_in">cap_</span>(n) {}
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; v)</span></span>;
    <span class="hljs-function">std::optional&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;
};
</div></code></pre>
<p>The method equal() returns true if the two indices are equal; otherwise, it updates the stored index values from the specified atomic variable. This follows the CAS pattern we have seen earlier: if the desired condition is not met, read the atomic variable again.</p>
<p>To <strong>push()</strong>:</p>
<ul>
<li>First, atomically increment the producer index p_ (bounded by the current capacity of the array).</li>
<li>Then construct the new element in the slot we just reserved (indexed by the old value of p_)</li>
<li>Then we increment the consumer index c_ to indicate that the new element is available to the consumer threads.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; v)</span> </span>{
    <span class="hljs-keyword">counts_t</span> n = n_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
    <span class="hljs-keyword">if</span> (n.p_ == cap_) <span class="hljs-built_in">abort</span>();
    <span class="hljs-keyword">while</span> (!n.<span class="hljs-built_in">equal</span>(n_) ||
        !n_.<span class="hljs-built_in">compare_exchange_weak</span>(n, {n.p_ + <span class="hljs-number">1</span>, n.c_},
            std::memory_order_acquire,
            std::memory_order_relaxed)) {
        <span class="hljs-keyword">if</span> (n.p_ == cap_) { … allocate more memory … }
    };
    ++n.p_;
    <span class="hljs-keyword">new</span> (&amp;s_[n.p_]) <span class="hljs-built_in">T</span>(v);
    <span class="hljs-built_in">assert</span>(n_.<span class="hljs-built_in">compare_exchange_strong</span>(n, {n.p_, n.c_ + <span class="hljs-number">1</span>},
        std::memory_order_release, std::memory_order_relaxed);
}
</div></code></pre>
<p>The last CAS operation should never fail unless there is a bug in our code: once the calling thread successfully advanced p_, no other thread can change either value until the same thread advanced c_ to match.</p>
<p>To <strong>pop()</strong>:</p>
<ul>
<li>first, decrement the consumer index c_ to reserve the top slot</li>
<li>object is copied or moved from the stack.</li>
<li>then decrement p_</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-function">std::optional&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">counts_t</span> n = n_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
    <span class="hljs-keyword">if</span> (n.c_ == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> std::optional&lt;T&gt;(std::nullopt);
    <span class="hljs-keyword">while</span> (!n.<span class="hljs-built_in">equal</span>(n_) ||
        !n_.<span class="hljs-built_in">compare_exchange_weak</span>(n, {n.p_, n.c_ - <span class="hljs-number">1</span>},
            std::memory_order_acquire,
            std::memory_order_relaxed)) {
        <span class="hljs-keyword">if</span> (n.c_ == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> std::optional&lt;T&gt;(std::nullopt);
    };
    --n.cc_;
    <span class="hljs-function">std::optional&lt;T&gt; <span class="hljs-title">res</span><span class="hljs-params">(std::move(s_[n.p_]))</span></span>;
    s_[n.pc_].~<span class="hljs-built_in">T</span>();
    <span class="hljs-built_in">assert</span>(n_.<span class="hljs-built_in">compare_exchange_strong</span>(n, {n.p_ - <span class="hljs-number">1</span>, n.c_},
        std::memory_order_release, std::memory_order_relaxed));
    <span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<br>
<h1 id="thread-safe-queue">Thread-safe queue</h1>
<p>Whenever we have the case that there are several different ways to access the data structure and they (mostly) do not interact with each other, the general suggestion:</p>
<ul>
<li>First, consider the scenario where these roles are assigned to different threads.</li>
<li>Start with the case of one thread of each kind.</li>
<li>In the queue’s case, it means one producer thread and one consumer thread.</li>
</ul>
<h2 id="one-producer-one-consumer-queue-implementation-1">One producer one consumer queue (implementation 1)</h2>
<ul>
<li>We don't need atomic for back index (the first empty slot to insert)</li>
<li>We don’t need atomic for front index (the first element that can be removed)</li>
<li>The only time the two threads interact with each other is when the queue becomes empty.
<ul>
<li>For that, we need an atomic variable: the size of the queue.</li>
<li>This means it is a wait-free queue</li>
</ul>
</li>
</ul>
<p>The producer:</p>
<ul>
<li>Check the size is not exceeding the capacity</li>
<li>constructs the new element in the first empty slot, and advances the back index (these two steps in any order since one producer)</li>
<li>Then increments the size of the queue</li>
</ul>
<p>The consumer:</p>
<ul>
<li>first, check the size to make sure the queue is not empty.</li>
<li>Then take the first element from the queue and advance the front index, and decreases - the size of the queue (in any order since one consumer)</li>
</ul>
<p>Circular buffer</p>
<ul>
<li>When accessing the element, do the modular operation. The back and front index can keep growing.</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pc_queue</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">pc_queue</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> capacity)</span> :
    capacity_(capacity),
    data_(static_cast&lt;T*&gt;(::malloc(sizeof(T)*capacity_))) {</span>}
    ~<span class="hljs-built_in">pc_queue</span>() { ::<span class="hljs-built_in">free</span>(data_); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; v)</span> </span>{
        <span class="hljs-keyword">if</span> (size_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) &gt;= capacity_)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">new</span> (data_ + (back_ % capacity_)) <span class="hljs-built_in">T</span>(v);
        ++back_;
        size_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_release);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-function">std::optional&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (size_.<span class="hljs-built_in">load</span>(std::memory_order_acquire) == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> std::optional&lt;T&gt;(std::nullopt);
        } <span class="hljs-keyword">else</span> {
            std::optional&lt;T&gt; <span class="hljs-built_in">res</span>(
            std::<span class="hljs-built_in">move</span>(data_[front_ % capacity_]));
            data_[front_ % capacity_].~<span class="hljs-built_in">T</span>();
            ++front_;
            size_.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);
            <span class="hljs-keyword">return</span> res;
        }
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity_;
    T* <span class="hljs-keyword">const</span> data_;
    <span class="hljs-keyword">size_t</span> front_ = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> back_ = <span class="hljs-number">0</span>;
    std::atomic&lt;<span class="hljs-keyword">size_t</span>&gt; size_;
};
</div></code></pre>
<h2 id="one-producer-one-consumer-queue-implementation-2">One producer one consumer queue (implementation 2)</h2>
<ul>
<li>good example: <a href="https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular">https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular</a></li>
<li>Another good example: <a href="https://github.com/jnk0le/Ring-Buffer/blob/master/ringbuffer.hpp">https://github.com/jnk0le/Ring-Buffer/blob/master/ringbuffer.hpp</a></li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-keyword">template</span>‹<span class="hljs-keyword">typename</span> Element, <span class="hljs-keyword">size_t</span> Size› 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularFifo</span>{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-class"><span class="hljs-keyword">enum</span> {</span> Capacity = Size+<span class="hljs-number">1</span> };

  <span class="hljs-built_in">CircularFifo</span>() : _tail(<span class="hljs-number">0</span>), _head(<span class="hljs-number">0</span>){}   
  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CircularFifo</span>() {}

  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Element&amp; item)</span></span>; 
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Element&amp; item)</span></span>;

  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wasEmpty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wasFull</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLockFree</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;

<span class="hljs-keyword">private</span>:
  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx)</span> <span class="hljs-keyword">const</span></span>; 

  std::atomic‹<span class="hljs-keyword">size_t</span>›  _tail;  
  Element              _array[Capacity];
  std::atomic‹<span class="hljs-keyword">size_t</span>›  _head; 

<span class="hljs-comment">// or use aligns</span>
<span class="hljs-comment">// alignas(64) std::atomic&lt;size_t&gt; _head;</span>
<span class="hljs-comment">// alignas(64) std::atomic&lt;size_t&gt; _tail;</span>
};
</div></code></pre>
<p><strong>Empty</strong></p>
<p>When the buffer is empty, both indexes will be the same. Any reads by the Consumer will fail.</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wasEmpty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{
  <span class="hljs-keyword">return</span> (_head.<span class="hljs-built_in">load</span>() == _tail.<span class="hljs-built_in">load</span>());
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{
<span class="hljs-keyword">return</span> head.<span class="hljs-built_in">load</span>(index_acquire_barrier) == tail.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
}
</div></code></pre>
<p><strong>Full</strong></p>
<p>When the queue is full, there will be a one slot difference between head and tail. At this point, any writes by the Producer will fail. Yes it must even fail since otherwise the empty queue criterion i.e. head == tail would come true.</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CircularFifo::wasFull</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{
  <span class="hljs-keyword">auto</span> index = _tail.<span class="hljs-built_in">load</span>();
  <span class="hljs-keyword">auto</span> next_tail = (index + <span class="hljs-number">1</span>) % Capacity; <span class="hljs-comment">// default  std::memory_order_seq_cst.</span>
  <span class="hljs-keyword">return</span> (next_tail == _head.<span class="hljs-built_in">load</span>());
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{
   <span class="hljs-keyword">return</span> buffer_size == 
          (head.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) - tail.<span class="hljs-built_in">load</span>(index_acquire_barrier));
}
</div></code></pre>
<p><strong>Sequential Consistent Version</strong></p>
<pre><code class="language-C++"><div><span class="hljs-comment">/* Producer only: updates tail index after setting the element in place */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(Element&amp; item_)</span>
</span>{	
  <span class="hljs-keyword">auto</span> current_tail = _tail.<span class="hljs-built_in">load</span>();            
  <span class="hljs-keyword">auto</span> next_tail = <span class="hljs-built_in">increment</span>(current_tail);    
  <span class="hljs-keyword">if</span>(next_tail != _head.<span class="hljs-built_in">load</span>())                         
  {
    _array[current_tail] = item;               
    _tail.<span class="hljs-built_in">store</span>(next_tail);                    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// full queue</span>
}

<span class="hljs-comment">/* Consumer only: updates head index after retrieving the element */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Element&amp; item)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> current_head = _head.<span class="hljs-built_in">load</span>();  
  <span class="hljs-keyword">if</span>(current_head == _tail.<span class="hljs-built_in">load</span>())  
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// empty queue</span>

  item = _array[current_head]; 
  _head.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">increment</span>(current_head)); 
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> idx)</span> <span class="hljs-keyword">const</span>
</span>{
  <span class="hljs-keyword">return</span> (idx + <span class="hljs-number">1</span>) % Capacity;
}
</div></code></pre>
<p><strong>Acquire-Release/Relaxed Version</strong></p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Element&amp; item)</span>
</span>{       
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> current_tail = _tail.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> next_tail = <span class="hljs-built_in">increment</span>(current_tail);                   
  <span class="hljs-keyword">if</span>(next_tail != _head.<span class="hljs-built_in">load</span>(std::memory_order_acquire))            <span class="hljs-comment">// 2               </span>
  {     
    _array[current_tail] = item;                                    <span class="hljs-comment">// 3</span>
    _tail.<span class="hljs-built_in">store</span>(next_tail, std::memory_order_release);              <span class="hljs-comment">// 4</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// full queue</span>
}
</div></code></pre>
<ol>
<li>Relaxed loading of the tail value. Since the Producer thread is the only thread calling <code>push()</code> it is guaranteed that the tail value will be the latest. No cross-thread synchronization is needed for the load.</li>
<li>The next_tail is compared against the head value snapshot. The head value is pair-wise acquire-release synchronized. It is guaranteed to never come out-of-order with following head updates.</li>
<li>The item is saved in the position pointed to by the not-yet-synchronized next_tail. This happens-before the release store in (4) and is guaranteed that the save is seen before (4).</li>
<li>The tail is updated with release order. Pair-synchronization with the Consumer thread is guaranteed with the Consumer's acquire reading of tail.</li>
</ol>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Element&amp; item)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> current_head = _head.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);    <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">if</span>(current_head == _tail.<span class="hljs-built_in">load</span>(std::memory_order_acquire))           <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// empty queue</span>

  item = _array[current_head];                                       <span class="hljs-comment">// 3</span>
  _head.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">increment</span>(current_head), std::memory_order_release);   <span class="hljs-comment">// 4</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<ol>
<li>Relaxed loading of the head value. Since the Consumer thread is the only thread calling <code>pop()</code> it is guaranteed that the head value will be the latest. No cross-thread synchronization is needed for the load.</li>
<li>The current_head is compared against the tail value snapshot. The tail value is pair-wise acquire-release synchronized. It is guaranteed to never come out-of-order with following tail updates.</li>
<li>The item is retrieved from the position pointed to by the current_head. This happens-before the release store in (4).</li>
<li>The head is updated with release order. Pair-wise synchronization with the Producer's thread is guaranteed with the Producer's acquire reading of tail.</li>
</ol>
<br>
<br>
<h2 id="non-sequentially-consistent-queue">Non-sequentially consistent queue</h2>
<p>If you don't care about the exact ordering of the element being pushed and popped into the queue, we can have a data structure like this: instead of a single queue thread-safe queue, we can have several single-threaded sub-queues. Each thread must atomically acquire exclusive ownership of one of these sub-queues.</p>
<ul>
<li>The simplest way to implement this is with an array of atomic pointers to the sub-queues</li>
<li>A thread that needs to access (either push or pop) the queue must first acquire a sub-queue. To acquire the ownership and, at the same time, prevent any other thread from getting access to the queue, we atomically exchange the sub-queue pointer with null.</li>
<li>Since there is only one thread operating on each sub-queue, each sub-queue is a regular queue, no locking needed.</li>
</ul>
<p><img src="images/2022-01-24-17-37-56.png" alt=""></p>
<h2 id="handle-the-out-of-memory-case">Handle the out-of-memory case</h2>
<ul>
<li>Try to avoid the problem
<ul>
<li>We can know the total capacity</li>
<li>We can push the problem back to a caller</li>
</ul>
</li>
<li>Best not to copy the entire existing data structure when adding memory. Such like std::deque</li>
<li>We dont want to acquire the memory lock in every thread every time.</li>
<li>We can have an atomic flag, but we also need a double checking lock to prevent multiple threads seeing the atomic flag being set.</li>
</ul>
<pre><code class="language-C++"><div>std::atomic&lt;<span class="hljs-keyword">int</span>&gt; wait; <span class="hljs-comment">// 1 if managing memory</span>
std::mutex lock;
<span class="hljs-keyword">while</span> (wait == <span class="hljs-number">1</span>) {}; <span class="hljs-comment">// Memory allocation in progress</span>
    <span class="hljs-keyword">if</span> ( … out of memory … ) {
        <span class="hljs-function">std::lock_guard <span class="hljs-title">g</span><span class="hljs-params">(lock)</span></span>;
    <span class="hljs-keyword">if</span> (… out of memory …) { <span class="hljs-comment">// We got here first!</span>
        wait = <span class="hljs-number">1</span>;
        … allocate more memory …
        wait = <span class="hljs-number">0</span>;
    }
}
… <span class="hljs-keyword">do</span> the operation normally …
</div></code></pre>
<br>
<h1 id="thread-safe-list">Thread-safe list</h1>
<p>Watch for A-B-A problem.</p>

        
        
    </body>
    </html>