<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Kernel</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.13.24"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
#button { display: inline-block; background-color: #FF9800; width: 50px; height: 50px; text-align: center; border-radius: 4px; position: fixed; bottom: 30px; right: 30px; transition: background-color .3s, opacity .5s, visibility .5s; opacity: 0; /*visibility: hidden;*/ z-index: 1000; } #button::after { content: "\f077"; font-family: FontAwesome; font-weight: normal; font-style: normal; font-size: 2em; line-height: 50px; color: #fff; } #button:hover { cursor: pointer; background-color: #333; } #button:active { background-color: #555; } #button.show { opacity: 1; visibility: visible; } #btn-back-to-top { position: fixed; bottom: 20px; right: 20px; display: none; } .to-top { background: white; position: fixed; bottom: 16px; right:32px; width:50px; height:50px; border-radius: 50%; border-color: white; display: flex; align-items: center; justify-content: center; font-size:32px; color:#1f1f1f; text-decoration: none; opacity: 0.5; pointer-events: auto; transition: all .4s; transform: rotate(270deg); } 
</style>
    </head>
    <body class="vscode-body vscode-light">
        <!-- title: Kernel -->
<h1>Kernel and Kernel Internals</h1>
<p><a href="#" class="to-top">➤</i></a></p>
<ul>
<li><a href="#kernel-overview">Kernel Overview</a>
<ul>
<li><a href="#tasks-performed-by-kernel">Tasks performed by kernel</a></li>
<li><a href="#the-init-process">The init process</a></li>
<li><a href="#proc-virtual-file-system"><code>/proc</code> virtual file system</a></li>
<li><a href="#sys-virtual-file-system"><code>/sys</code> virtual file system</a></li>
<li><a href="#sysctl">Sysctl</a></li>
</ul>
</li>
<li><a href="#kernel-is-special">Kernel is special</a>
<ul>
<li><a href="#no-libc-or-standard-headers">No libc or Standard Headers</a></li>
<li><a href="#gnu-c">GNU C</a></li>
<li><a href="#no-memory-protection">No memory protection</a></li>
<li><a href="#small-fixed-size-stack">Small fixed-size Stack</a></li>
<li><a href="#synchronization-and-concurrency">Synchronization and Concurrency</a></li>
<li><a href="#importance-of-portability">Importance of portability</a></li>
</ul>
</li>
<li><a href="#kernel-history">Kernel History</a></li>
<li><a href="#kernel-data-structures">Kernel Data Structures</a>
<ul>
<li><a href="#linked-list">Linked list</a></li>
<li><a href="#queue">Queue</a></li>
<li><a href="#maps">Maps</a></li>
<li><a href="#binary-tree">Binary Tree</a></li>
</ul>
</li>
<li><a href="#kernel-synchronization">Kernel Synchronization</a>
<ul>
<li><a href="#preemption-disabling">Preemption Disabling</a></li>
<li><a href="#atomic-integer">atomic integer</a></li>
<li><a href="#atomic-bitwise-operation">atomic bitwise operation</a></li>
<li><a href="#spin-lock">spin lock</a>
<ul>
<li><a href="#spin-lock-kernel-implementation">Spin lock kernel Implementation</a></li>
</ul>
</li>
<li><a href="#read-write-spin-lock">read-write spin lock</a></li>
<li><a href="#seq-lock">seq lock</a></li>
<li><a href="#rcu">RCU</a>
<ul>
<li><a href="#srcu-sleepable-rcu">SRCU (Sleepable RCU)</a></li>
</ul>
</li>
<li><a href="#mutexes">mutexes</a>
<ul>
<li><a href="#linux-spinlock-vs-mutex">Linux spinlock vs mutex</a></li>
</ul>
</li>
<li><a href="#semaphores">Semaphores</a>
<ul>
<li><a href="#linux-mutex-vs-semaphore">Linux Mutex vs Semaphore</a></li>
</ul>
</li>
<li><a href="#completion-variables">completion variables</a></li>
<li><a href="#memory-barriers">Memory Barriers</a></li>
<li><a href="#compiler-barrier">compiler barrier</a></li>
<li><a href="#bkl-the-big-kernel-lock">BKL: The big kernel lock</a></li>
</ul>
</li>
<li><a href="#timer-related">Timer related</a>
<ul>
<li><a href="#the-time-of-day">The time of Day</a></li>
<li><a href="#timers">Timers</a></li>
</ul>
</li>
</ul>
<h1 id="kernel-overview">Kernel Overview</h1>
<p>Kernel source search:</p>
<ul>
<li><a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source</a></li>
<li><a href="https://livegrep.com/search/linux">https://livegrep.com/search/linux</a></li>
</ul>
<h2 id="tasks-performed-by-kernel">Tasks performed by kernel</h2>
<ul>
<li>Process scheduling. Preemptive means that the rules governing which processes receive use of the CPU and for how long are determined by the kernel process scheduler</li>
<li>Memory management. Virtual memory system.
<ul>
<li>Isolation. Process can’t read/modify memory of another nor the kennel</li>
<li>Only part of a process needs to be kept in memory.</li>
</ul>
</li>
<li>Filesystem. Kernel provides a filesystem on disk.</li>
<li>Creation and termination of processes.</li>
<li>Access to devices.</li>
<li>networking .</li>
<li>System call API. Processes can request the kernel to perform various tasks using kernel entry points known as system calls.</li>
</ul>
<h2 id="the-init-process">The init process</h2>
<ul>
<li>When booting the system, the kernel creates a special process called init, which is derived from the program file /sbin/init.</li>
<li>All processes on the system are created (using fork()) either by init or by one of its descendants.</li>
<li>The init process always has the process ID 1 and runs with root privileges.</li>
<li>init can’t be killed (not even by the root), and it terminates only when the system is shut down.</li>
<li>The main task of init is to create and monitor a range of processes required by a running system.</li>
</ul>
<h2 id="proc-virtual-file-system"><code>/proc</code> virtual file system</h2>
<ul>
<li>The <code>/proc</code> file system is a virtual file system that provides an interface to kernel data structures in a form that looks like files and directories on a file system.</li>
<li>This provides an easy mechanism for viewing and changing (using normal file I/O system calls) various system attributes.</li>
<li>A set of directories of the form <code>/proc/PID</code>, allows us to view information about each process running on the system.</li>
<li>The <code>/proc</code> file system is said to be virtual because the files and subdirectories that it contains don’t reside on a disk. Instead, the kernel creates them “on the fly” as processes access them.</li>
</ul>
<p>per-process info:</p>
<p><img src="images/2022-03-01-21-59-52.png" alt=""></p>
<p><strong><code>/proc/PID/fd</code></strong></p>
<p>The <code>/proc/PID/fd</code> directory contains one symbolic link for each file descriptor that the process has open.</p>
<ul>
<li>for example, <code>/proc/1968/1</code> is a symbolic link to the standard output of process 1968.</li>
</ul>
<p><strong><code>/proc/PID/task</code></strong></p>
<p>For each thread in this process, the kernel provides a subdirectory named <code>/proc/PID/task/TID</code>, TID is the same number as would be returned by a call to gettid() in the thread.</p>
<ul>
<li>Under each <code>/proc/PID/task/TID</code> subdirectory is a set of files and directories exactly like those that are found under <code>/proc/PID</code>.</li>
<li>For example, in the <code>/proc/PID/task/TID/status</code> files for a thread group</li>
</ul>
<p>System-wide info:</p>
<p><img src="images/2022-03-01-22-01-44.png" alt=""></p>
<p>System-wide files related to performance observability include:</p>
<ul>
<li><code>cpuinfo</code>: Physical processor information, including every virtual CPU, model name, clock
speed, and cache sizes.</li>
<li><code>diskstats</code>: Disk I/O statistics for all disk devices</li>
<li><code>interrupts</code>: Interrupt counters per CPU</li>
<li><code>loadavg</code>: Load averages</li>
<li><code>meminfo</code>: System memory usage breakdowns</li>
<li><code>net/dev</code>: Network interface statistics</li>
<li><code>net/netstat</code>: System-wide networking statistics</li>
<li><code>net/tcp</code>: Active TCP socket information</li>
<li><code>pressure/</code>: Pressure stall information (PSI) files</li>
<li><code>schedstat</code>: System-wide CPU scheduler statistics</li>
<li><code>self</code>: A symlink to the current process ID directory, for convenience</li>
<li><code>slabinfo</code>: Kernel slab allocator cache statistics</li>
<li><code>stat</code>: A summary of kernel and system resource statistics: CPUs, disks, paging, swap,
processes and is used by many tools (<code>vmstat(8)</code>, <code>mpstat(1)</code>,<code> sar(1)</code>, monitoring agents).</li>
<li><code>zoneinfo</code>: Memory zone information</li>
</ul>
<p>These are read by system-wide tools. For example, here’s <code>vmstat(8)</code> reading <code>/proc</code>, as traced by <code>strace(1)</code>. The output shows that <code>vmstat(8)</code> was reading meminfo, stat, and vmstat.</p>
<pre><code class="language-bash"><div>open(<span class="hljs-string">&quot;/proc/meminfo&quot;</span>, O_RDONLY) = 3
lseek(3, 0, SEEK_SET) = 0
<span class="hljs-built_in">read</span>(3, <span class="hljs-string">&quot;MemTotal: 889484 kB\nMemF&quot;</span>..., 2047) = 1170
open(<span class="hljs-string">&quot;/proc/stat&quot;</span>, O_RDONLY) = 4
<span class="hljs-built_in">read</span>(4, <span class="hljs-string">&quot;cpu 14901 0 18094 102149804 131&quot;</span>..., 65535) = 804
open(<span class="hljs-string">&quot;/proc/vmstat&quot;</span>, O_RDONLY) = 5
lseek(5, 0, SEEK_SET) = 0
<span class="hljs-built_in">read</span>(5, <span class="hljs-string">&quot;nr_free_pages 160568\nnr_inactive&quot;</span>..., 2047) = 1998
</div></code></pre>
<h2 id="sys-virtual-file-system"><code>/sys</code> virtual file system</h2>
<p>Linux provides a <em>sysfs</em> file system (introduced with the 2.6 kernel), mounted on <code>/sys</code>. It provides a directory-based structure for kernel statistics. <em>sysfs</em> was originally designed to provide device driver statistics but has been extended to include any statistic type.</p>
<p>Some examples:</p>
<pre><code class="language-bash"><div>$ find /sys/devices/system/cpu/cpu0 -<span class="hljs-built_in">type</span> f
/sys/devices/system/cpu/cpu0/uevent
/sys/devices/system/cpu/cpu0/hotplug/target
/sys/devices/system/cpu/cpu0/hotplug/state
/sys/devices/system/cpu/cpu0/hotplug/fail
/sys/devices/system/cpu/cpu0/crash_notes_size
/sys/devices/system/cpu/cpu0/power/runtime_active_time
/sys/devices/system/cpu/cpu0/power/runtime_active_kids
/sys/devices/system/cpu/cpu0/power/pm_qos_resume_latency_us
/sys/devices/system/cpu/cpu0/power/runtime_usage
[...]

$ grep . /sys/devices/system/cpu/cpu0/cache/index*/size
/sys/devices/system/cpu/cpu0/cache/index0/size:32K
/sys/devices/system/cpu/cpu0/cache/index1/size:32K
/sys/devices/system/cpu/cpu0/cache/index2/size:1024K
/sys/devices/system/cpu/cpu0/cache/index3/size:33792K
</div></code></pre>
<h2 id="sysctl">Sysctl</h2>
<p>To view a system config</p>
<pre><code class="language-bash"><div>$ sysctl net.ipv4.tcp_sack
net.ipv4.tcp_sack = 1
</div></code></pre>
<p>To change a system config</p>
<pre><code class="language-bash"><div>$ sysctl -w net.ipv4.tcp_sack=0
net.ipv4.tcp_sack = 0
</div></code></pre>
<p>Settings are persisted in the <code>/etc/sysctl.conf</code> file, and in separate <code>.conf</code> files in the <code>/etc/sysctl.d/</code> directory in later Red Hat releases. These files can be edited directly with a text editor. The values are applied at reboot.</p>
<pre><code class="language-bash"><div>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;net.ipv4.tcp_sack = 0&#x27;</span> &gt;&gt; /etc/sysctl.conf
</div></code></pre>
<br>
<br>
<h1 id="kernel-is-special">Kernel is special</h1>
<h2 id="no-libc-or-standard-headers">No libc or Standard Headers</h2>
<ul>
<li>a chickenand-the-egg situation</li>
<li>primary reason is speed and size. The full C library—or even a decent subset of it—is too large and too inefficient for the kernel.</li>
<li>Many of the usual libc functions are implemented inside the kernel. like <code>lib/string.c</code> and architecture-specific headers are in <code>arch/x86/include/asm</code>.</li>
</ul>
<p>It has <code>printk()</code> instead of printf()</p>
<ul>
<li>The printk()function copies the formatted string into the kernel log buffer, which is normally read by the syslog program.</li>
<li>One notable difference between printf() and printk() is that printk() enables you
to specify a priority flag.This flag is used by syslogd to decide where to display kernel messages.<pre><code class="language-C++"><div><span class="hljs-built_in">printk</span>(KERN_ERR <span class="hljs-string">&quot;this is an error!\n&quot;</span>);
</div></code></pre>
Note there is no comma between KERN_ERR and the printed message.This is intentional;
the priority flag is a preprocessor-define representing a string literal, which is concatenated
onto the printed message during compilation.</li>
</ul>
<h2 id="gnu-c">GNU C</h2>
<ul>
<li>the kernel is not programmed in strict ANSI C.</li>
<li>The kernel developers make use of various language extensions available in gcc</li>
<li>The kernel developers use both ISO C991 and GNU C extensions to the C language.</li>
</ul>
<p><strong>inline functions</strong>
Kernel developers use inline functions for small time-critical functions.</p>
<p>Common practice is to place inline functions in header files. Because
they are marked static, an exported function is not created. If an inline function is used
by only one file, it can instead be placed toward the top of just that file.</p>
<p><strong>inline assembly</strong>
The asm() compiler directive is used to inline assembly code.</p>
<p>The Linux kernel is written in a mixture of C and assembly, with assembly relegated
to low-level architecture and fast path code.The vast majority of kernel code is programmed
in straight C.</p>
<p><strong>Branch annotation</strong>
The kernel wraps the directive in easy-to-use macros, likely() and
unlikely().</p>
<p>These directives result in a performance boost when the
branch is correctly marked, but a performance loss when the branch is mismarked.</p>
<h2 id="no-memory-protection">No memory protection</h2>
<p>When a user-space application attempts an illegal memory access, the kernel can trap the
error, send the SIGSEGV signal, and kill the process. If the kernel attempts an illegal memory access, it is a major kernel error.</p>
<p>Additionally, kernel memory is not pageable. (will not be swapped out). Every byte of memory consume physical memory.</p>
<h2 id="small-fixed-size-stack">Small fixed-size Stack</h2>
<p>User-space stack is large and can dynamically grow.</p>
<p>The kernel stack is neither large nor dynamic; it is small and fixed in size.The exact
size of the kernel’s stack varies by architecture. Historically, the kernel stack is two pages, which generally implies that it is 8KB on 32-bit architectures and 16KB on 64-bit architectures.</p>
<p>Each process receives its own stack.</p>
<h2 id="synchronization-and-concurrency">Synchronization and Concurrency</h2>
<p>The kernel is susceptible to race conditions.</p>
<ul>
<li>Linux is a preemptive multitasking operating system. Processes are scheduled and
rescheduled at the whim of the kernel’s process scheduler.The kernel must synchronize
between these tasks.</li>
<li>Linux supports symmetrical multiprocessing (SMP).Therefore, without proper protection,
kernel code executing simultaneously on two or more processors can concurrently
access the same resource.</li>
<li>Interrupts occur asynchronously with respect to the currently executing code.
Therefore, without proper protection, an interrupt can occur in the midst of accessing
a resource, and the interrupt handler can then access the same resource.</li>
<li>The Linux kernel is preemptive.Therefore, without protection, kernel code can be
preempted in favor of different code that then accesses the same resource.</li>
</ul>
<p>Typical solutions to race conditions include spinlocks and semaphores.</p>
<h2 id="importance-of-portability">Importance of portability</h2>
<p>architecture-independent C
code must correctly compile and run on a wide range of systems, and that architecturedependent
code must be properly segregated in system-specific directories in the kernel
source tree.</p>
<p>A handful of rules—such as remain endian neutral, be 64-bit clean, do not assume the
word or page size, and so on</p>
<br>
<h1 id="kernel-history">Kernel History</h1>
<p><strong>The start of Unix</strong> <br></p>
<ul>
<li>1969, The first Unix by Ken Thompson at Bell lab (a division of AT&amp;T), in assembly.</li>
<li>1972-1973, Dennis Ritchie, Thompson’s colleague at Bell lab implemented C. (BTW, C followed interpreted language B, which was implemented by Thompson). The design of C arose from the ideas and needs of a few individuals working toward a single goal: developing a high-level language for implementing the UNIX kernel and associated software.</li>
<li>1973: Unix was almost totally rewritten in C.</li>
</ul>
<p><strong>The start of BSD</strong> <br></p>
<ul>
<li>1975-1976 Thompson visited UCB and worked with students to add new features to UNIX.
Under the name Berkeley Software Distribution (BSD), this version of UNIX, including its source code, came to be widely distributed.</li>
<li>1983 UCB released 4.2BSD - containing a complete TCP/IP implementation. It is widely distributed in universities around the world. It also formed the basis for SunOS (the UNIX variant sold by Sun, first released in 1983, later Solaris).</li>
<li>1986 4.3BSD released.</li>
<li>1993 final release 4.4BSD released.</li>
<li>June 1991 BSD Net/2 release, a version of the 4.3BSD without remaining proprietary AT&amp;T source code. In the face of an increasingly large backlog of patches, couple alternative development groups appeared
<ul>
<li>1993, NetBSD, which emphasizes portability to a wide range of hardware platforms</li>
<li>1993, FreeBSD, which emphasizes performance and is the most widespread of the modern BSDs</li>
<li>1996, OpenBSD, after forking from NetBSD, emphasizing security.</li>
</ul>
</li>
</ul>
<p><strong>The start of System V</strong> <br></p>
<ul>
<li>US antitrust legislation forced the breakup of AT&amp;T in the mid-1970s, after that, the company was permitted to market UNIX. ATT thus enhanced and developed UNIX applications.</li>
<li>1983 first release of System V</li>
<li>1989 the definitive System V Release 4 (SVR4). By which time System V had incorporated many features from BSD. System V was licensed to a variety of commercial vendors, who
used it as the basis of their UNIX implementations.</li>
</ul>
<p><strong>Side bar</strong>: lawsuits between UNIX System Laboratories (USL, the AT&amp;T subsidiary spun off to develop and market UNIX) and UC Berkeley.</p>
<p><strong>The GNU project</strong> <br></p>
<ul>
<li>1984 Richard Stallman started the GNU project (a recursively defined acronym for “GNU’s not UNIX”) to develop an entire, freely available, UNIX-like system,</li>
<li>1985 Stallman founded the Free Software Foundation (FSF), a nonprofit organization to support the GNU project as well as the development of free software in general.
<ul>
<li>GNU General Public License (GPL)</li>
</ul>
</li>
<li>The GNU project did not initially produce a working UNIX kernel, but did produce a wide range of other programs, including <code>emcas</code>, <code>gcc</code>, <code>glibc</code>, <code>bash</code>.</li>
<li>By the early 1990s, the GNU project had produced a system that was virtually complete, except for one important component: a working UNIX kernel.</li>
</ul>
<p><strong>The Linux Kernel</strong> <br></p>
<ul>
<li>1991, Linus Torvalds, a Finnish student at the University of Helsinki, was inspired to write an operating system for his Intel 80386 PC. Torvalds therefore started on a project to create an efficient, full-featured UNIX kernel to run on the 386. Over a few months, Torvalds developed a basic kernel that allowed him to compile and run various GNU programs.</li>
<li>October 5, 1991, Torvalds requested the help of other programmers, making the following now much-quoted announcement of version 0.02 of his kernel.</li>
<li>March 1994, the developers were able to release version 1.0.</li>
<li>March 1995, v1.2</li>
<li>June 1996, v2.0</li>
<li>Jan 1999, v2.2</li>
<li>Jan 2001, v2.4</li>
<li>Dec 2003, v2.6</li>
</ul>
<p>Before v2.6, Two kernel versions were always under development:</p>
<ul>
<li>a stable branch for use on production systems, which had an even minor version number</li>
<li>a more volatile development branch, which carried the next higher odd minor version number.</li>
<li>For example, the 2.3.z development kernel branch resulted in the 2.4 stable kernel branch.</li>
</ul>
<p><strong>Linux distributors</strong>, who created packages (distributions) to automate most of the installation process, creating a file system and installing the kernel and other required software.</p>
<ul>
<li>In 1993, the non-commercial Debian distribution appeared</li>
<li>SUSE and Red Hat soon followed.</li>
<li>Ubuntu distribution first appeared in 2004.</li>
</ul>
<p><strong>The standardization of C</strong><br>
Situation:</p>
<ul>
<li>By early 1980s, C had been implemented on a variety of UNIX systems with many differences, many details missing in de facto standard - the C Programming language book.</li>
<li>Appearance of C++ in 1985 shows some improvements that can be back ported to C.</li>
</ul>
<p>Standard <strong>C89</strong> (also often called ANSI C) <br>
in 1989 with the approval of the American National Standards Institute (ANSI) C standard
(X3.159-1989), which was subsequently adopted in 1990 as an International Standards
Organization (ISO) standard. The standard defines the syntax and semantics of C, the operation of the standard C library, which includes the stdio functions, string-handling functions, math functions, various header files, and so on.</p>
<p><strong>C99</strong> <br>
A revision of the C standard was adopted by ISO in 1999. It includes the addition of long long and Boolean data types, C++-style (//) comments, restricted pointers, and variable-length arrays.</p>
<p><strong>POSIX standard</strong><br></p>
<ul>
<li>POSIX.1 documents an API for a set of services that should be made available to a program by a conforming operating system. An operating system that does this can be certified as POSIX.1 conformant.</li>
<li>POSIX.1 is based on the UNIX system call and the C library function API. But interfaces can be implemented by any OS.</li>
<li>1988 POSIX.1 (or, more fully, POSIX 1003.1) became an IEEE standard.
<ul>
<li>IEEE POSIX 1003.1b, a range of realtime extensions</li>
<li>IEEE POSIX 1003.1c, definition of POSIX threads, 1995</li>
<li>IEEE POSIX 1003.1g, define of networking APIs, including socket</li>
<li>IEEE POSIX 1003.1d and POSIX1j, defined additional realtime extensions.</li>
</ul>
</li>
<li>1992 A related standard, POSIX.2 standardized the shell and various UNIX utilities, including the command-line interface of the C compiler.</li>
<li>In 2001, the combined POSIX 1003.1-2001 and SUSv3 standard was ratified. This standard consolidates and extends various earlier POSIX standards and earlier versions of the Single UNIX Specification. This standard is also known as the Single UNIX Specification Version 3 (SUSv3)</li>
<li>2008, a less wide-ranging revision of the standard was completed, yielding the combined
POSIX 1003.1-2008 and SUSv4 standard.</li>
</ul>
<p><strong>Implementation standard</strong><br></p>
<ul>
<li>two implementation standards defined by the final BSD release (4.4BSD) and AT&amp;T’s System V Release 4 (SVR4). Latter defined the interface that a UNIX implementation must provide in order to be able to call itself System V Release 4</li>
<li>Because the behavior of some system calls and library functions varies between SVR4 and BSD, many UNIX implementations provide compatibility libraries and conditional-compilation facilities.</li>
</ul>
<br>
<h1 id="kernel-data-structures">Kernel Data Structures</h1>
<h2 id="linked-list">Linked list</h2>
<p>The Linux kernel approach: Instead of turning the structure into a linked list, the Linux approach is to <em>embed a linked list node in the structure</em>!</p>
<p>It is important to note that the pointers in a <code>list_head</code> field store the addresses of other <code>list_head</code> fields rather than the addresses of
the whole data structures in which the <code>list_head</code> structure is included;
<img src="images/2022-02-17-09-14-16.png" alt=""></p>
<p>The linked-list code is declared in the header file &lt;linux/list.h&gt; and the data structure
is simple:</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">next</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">prev</span>;</span>
};
</div></code></pre>
<p>Usage example:</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fox</span> {</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> tail_length; <span class="hljs-comment">/* length in centimeters of tail */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> weight; <span class="hljs-comment">/* weight in kilograms */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span> <span class="hljs-comment">/* list of all fox structures */</span>
};
</div></code></pre>
<p>Using the macro <code>container_of()</code>, we can easily find the parent
structure containing any list_head. This is because in C, the offset of a
given variable into a structure is fixed by the ABI at compile time.</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> container_of(ptr, type, member) ({              \
    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \
    (type *)( (char *)__mptr - offsetof(type,member) );})</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> list_entry(ptr, type, member)       \
            container_of(ptr, type, member)</span>
</div></code></pre>
<p>Armed with <code>list_entry()</code>, the kernel provides routines to create, manipulate, and manage linked lists, all without knowing anything about the structures that the list_head resides within.</p>
<p>Initialize the list</p>
<pre><code class="language-C++"><div><span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;red_fox-&gt;list);
</div></code></pre>
<p>A special pointer that refers to your linked list, without being a list node itself.</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">LIST_HEAD</span><span class="hljs-params">(fox_list)</span></span>;
</div></code></pre>
<p>Add a node to list</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// To add the new node to the given list immediately after the head node.</span>
<span class="hljs-comment">// you can pass any element for head, </span>
<span class="hljs-comment">// but if you do pass the “last” element, however, this function can be used to implement a stack.</span>
<span class="hljs-built_in">list_add</span>(struct list_head *<span class="hljs-keyword">new</span>, struct list_head *head)

<span class="hljs-comment">// To add a node to the end of a linked list:</span>
<span class="hljs-comment">// This function adds the new node to the given list immediately before the head node.</span>
<span class="hljs-comment">// if you pass the “first” element, this function can be used to implement a queue</span>
<span class="hljs-built_in">list_add_tail</span>(struct list_head *<span class="hljs-keyword">new</span>, struct list_head *head)
</div></code></pre>
<p>Traverse the list with <code>list_for_each()</code> macro. The macro takes two parameters, both <code>list_head</code> structures.</p>
<ul>
<li>The first is a pointer used to point to the current entry; it is a temporary variable that you must provide.</li>
<li>The second is the list_head acting as the head node of the list you want to traverse</li>
</ul>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">p</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fox</span> *<span class="hljs-title">f</span>;</span>
<span class="hljs-built_in">list_for_each</span>(p, &amp;fox_list) {
    <span class="hljs-comment">/* f points to the structure in which the list is embedded */</span>
    f = <span class="hljs-built_in">list_entry</span>(p, struct fox, list);
}
</div></code></pre>
<p>Most kernel code traverses the list with <code>list_for_each_entry()</code> macro. This macro handles the work
performed by <code>list_entry()</code>, making list iteration simple. An example:</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">static</span> struct inotify_watch *<span class="hljs-title">inode_find_handle</span><span class="hljs-params">(struct inode *inode,
struct inotify_handle *ih)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inotify_watch</span> *<span class="hljs-title">watch</span>;</span>
    <span class="hljs-built_in">list_for_each_entry</span>(watch, &amp;inode-&gt;inotify_watches, i_list) {
        <span class="hljs-keyword">if</span> (watch-&gt;ih == ih)
            <span class="hljs-keyword">return</span> watch;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
</div></code></pre>
<p>Itarate list while removing the element.</p>
<p>The Linux kernel provides <code>list_for_each_entry_safe(pos, next, head, member)</code>.  You use this version in the same manner as list_for_each_entry(), except that you provide the next pointer.The next pointer is used to store the next entry in the list, making it safe to remove the current entry. One example:</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inotify_inode_is_dead</span><span class="hljs-params">(struct inode *inode)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inotify_watch</span> *<span class="hljs-title">watch</span>, *<span class="hljs-title">next</span>;</span>

    <span class="hljs-built_in">mutex_lock</span>(&amp;inode-&gt;inotify_mutex);
    <span class="hljs-built_in">list_for_each_entry_safe</span>(watch, next, &amp;inode-&gt;inotify_watches, i_list) {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inotify_handle</span> *<span class="hljs-title">ih</span> =</span> watch-&gt;ih;
        <span class="hljs-built_in">mutex_lock</span>(&amp;ih-&gt;mutex);
        <span class="hljs-built_in">inotify_remove_watch_locked</span>(ih, watch); <span class="hljs-comment">/* deletes watch */</span>
        <span class="hljs-built_in">mutex_unlock</span>(&amp;ih-&gt;mutex);
    }
    <span class="hljs-built_in">mutex_unlock</span>(&amp;inode-&gt;inotify_mutex);
}
</div></code></pre>
<h2 id="queue">Queue</h2>
<p>The Linux kernel’s generic queue implementation is called kfifo and is implemented in
kernel/kfifo.c and declared in &lt;linux/kfifo.h&gt;.</p>
<ul>
<li>
<p>kfifo provides two primary operations: enqueue (named in) and dequeue (out).</p>
<ul>
<li>The enqueue (in) operation copies data into the queue, starting at the in offset. When
complete, the in offset is incremented by the amount of data enqueued.</li>
<li>The dequeue (out) operation copies data out of the queue, starting from the out offset.When complete,
the out offset is incremented by the amount of data enqueued.</li>
</ul>
</li>
<li>
<p>kfifo object maintains two offsets into the queue: an in offset and an out offset.</p>
<ul>
<li>The in offset is the location in the queue to which the next enqueue will occur.</li>
<li>The out offset is the location in the queue from which the next dequeue will occur.</li>
<li>The out offset is always less than or equal to the in offset.</li>
<li>When the out offset is equal to the in offset, the queue is empty</li>
<li>When the in offset is equal to the length of the queue, no more data can be enqueued</li>
</ul>
</li>
</ul>
<p>Allocating Queue, size of the queue must be power of 2.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// dynamic create a fifo with PAGE_SIZE size</span>
<span class="hljs-comment">// use kfifo_free to destroy the queue later</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kfifo</span> <span class="hljs-title">fifo</span>;</span>
<span class="hljs-keyword">int</span> ret;
ret = <span class="hljs-built_in">kfifo_alloc</span>(&amp;fifo, PAGE_SIZE, GFP_KERNEL);
<span class="hljs-keyword">if</span> (ret)
    <span class="hljs-keyword">return</span> ret; 

<span class="hljs-comment">//use the buffer allcoated before when creating the queue</span>
<span class="hljs-comment">// This function creates and initializes a kfifo that will use the size bytes of memory pointed at by buffer for its queue.</span>
<span class="hljs-comment">// use kfifo_reset to clear the queue later</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kfifo_init</span><span class="hljs-params">(struct kfifo *fifo, <span class="hljs-keyword">void</span> *buffer, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span>; 

<span class="hljs-comment">//statically declaring a kfifo</span>
<span class="hljs-built_in">DECLARE_KFIFO</span>(name, size);
<span class="hljs-built_in">INIT_KFIFO</span>(name);
</div></code></pre>
<p>Enqueuing Data</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// This function copies the len bytes starting at from into the queue represented by fifo.</span>
<span class="hljs-comment">// The function only copies up to the avaialble bytes, the return value can be less than the len or even zero.</span>
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kfifo_in</span><span class="hljs-params">(struct kfifo *fifo, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *from, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len)</span></span>;
</div></code></pre>
<p>Dequeue</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// This function copies at most len bytes from the queue pointed at by fifo to the buffer pointed at by to.</span>
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kfifo_out</span><span class="hljs-params">(struct kfifo *fifo, <span class="hljs-keyword">void</span> *to, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len)</span></span>;

<span class="hljs-comment">// if you want to “peek” at data within the queue without removing it, you can use kfifo_out_peek():</span>
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kfifo_out_peek</span><span class="hljs-params">(struct kfifo *fifo, <span class="hljs-keyword">void</span> *to, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">unsigned</span> offset)</span></span>;
</div></code></pre>
<p>Utilities</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// total size in bytes of the buffer used to store a kfifo’s queue</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kfifo_size</span><span class="hljs-params">(struct kfifo *fifo)</span></span>;
<span class="hljs-comment">// the number of bytes enqueued in a kfifo</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kfifo_len</span><span class="hljs-params">(struct kfifo *fifo)</span></span>;
<span class="hljs-comment">// the number of bytes available to write into a kfifo</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kfifo_avail</span><span class="hljs-params">(struct kfifo *fifo)</span></span>;
</div></code></pre>
<h2 id="maps">Maps</h2>
<p>The Linux kernel provides a simple and efficient map data structure for one specific use case: mapping a unique identification number (UID) to a pointer. It is called <code>idr</code>.</p>
<p>One common data structure often implemented in individual
source files is the hash table. Because a hash table is little more than some buckets and a
hash function, and the hash function is so specific to each use case, there is little value in
providing a kernelwide solution in a nongeneric programming language such as C.</p>
<h2 id="binary-tree">Binary Tree</h2>
<p>Linux’s primary binary tree data structure is the red-black tree. Red-black trees remain semi-balanced by enforcing that the following six properties remain true:</p>
<ol>
<li>All nodes are either red or black.</li>
<li>Leaf nodes are black.</li>
<li>Leaf nodes do not contain data.</li>
<li>All non-leaf nodes have two children.</li>
<li>If a node is red, both of its children are black.</li>
<li>The path from a node to one of its leaves contains the same number of black nodes as the shortest path to any of its other leaves.</li>
</ol>
<p>Taken together, these properties ensure that the deepest leaf has a depth of no more
than double that of the shallowest leaf.</p>
<p>The Linux implementation of red-black trees is called rbtrees.They are defined in <code>lib/rbtree.c</code> and declared in &lt;linux/rbtree.h&gt;.</p>
<p>The root of an rbtree is represented by the <code>rb_root</code> structure. To create a new tree, we
allocate a new <code>rb_root</code> and initialize it to the special value <code>RB_ROOT</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">root</span> =</span> RB_ROOT;
</div></code></pre>
<p>Individual nodes in an rbtree are represented by the <code>rb_node</code> structure.</p>
<p>The rbtree implementation does not provide search and insert routines. Users of
rbtrees are expected to define their own.This is because C does not make generic programming
easy, and the Linux kernel developers believed this is the most efficient way.</p>
<p>The following function implements a search of Linux’s page cache for a chunk of a file (represented by an inode and offset pair). Each inode has its own rbtree, keyed from page offsets to file.This function thus searches the given inode’s rbtree for a matching offset value:</p>
<pre><code class="language-C++"><div><span class="hljs-function">struct page * <span class="hljs-title">rb_search_page_cache</span><span class="hljs-params">(struct inode *inode,
                                    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> offset)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">n</span> =</span> inode-&gt;i_rb_page_cache.rb_node;
    <span class="hljs-keyword">while</span> (n) {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-built_in">rb_entry</span>(n, struct page, rb_page_cache);
        <span class="hljs-keyword">if</span> (offset &lt; page-&gt;offset)
            n = n-&gt;rb_left;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset &gt; page-&gt;offset)
            n = n-&gt;rb_right;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> page;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
</div></code></pre>
<p>Insert example:</p>
<pre><code class="language-C++"><div><span class="hljs-function">struct page * <span class="hljs-title">rb_insert_page_cache</span><span class="hljs-params">(struct inode *inode,
                                    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> offset,
                                    struct rb_node *node)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> **<span class="hljs-title">p</span> =</span> &amp;inode-&gt;i_rb_page_cache.rb_node;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">parent</span> =</span> <span class="hljs-literal">NULL</span>;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span>
    
    <span class="hljs-keyword">while</span> (*p) {
        parent = *p;
        page = <span class="hljs-built_in">rb_entry</span>(parent, struct page, rb_page_cache);
        <span class="hljs-keyword">if</span> (offset &lt; page-&gt;offset)
            p = &amp;(*p)-&gt;rb_left;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset &gt; page-&gt;offset)
            p = &amp;(*p)-&gt;rb_right;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> page;
    }
    <span class="hljs-built_in">rb_link_node</span>(node, parent, p); <span class="hljs-comment">// insert the new node at the given spot.</span>
    <span class="hljs-built_in">rb_insert_color</span>(node, &amp;inode-&gt;i_rb_page_cache); <span class="hljs-comment">//perform the complicated rebalancing dance.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
</div></code></pre>
<br>
<h1 id="kernel-synchronization">Kernel Synchronization</h1>
<h2 id="preemption-disabling">Preemption Disabling</h2>
<p>Because the kernel is preemptive, a process in the kernel can stop running at any instant
to enable a process of higher priority to run.</p>
<p>To prevent this, the kernel preemption code uses spin locks as markers of nonpreemptive regions.</p>
<ul>
<li>If a spin lock is held, the kernel is not preemptive.</li>
</ul>
<p>In reality, some situations do not require a spin lock, but do need kernel preemption disabled. kernel preemption can be disabled via <code>preempt_disable()</code>.The call is nestable; you can call it any number of times. For each call, a corresponding call to <code>preempt_enable()</code> is required</p>
<p>The <code>preempt_count()</code> returns the number of held locks <em>and</em> <code>preempt_disable()</code> calls.</p>
<ul>
<li>If the number is zero, the kernel is preemptive.</li>
<li>If the value is one or greater, the kernel is not preemptive.</li>
</ul>
<p>Also refer to <a href="scheduler.html#preempt_count-kernel-internals">preempt_count-kernel-internals</a></p>
<h2 id="atomic-integer">atomic integer</h2>
<p>They are implemented on every architecture, some with native atomic operations, other with operation to lock the memory bus.</p>
<p>The atomic_t type is defined in <code>&lt;linux/types.h&gt;</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> counter;
} <span class="hljs-keyword">atomic_t</span>;
</div></code></pre>
<p>atomic_t is always 32bit even on 64-bit architectures. Instead, the atomic64_t type provides a 64-bit atomic integer</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> counter;
} <span class="hljs-keyword">atomic64_t</span>;
</div></code></pre>
<p>The declarations needed to use the atomic integer operations are in <code>&lt;asm/atomic.h&gt;</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">atomic_t</span> v; <span class="hljs-comment">/* define v */</span>
<span class="hljs-keyword">atomic_t</span> u = <span class="hljs-built_in">ATOMIC_INIT</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* define u and initialize it to zero */</span>

<span class="hljs-built_in">atomic_set</span>(&amp;v, <span class="hljs-number">4</span>); <span class="hljs-comment">/* v = 4 (atomically) */</span>
<span class="hljs-built_in">atomic_add</span>(<span class="hljs-number">2</span>, &amp;v); <span class="hljs-comment">/* v = v + 2 = 6 (atomically) */</span>
<span class="hljs-built_in">atomic_inc</span>(&amp;v); <span class="hljs-comment">/* v = v + 1 = 7 (atomically) */</span>

<span class="hljs-comment">// convert an atomic_t to an int, use atomic_read():</span>
<span class="hljs-built_in">printk</span>(“%d\n”, <span class="hljs-built_in">atomic_read</span>(&amp;v)); <span class="hljs-comment">/* will print “7” */</span>

<span class="hljs-comment">// decrements by one the given atomic value. If the result is zero, it returns true; otherwise, it returns false.</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atomic_dec_and_test</span><span class="hljs-params">(<span class="hljs-keyword">atomic_t</span> *v)</span>
</span></div></code></pre>
<p><strong>Atomic Kernel Implementation</strong></p>
<p>不同架构的处理器给出了不同的解决方法。</p>
<p>x86处理器常用的做法是给总线上锁(bus lock)，以获得在一定的时间窗口内对总线独占的授权.</p>
<p>有一些指令，比如<code>XCHG</code>，在执行时会被硬件自动/隐式地加上<code>LOCK#</code>信号，实现总线的锁定。软件也可以显示地在指令前面加上一个名为&quot;lock&quot;的前缀来达到相同的效果，锁总线的时间等于指令执行的时间。不过，并非所有的指令都可以加&quot;<strong>lock</strong>&quot;前缀，允许添加的指令包括CMPXCHG, 用于算术运算的ADD, SUB, INC, DEC，以及用于位运算的BTS, BTC等。</p>
<p>大部分的内存都是可以被cache的，根据前面文章介绍的cache一致性原理, 所以，虽然使用的是&quot;lock&quot;指令前缀，<strong>但此时总线和内存都不会被上锁</strong>，bus lock实际成了<strong>cache lock</strong>。</p>
<p>如果RMW操作的数据跨越了2个cache line，cache lock就不够了，只能是bus lock。这种跨越cache line的访问被称为&quot;split access&quot;，此时的bus lock对应地被称为&quot;<strong>split lock</strong>&quot;. 不过，非对齐的数据访问对性能影响很大（使用一次split lock会消耗大约1000个时钟周期），是应该尽量避免的。</p>
<p>来看下Linux中atomic_add()在x86上的实现：</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> <span class="hljs-title">arch_atomic_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">atomic_t</span> *v)</span>
</span>{
	<span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(LOCK_PREFIX <span class="hljs-string">&quot;addl %1,%0&quot;</span>
		     : <span class="hljs-string">&quot;+m&quot;</span> (v-&gt;counter)  <span class="hljs-comment">// input+output</span>
		     : <span class="hljs-string">&quot;ir&quot;</span> (i))</span></span>;  <span class="hljs-comment">// input</span>
}
</div></code></pre>
<p>如果CPU A和CPU B同时调用atomic_add()去给共享变量的值加1，那么只有一个CPU能成功地执行&quot;lock add&quot;这条指令，假设A成功了，B失败了，那么A随后会将该变量的值设为6，其cache line为modified状态，B对应的包含该变量的cache line则为invalid状态。接下来B将运行刚才没有获准执行的这条&quot;lock add&quot;指令，由于此时它的cache line是invalid状态，根据硬件维护的cache一致性协议，B中cache line中变量的值将变为6，并回到shared状态，B的&quot;lock add&quot;也将基于新的值(6)来做加1运算，所以最终结果就是7，不会因为竞态而出现结果的不一致。</p>
<h2 id="atomic-bitwise-operation">atomic bitwise operation</h2>
<p>bitwise functions operate on generic memory addresses. The arguments are a pointer and a bit number.
Code is defined in <code>&lt;asm/bitops.h&gt;</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> word = <span class="hljs-number">0</span>;
<span class="hljs-built_in">set_bit</span>(<span class="hljs-number">0</span>, &amp;word); <span class="hljs-comment">/* bit zero is now set (atomically) */</span>
<span class="hljs-built_in">set_bit</span>(<span class="hljs-number">1</span>, &amp;word); <span class="hljs-comment">/* bit one is now set (atomically) */</span>
<span class="hljs-built_in">printk</span>(“%ul\n”, word); <span class="hljs-comment">/* will print “3” */</span>
<span class="hljs-built_in">clear_bit</span>(<span class="hljs-number">1</span>, &amp;word); <span class="hljs-comment">/* bit one is now unset (atomically) */</span>
<span class="hljs-built_in">change_bit</span>(<span class="hljs-number">0</span>, &amp;word); <span class="hljs-comment">/* bit zero is flipped; now it is unset (atomically) */</span>
<span class="hljs-comment">/* atomically sets bit zero and returns the previous value (zero) */</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">test_and_set_bit</span>(<span class="hljs-number">0</span>, &amp;word)) {
<span class="hljs-comment">/* never true ... */</span>
}
<span class="hljs-comment">/* the following is legal; you can mix atomic bit instructions with normal C */</span>
word = <span class="hljs-number">7</span>;
</div></code></pre>
<p>Conveniently, nonatomic versions of all the bitwise functions are also provided. Their names are prefixed with double underscores. For example, the nonatomic form of <code>test_bit()</code> is <code>__test_bit()</code>.</p>
<h2 id="spin-lock">spin lock</h2>
<p>The architecturedependent code is defined in <code>&lt;asm/spinlock.h&gt;</code>. The actual interfaces are defined
in <code>&lt;linux/spinlock.h&gt;</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-built_in">DEFINE_SPINLOCK</span>(mr_lock);

<span class="hljs-built_in">spin_lock</span>(&amp;mr_lock);
<span class="hljs-comment">/* critical region ... */</span>
<span class="hljs-built_in">spin_unlock</span>(&amp;mr_lock);
</div></code></pre>
<p>Linux kernel’s spin locks are not recursive.</p>
<p>Linux spin lock calls preempt_disable(), which disables kernel preempt/scheduling. (but it doesn't disable interrupt)</p>
<pre><code class="language-C++"><div><span class="hljs-comment">// For SMP, in /include/linux/spinlock_api_smp.h</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __raw_spin_lock(<span class="hljs-keyword">raw_spinlock_t</span> *lock)
{
    <span class="hljs-built_in">preempt_disable</span>();
    ...
    <span class="hljs-built_in">LOCK_CONTENDED</span>(lock, do_raw_spin_trylock, do_raw_spin_lock);
}
<span class="hljs-comment">// For uni-processor, in /include/linux/spinlock_api_up.h</span>
<span class="hljs-comment">// 在UP的环境中，不再需要防止多个CPU对共享变量的同时访问，所以spin_lock()的作用仅仅是关闭调度，等同于（或者说退化成了）preempt_disable()。</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _raw_spin_lock(lock)  __LOCK(lock)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __LOCK(lock) \
  do { preempt_disable(); ___LOCK(lock); } while (0)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ___LOCK(lock) \
  do { __acquire(lock); (void)(lock); } while (0)</span>
</div></code></pre>
<p>Spin locks can be used in interrupt handlers (because it doesn't sleep)</p>
<ul>
<li>If a lock is used in an interrupt handler, you must also disable local interrupts on the current processor before obtaining the lock.
<ul>
<li>Otherwise, it is possible for an interrupt handler to interrupt kernel code while the lock is held and attempt to reacquire the lock. This will cause dead-lock.</li>
<li>The kernel provides an interface that conveniently disables interrupts and acquires the lock.<pre><code class="language-C++"><div><span class="hljs-built_in">DEFINE_SPINLOCK</span>(mr_lock);
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;

<span class="hljs-comment">// The routine spin_lock_irqsave() saves the current state of interrupts, disables them locally, and then obtains the given lock. It is a combination of local_irq_save() and spin_lock()</span>
<span class="hljs-built_in">spin_lock_irqsave</span>(&amp;mr_lock, flags);
<span class="hljs-comment">/* critical region ... */</span>
<span class="hljs-built_in">spin_unlock_irqrestore</span>(&amp;mr_lock, flags);
</div></code></pre>
</li>
</ul>
</li>
</ul>
<p>从程序性能的角度出发:<br></p>
<ul>
<li>
<p>在进程上下文中，</p>
<ul>
<li>对于不会和hardirq/softirq共享的变量，应该尽量使用更轻量级的spin_lock()。</li>
<li>只会和softirq共享而不会和hardirq共享的，则应该使用spin_lock_bh(), 一个spin_lock()加local_bh_disable()的二合一函数 。</li>
<li>如果hardirq和线程共享变量，需要使用spin_lock_irqsave()，这样关闭了中断，hardirq不会执行，对应的softirq就更不会执行，无疑是最安全的，但同时也是开销最大的。</li>
</ul>
</li>
<li>
<p>对于hardirq上下文，因为Linux是不支持hardirq嵌套的，在hardirq执行期间，CPU对中断的响应默认是关闭的，所以可直接使用spin_lock()。</p>
</li>
<li>
<p>至于softirq上下文，因为有可能被hardirq打断，针对会和hardirq共享的变量，需使用spin_lock_irqsave()。</p>
</li>
</ul>
<h3 id="spin-lock-kernel-implementation">Spin lock kernel Implementation</h3>
<p><strong>CAS</strong></p>
<p>基于CAS的实现速度很快，尤其是在没有真正竞态的情况下（事实上大部分时候就是这种情况）， 但这种方法存在一个缺点：它是「不公平」的。 一旦spinlock被释放，第一个能够成功执行CAS操作的CPU将成为新的owner，没有办法确保在该spinlock上等待时间最长的那个CPU优先获得锁，这将带来延迟不能确定的问题。</p>
<p><strong>Ticket Spinlock</strong></p>
<p>基于x86-64的ACRN hypervisor对于ticket spinlock的实现：</p>
<p>一个spinlock的数据结构由&quot;head&quot;和&quot;tail&quot;两个index组成。</p>
<p>一个spinlock被owner释放时，该spinlock的head值会被owner通过&quot;inc&quot;指令加1。</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">spinlock_release</span><span class="hljs-params">(<span class="hljs-keyword">spinlock_t</span> *lock)</span>
</span>{
        <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;   lock incl %[head]\n&quot;</span>   <span class="hljs-comment">// head加1</span>
          :
          : [head] <span class="hljs-string">&quot;m&quot;</span> (lock-&gt;head)
          : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span></span>;
}
</div></code></pre>
<p>其他CPU在试图获取这个spinlock时，会通过&quot;xadd&quot;指令将&quot;tail&quot;值保存在自己的eax寄存器中，然后将该spinlock的&quot;tail&quot;值加1. 接下来就是不断的循环比较，判断该spinlock当前的&quot;head&quot;值，是否和自己存储在eax寄存器中的&quot;tail&quot;值相等，相等时则获得该spinlock，成为新的owner。</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">spinlock_obtain</span><span class="hljs-params">(<span class="hljs-keyword">spinlock_t</span> *lock)</span>
</span>{	
        <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;   movl $0x1,%%eax\n&quot;</span>  <span class="hljs-comment">// eax = 1</span>
		      <span class="hljs-string">&quot;   lock xaddl %%eax,%[tail]\n&quot;</span>  <span class="hljs-comment">// eax = old tail, new tail = old tail + 1</span>
		      <span class="hljs-string">&quot;   cmpl %%eax,%[head]\n&quot;</span>  <span class="hljs-comment">// 比较eax(old tail)和head</span>
		      <span class="hljs-string">&quot;   jz 1f\n&quot;</span>  <span class="hljs-comment">// 相等，获得锁</span>
		      <span class="hljs-string">&quot;2: pause\n&quot;</span>  <span class="hljs-comment">// 不相等，继续比较</span>
		      <span class="hljs-string">&quot;   cmpl %%eax,%[head]\n&quot;</span>
		      <span class="hljs-string">&quot;   jnz 2b\n&quot;</span>
		      <span class="hljs-string">&quot;1:\n&quot;</span>
		      :
		      :
		      [head] <span class="hljs-string">&quot;m&quot;</span>(lock-&gt;head),
		      [tail] <span class="hljs-string">&quot;m&quot;</span>(lock-&gt;tail)
		      : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;eax&quot;</span>)</span></span>;
}
</div></code></pre>
<p>在ticket spinlock中，&quot;compare&quot;和&quot;swap&quot;的操作就分离了。把spinlock当前的值和旧的值进行比较（compare），还是由每个试图获得spinlock的CPU来执行的，但设置新的值（swap），则是由上一个持有spinlock的CPU来完成的。</p>
<p>使用ticket spinlock可以让CPU按照到达的先后顺序，去获取spinlock的所有权，形成了「有序竞争」。</p>
<p>缺点：<br>
根据硬件维护的cache一致性协议，如果spinlock的值没有更改，那么在busy wait时，试图获取spinlock的CPU，只需要不断地读取自己包含这个spinlock变量的cache line上的值就可以了，不需要从spinlock变量所在的内存位置读取。但是，当spinlock的值被更改时，所有试图获取spinlock的CPU对应的cache line都会被invalidate，因为这些CPU会不停地读取这个spinlock的值，所以&quot;invalidate&quot;状态意味着此时，它们必须重新从内存读取新的spinlock的值到自己的cache line中。而事实上，其中只会有一个CPU，也就是队列中最先达到的那个CPU，接下来可以获得spinlock，对于其他的CPU来说，这就是做无用功。</p>
<p><strong>MCS spinlock</strong></p>
<p>在ticket spinlock的基础上进行一定的修改，让每个CPU不再是等待同一个spinlock变量，而是基于各自不同的per-CPU的变量进行等待.</p>
<p>code in <code>/kernel/locking/mcs_spinlock.h</code></p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> {</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span>;</span>
	<span class="hljs-keyword">int</span> locked; 
};
</div></code></pre>
<p>每当一个CPU试图获取一个spinlock，它就会将自己的MCS lock加到这个spinlock的等待队列，成为该队列的一个节点(node)。&quot;locked&quot;的值为1表示该CPU是spinlock当前的持有者，为0则表示没有持有。分身之后的spinlock在哪里？它就在每个MCS lock的&quot;locked&quot;域里，像波浪一样地向前推动着。&quot;locked&quot;的值为1的那个node，才是spinlock的「真身」。</p>
<p><img src="images/2022-03-03-20-35-52.png" alt="">
<img src="images/2022-03-03-22-09-56.png" alt=""></p>
<p>Details refer to: <a href="https://zhuanlan.zhihu.com/p/89058726">https://zhuanlan.zhihu.com/p/89058726</a></p>
<p>缺点：<br>
MCS lock的实现保留在了Linux的代码中，but it is not used at all!</p>
<p>因为相比起Linux中只占4个字节的ticket spinlock，MCS lock多了一个指针，要多占4（或者8）个字节，消耗的存储空间是原来的2-3倍。</p>
<p><strong>qspinlock</strong></p>
<p>在Linux中，如果针对某个处理器架构的代码没有单独定义，qspinlock将是spinlock默认的实现方式。</p>
<pre><code class="language-C++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> arch_spin_lock(l)    queued_spin_lock(l)</span>
</div></code></pre>
<p>对于设计合理的spinlock，在大多数情况下，锁的争抢都不应该太激烈。这也是qspinlock中加入&quot;pending&quot;位域的意义，如果是两个CPU试图获取锁，那么第二个CPU只需要简单地设置&quot;pending&quot;为1，而不用「另起炉灶」创建一个MCS node。</p>
<p><img src="images/2022-03-03-22-27-42.png" alt=""></p>
<p>当有3个以上的CPU试图获取锁，需要一个qspinlock加上(N-2)个MCS node。</p>
<p><img src="images/2022-03-03-22-26-58.png" alt=""></p>
<p>Details refer to: <a href="https://zhuanlan.zhihu.com/p/100546935">https://zhuanlan.zhihu.com/p/100546935</a></p>
<p>Code in <code>/include/asm-generic/qspinlock_types.h</code> and <code>/include/asm-generic/qspinlock.h</code></p>
<h2 id="read-write-spin-lock">read-write spin lock</h2>
<p>Writer starve problem.</p>
<p>现在的内核开发已经不建议再使用rwlock了，之前的Linux代码中使用到的rwlock也在逐渐被移除，或者替换为普通的spinlock或者RCU。</p>
<h2 id="seq-lock">seq lock</h2>
<p>It provides a simple mechanism for reading and writing shared data.</p>
<p>defined in <code>/include/linux/seqlock.h</code></p>
<pre><code class="language-C++"><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seqcount</span> <span class="hljs-title">seqcount</span>;</span>
	<span class="hljs-keyword">spinlock_t</span> lock;
} <span class="hljs-keyword">seqlock_t</span>;
</div></code></pre>
<p>Writer:</p>
<ul>
<li>每当有writter持有seqlock之后，sequence number的值就会加1; 当writer释放seqlock之前，sequence number的值会再次加1.</li>
<li>sequence number的初始值是一个偶数(even)，当writer持有spinlock时，sequence number的值将是一个奇数(odd)，释放后则又变成偶数。</li>
</ul>
<p>reader:</p>
<ul>
<li>reader在读取一个共享变量之前，需要先读取一下sequence number的值，如果为奇数，说明现在有writer正在修改这个变量，需要等待，直到sequence number变为偶数，才可以开始读取变量。</li>
<li>读取变量之后，reader需要再次读取一下sequence number的值，并和读取之前的sequence number的值进行比较，看是否相等，相等则说明在此期间没有writer的操作。</li>
</ul>
<p>Seq locks are ideal when your locking needs meet most or all these requirements:</p>
<ul>
<li>Your data has a lot of readers.</li>
<li>Your data has few writers.</li>
<li>Although few in number, you want to favor writers over readers and never allow readers to starve writers.
<ul>
<li>This also means readers need to spin-wait while writer is doing the write.</li>
</ul>
</li>
</ul>
<p>在Linux中的一个重要应用就是表示时间的jiffies（jiffies记录了系统启动后的时钟节拍的数目）。</p>
<pre><code class="language-C++"><div><span class="hljs-keyword">do</span> {
    seq = <span class="hljs-built_in">read_seqbegin</span>(&amp;jiffies_lock);
    ret = jiffies_64;
} <span class="hljs-keyword">while</span> (<span class="hljs-built_in">read_seqretry</span>(&amp;jiffies_lock, seq));
</div></code></pre>
<h2 id="rcu">RCU</h2>
<p>RCU (read-copy-update) 机制是自内核2.5版本引入的（2002年10月），而后不断完善，其在Linux的locking机制中的使用占比也是逐年攀升, more than 10% in 2020.</p>
<p>RCU is most frequently described as a replacement for reader-writer locking. RCU is notable in that RCU readers do not directly synchronize with RCU updaters, which makes RCU read paths extremely fast, and also permits RCU readers to accomplish useful work even when running concurrently with RCU updaters.</p>
<ul>
<li>RCU 同 seqlock 一样，适合“读多写少”的情景（比如链表操作），更新越少，受过时数据的影响越低，就越适合使用 RCU。</li>
<li>对于 RCU 来说，天然地具有防死锁特性，所以也没有 &quot;rcu_read_lock_irqdisable()&quot; 一类的函数，因为不需要关中断，即便来了中断，在 ISR 里不管是读还是写，都可以完成后返回，不会形成死锁。</li>
</ul>
<p><strong>API</strong></p>
<ul>
<li><code>rcu_read_lock()</code>/ <code>rcu_read_unlock()</code>: Used by a reader to inform the reclaimer that the reader is entering an RCU read-side critical section. It is illegal to block while in an RCU read-side critical section.Conceptually just to disable preempt, no lock used here.</li>
<li><code>synchronize_rcu()</code>: Marks the end of updater code and the beginning of reclaimer code. It wait for any currently executing RCU read-side critical sections to complete. The length of this wait is known as a &quot;<em>grace period</em>&quot;.
<ul>
<li><code>call_rcu()</code>: The asynchronous, callback form of <code>synchronize_rcu()</code>, Instead of blocking, it registers a function and argument which are invoked after the grace period.</li>
</ul>
</li>
<li><code>rcu_assign_pointer()</code>: The updater uses this function to assign a new value to an RCU-protected pointer, it executes a memory-barrier instruction.
<ul>
<li><code>rcu_assign_pointer()</code> is most frequently used indirectly, via the rcu list-manipulation primitives such as <code>list_add_rcu()</code>.</li>
</ul>
</li>
<li><code>rcu_dereference</code>: The reader uses rcu_dereference() to fetch an RCU-protected pointer, which returns a value that may then be safely dereferenced <em>before</em> the critical section ends.</li>
</ul>
<p><img src="images/2022-03-04-09-44-42.png" alt=""></p>
<p>以链表的&quot;replace&quot;操作为例:</p>
<ul>
<li>
<p>作为<strong>updater</strong>，在对copy的数据更新完成后，需要通过<code>rcu_assign_pointer()</code>，用这个copy替换原节点在链表中的位置，并移除对原节点的引用，而后调用<code>synchronize_rcu()</code>或<code>call_rcu()</code>进入grace period。因为<code>synchronize_rcu()</code>会阻塞等待，所以只能在进程上下文中使用，而<code>call_rcu()</code>可在中断上下文中使用。</p>
</li>
<li>
<p>作为<strong>reader</strong>，在调用<code>rcu_read_lock()</code>进入临界区后，因为所使用的节点可能被updater解除引用，因而需要通过<code>rcu_dereference()</code>保留一份对这个节点的指针指向。进入grace period意味着数据已经更新，而这些reader在退出临界区之前，只能使用旧的数据，也就是说，它们需要暂时忍受“过时”的数据，不过这在很多情况下是没有多大影响的。</p>
</li>
<li>
<p>作为<strong>reclaimer</strong>，对于所有进入grace period之前就进入临界区的reader，需要等待它们都调用了<code>rcu_read_unlock()</code>退出临界区，之后grace period结束，原节点所在的内存区域被释放。</p>
</li>
</ul>
<h3 id="srcu-sleepable-rcu">SRCU (Sleepable RCU)</h3>
<p>传统的 RCU，它对读取一侧的临界区的要求同 spinlock 一样，不能睡眠/阻塞。如果允许读取一侧临界区的睡眠，那 GP 可能会变得很长/不能结束，那作为 writer 就不能释放旧数据所占据的内存资源, 甚至有内存耗尽的风险。但是对于可抢占的内核，从实时性的角度，“不能调度”将可能导致高优先级的任务被低优先级的任务阻塞，得不到执行。</p>
<p>&quot;sleepable RCU&quot;(SRCU)着力点主要是如何减少需要等待 GP 后才能释放的内存总量。</p>
<ul>
<li>SRCU 摒弃了异步的 call_rcu()，因为使用这个 API 的线程，理论上可以产生大量等待 GP 结束后释放的内存，而使用同步的 synchronize_rcu() 的线程，最多产生一个。SRCU 提供的对应API是 synchronize_srcu()。</li>
<li>如果系统中 CPU 数量较多，那么一个 reader 在临界区的阻塞可能影响众多的CPU，所以 SRCU 将整个系统进行了细分，划分为若干个 subsystem。这样，一个 reader 只会影响和它同属一个 subsystem 的其他 CPU。</li>
</ul>
<p>SRCU 和 Preemptible RCU 都允许临界区内的抢占，因而不能通过线程切换来判断临界区的结束，而是需要在进入/退出临界区时加/减一个 counter，借助 counter 的值来判断是否已退出。</p>
<p>reference: <a href="https://lwn.net/Articles/253651/">https://lwn.net/Articles/253651/</a></p>
<h2 id="mutexes">mutexes</h2>
<p>defined in <code>include/linux/mutex.h</code></p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> {</span>
    <span class="hljs-keyword">atomic_long_t</span>      owner;
    <span class="hljs-keyword">spinlock_t</span>         wait_lock;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>   <span class="hljs-title">wait_list</span>;</span>
};
</div></code></pre>
<p>it includes</p>
<ul>
<li>a spinlock (<code>wait_lock</code>)</li>
<li>a wait-queue (<code>wait_list</code>)</li>
<li>Field <code>owner</code> contains '<code>struct task_struct *</code>' to the current lock owner. Since task_struct pointers are aligned at at least L1_CACHE_BYTES, low bits (3) are used to store extra state (e.g.,if <code>wait_list</code> is non-empty).</li>
<li>a spinner MCS spinlock, called <code>osq</code></li>
</ul>
<p>When acquiring a mutex, there are three possible paths that can be
taken, depending on the state of the lock:</p>
<ol>
<li>
<p><strong>fastpath</strong>: tries to atomically acquire the lock by <code>cmpxchg()</code>ing the owner with
the current task. This only works in the uncontended case (cmpxchg() checks
against 0UL, so all 3 state bits above have to be 0). If the lock is
contended it goes to the next possible path.</p>
</li>
<li>
<p><strong>midpath</strong>: aka <em>optimistic spinning</em>, tries to spin for acquisition
while the lock owner is running and there are no other tasks ready
to run that have higher priority (<code>need_resched</code>). The rationale is
that if the lock owner is running, it is likely to release the lock
soon. The mutex <em>spinners</em> are queued up using MCS lock so that only
one spinner can compete for the mutex. <code>CONFIG_MUTEX_SPIN_ON_OWNER</code> kernel config needs to be set to enable spinner.</p>
<p>An important feature of the customized
MCS lock is that spinners are able to exit
the MCS spinlock queue when they need to reschedule. This enables MCS spinners that need to reschedule  to go directly to slowpath upon
obtaining the MCS lock.</p>
<p>Another behavior is if the lock owner is preempted during critical section, then the spinners are moved to wait_list and block.</p>
</li>
<li>
<p><strong>slowpath</strong>: last resort, if the lock is still unable to be acquired,
the task is added to the wait-queue and sleeps until woken up by the
unlock path. This is called <em>waiter</em>. Under normal circumstances it blocks as TASK_INTERRUPTIBLE.</p>
</li>
</ol>
<p><img src="images/2022-03-04-22-01-35.png" alt=""></p>
<p><strong>overly-optimistic spinning issue</strong></p>
<p>That optimistic spinning allows the transfer of the mutex without going through a sleep/wakeup cycle, and, importantly, it gives the mutex to a running (and, thus, cache-hot) thread. The result is an unfair, but better-performing mutex implementation. In the worst case though, an unlucky thread contending for a highly contended mutex could be starved for a long time.</p>
<p>The solution is: If the ownership of a mutex changes while a thread is spinning, that means that mutex was released and somebody else grabbed it first. In other words, there is heavy contention and multiple CPUs are spinning in a race. In such cases, it makes sense to just go to sleep and wait until things calm down a bit.</p>
<h3 id="linux-spinlock-vs-mutex">Linux spinlock vs mutex</h3>
<p>spinlock的开销在于暂时获取不到锁时，对所在CPU的持续占有，而传统的mutex的开销则在于释放CPU和重新获取CPU所带来的上下文切换。不过，现在的mutex设计已经通过optimistic spinning糅合了spinlock的行为，在资源不足时是否主动让出CPU已经不再构成两者真正的区别。</p>
<p>两者语义上的差异（或者说spinlock和mutex能同时存在的原因）是在线程试图获取和持有spinlock期间，调度都是关闭的，因而要求临界区的执行时间必须较短。相比而言，使用mutex的限制条件更加宽松。如果支持的操作可能会导致睡眠，比如<code>copy_from_user()</code>或者<code>kmalloc(GFP_KERNEL)</code>，则只能使用mutex。</p>
<h2 id="semaphores">Semaphores</h2>
<p>In Linux, Semaphore definitions is similar to mutex</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> {</span>
    <span class="hljs-keyword">raw_spinlock_t</span>    lock;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>      count;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>  <span class="hljs-title">wait_list</span>;</span>
};
</div></code></pre>
<p>semaphore是没有&quot;owner&quot;的，它只需要一个标识共享资源数目的&quot;count&quot;，因而也被称为counting semaphore。</p>
<p><img src="images/2022-03-04-22-48-50.png" alt=""></p>
<p>获取semaphore</p>
<ul>
<li>只要&quot;count&quot;的值大于0，线程获取semaphore就可以成功。&quot;count&quot;值减1，所以其函数名为<code>down()</code>。因为可能进入休眠等待，不能被signal打断，所有一般调用<code>down_interruptible()</code>。</li>
<li>如果count的值小于或等于0，说明当前进入临界区的线程数目已满，那么新的线程只能加入&quot;wait_list&quot;等待队列，进入休眠态。</li>
</ul>
<p>释放semaphore</p>
<ul>
<li>如果等待队列为空，释放semaphore会使可进入临界区的线程的数目增加（对应count值加1），反之则需要唤醒等待队列中的第一个waiter线程。使用<code>up()</code>即可（因为释放semaphore不会进入睡眠等待）</li>
</ul>
<h3 id="linux-mutex-vs-semaphore">Linux Mutex vs Semaphore</h3>
<p>从某种意义上来说，mutex可以被视作是一种&quot;count&quot;值只能为0和1的特殊semaphore，也就是binary semaphore(二值信号量)。但严格地来将，mutex和binary semaphore还是存在一些区别的。</p>
<p>semaphore已经不能算是一种锁了，对于像mutex这样真正的锁，必须遵循“解铃还须系铃人”的原则，也就是“谁占有谁释放”。这在一定程度上限制了mutex的使用，比如一些内核和用户空间之间的交互，但同时也更不容易出错。</p>
<h2 id="completion-variables">completion variables</h2>
<p>synchronization between two tasks in the kernel when one task needs to signal to the other that an event has occurred.</p>
<ul>
<li>For example, the vfork() system call uses completion variables to wake up the parent process when the child process execs or exits.</li>
<li>For sample usages of completion variables, see <code>kernel/sched.c</code> and <code>kernel/fork.c</code>.</li>
<li>A common usage is to have a completion variable dynamically created as a member of a
data structure. Kernel code waiting for the initialization of the data structure calls
<code>wait_for_completion()</code>. When the initialization is complete, the waiting tasks are awakened
via a call to <code>completion()</code>.</li>
</ul>
<p>Completion variables are represented by the <code>struct completion</code> type, which is defined
in <code>&lt;linux/completion.h&gt;</code>.</p>
<pre><code class="language-C++"><div><span class="hljs-built_in">init_completion</span>(struct completion *) <span class="hljs-comment">//Initializes the given dynamically created completion variable</span>
<span class="hljs-built_in">wait_for_completion</span>(struct completion *) <span class="hljs-comment">// Waits for the given completion variable to be signaled</span>
<span class="hljs-built_in">complete</span>(struct completion *) <span class="hljs-comment">// Signals any waiting tasks to wake up</span>
</div></code></pre>
<h2 id="memory-barriers">Memory Barriers</h2>
<p>对于那些没有这种依赖关系的指令，CPU可以进行reorder优化。在x86中，对于同一CPU执行的load指令后接load指令（L-L），store指令后接store指令（S-S），load指令后接store指令（L-S），都是不能交换指令的执行顺序的，只有store指令后接load指令（S-L）时才可以</p>
<p><img src="images/2022-03-03-19-43-41.png" alt=""></p>
<p>这可以理解为是“读”的优先级比“写”高，所以&quot;load&quot;可以跑到&quot;store&quot;前面去执行，而其他的三种情况，要么优先级相同，要么后面的一条指令的优先级更低。</p>
<p>CPU的reorder优化会导致指令的内存访问顺序与我们程序设定的顺序(program order)不一致，如果我们不希望CPU对一段指令进行reorder，就需要使用memory barrier。</p>
<p>Memory barriers在约束CPU行为的同时，也约束了编译器的行为，CPU都不敢reorder，编译器就更别想了，可以理解为memory barrier里隐含了compiler barrier的语义。</p>
<p>x86中用于设置&quot;full memory barrier&quot;的指令是<code>fence</code>。还提供了设置&quot;write memory barrier&quot;的<code>sfence</code>指令和设置&quot;read memory barrier&quot;的<code>lfence</code>指令。</p>
<p>Linux中提供的设置full/write/read memory barrier的API分别是<code>mb()</code>, <code>wmb()</code>和<code>rwb()</code>。</p>
<p>The <strong><code>rmb()</code></strong> method provides a read memory barrier. It ensures that no loads are reordered
across the <code>rmb()</code> call.That is, no loads prior to the call will be reordered to after
the call, and no loads after the call will be reordered to before the call.</p>
<p>The <strong><code>wmb()</code></strong> method provides a write barrier. It functions in the same manner as rmb() for stores.</p>
<ul>
<li>if a machine does not perform out-of-order stores (for example, Intel x86 processors do
not), wmb() does nothing.</li>
</ul>
<p>The <strong><code>mb()</code></strong> call provides both a read barrier and a write barrier. No loads or stores will
be reordered across a call to <code>mb()</code>.</p>
<h2 id="compiler-barrier">compiler barrier</h2>
<p>The <code>barrier()</code> method prevents the compiler barrier from optimizing loads or stores across
the call. The previous memory barriers also function as compiler barriers, but a compiler barrier is much lighter in weight than a memory barrier.</p>
<p>它对应gcc的实现是这样的（定义在include/linux/compiler-gcc.h）：</p>
<pre><code class="language-C++"><div><span class="hljs-comment">/* The &quot;volatile&quot; is due to gcc bugs */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> barrier() __asm__ __volatile__(<span class="hljs-meta-string">&quot;&quot;</span>: : :<span class="hljs-meta-string">&quot;memory&quot;</span>)</span>
</div></code></pre>
<p>它利用了末尾clobber list里的&quot;memory&quot;，clober list是gcc和gas(GNU Assembler)的接口，用于gas通知gcc它对寄存器和memory的修改情况。这里的&quot;memory&quot;就是告知gcc，在汇编代码中，我修改了内存中的内容，之前的C代码块和之后的C代码块看到的内存是不一样的，对内存的访问不能依赖于嵌入汇编之前的C代码块中寄存器的内容，所以乖乖地重新从内存读数据吧。</p>
<p>需要注意的是，barrier()只会对编译器的行为产生约束，它不会生成真正的指令，因此对最终CPU的指令执行没有影响。</p>
<h2 id="bkl-the-big-kernel-lock">BKL: The big kernel lock</h2>
<p><em>Linux BLK is fully removed in kernel 2.6.39!</em></p>
<p>a global spin recurisve lock that was created to ease the transition from Linux’s original SMP implementation to fine-grained locking</p>
<br>
<h1 id="timer-related">Timer related</h1>
<h2 id="the-time-of-day">The time of Day</h2>
<p>The current time of day (the wall time) is defined in <code>&lt;kernel/time/timekeeping.c&gt;</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">xtime</span>;</span>
</div></code></pre>
<p>The timespec data structure is defined in &lt;linux/time.h&gt; as:</p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> {</span>
    <span class="hljs-keyword">__kernel_time_t</span> tv_sec; <span class="hljs-comment">/* seconds */</span>
    <span class="hljs-keyword">long</span> tv_nsec; <span class="hljs-comment">/* nanoseconds */</span>
};
</div></code></pre>
<p>Reading or writing the xtime variable requires the xtime_lock lock, which is a seqlock.</p>
<pre><code class="language-C++"><div><span class="hljs-comment">//To update xtime, a write seqlock is required:</span>
<span class="hljs-built_in">write_seqlock</span>(&amp;xtime_lock);
<span class="hljs-comment">/* update xtime ... */</span>
<span class="hljs-built_in">write_sequnlock</span>(&amp;xtime_lock);

<span class="hljs-comment">// Reading xtime requires the use of the read_seqbegin() and read_seqretry() functions:</span>
<span class="hljs-comment">// This loop repeats until the reader is assured that it read the data without an intervening write</span>
<span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> lost;
    seq = <span class="hljs-built_in">read_seqbegin</span>(&amp;xtime_lock);
    usec = timer-&gt;<span class="hljs-built_in">get_offset</span>();
    lost = jiffies - wall_jiffies;
    <span class="hljs-keyword">if</span> (lost)
        usec += lost * (<span class="hljs-number">1000000</span> / HZ);
    sec = xtime.tv_sec;
    usec += (xtime.tv_nsec / <span class="hljs-number">1000</span>);
} <span class="hljs-keyword">while</span> (<span class="hljs-built_in">read_seqretry</span>(&amp;xtime_lock, seq));
</div></code></pre>
<p>The primary user-space interface for retrieving the wall time is <code>gettimeofday()</code>, which is implemented as <code>sys_gettimeofday()</code> in <code>kernel/time.c</code>:</p>
<pre><code class="language-C++"><div><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_gettimeofday</span><span class="hljs-params">(struct timeval *tv, struct timezone *tz)</span>
</span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">likely</span>(tv)) {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">ktv</span>;</span>
        <span class="hljs-built_in">do_gettimeofday</span>(&amp;ktv);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(tv, &amp;ktv, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ktv)))
            <span class="hljs-keyword">return</span> -EFAULT;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(tz)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(tz, &amp;sys_tz, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sys_tz)))
            <span class="hljs-keyword">return</span> -EFAULT;
        }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>The settimeofday() system call sets the wall time to the specified value. It requires the CAP_SYS_TIME capability.</p>
<p>The kernel also implements the time() system call, but gettimeofday()largely supersedes it.</p>
<p>The C library also provides other wall time–related library calls, such as ftime()and ctime().</p>
<h2 id="timers">Timers</h2>
<p>Timers, sometimes called dynamic timers or kernel timers. Kernel code often needs to delay execution of some function until a later time.</p>
<p>A timer is easy to use. You perform some initial setup, specify an expiration time, specify a function to execute upon said expiration, and activate the timer. The given function runs after the timer expires.</p>
<ul>
<li>The timer is destroyed after it expires. (one-time use)</li>
<li>Timers are constantly created and destroyed, and there is no limit on the number of timers.</li>
</ul>
<p><strong>timer wheels</strong></p>
<p>Timers are stored in a linked list. However, it would be unwieldy for the kernel to either constantly traverse the entire list looking for expired timers (O(N) lookup), or keep the list sorted by expiration value (O(N) insertion). If it is put in rbtree, insertion will be O(log(N)).</p>
<p>Instead, the kernel partitions timers into five groups based on their expiration value</p>
<ul>
<li>5 group: 1..256, 257..16384, 16385..1048576, 1048577..67108864, 67108865..4294967295.</li>
<li>the buckets of each group are put into a per-group fixed-size array, called the &quot;timer vector&quot; - named tv1, tv2, tv3, tv4 and tv5.</li>
<li>tv1 consists of 256 buckets (each bucket representing a single jiffy). This array is indexed directly by the bottom bits of a jiffies value to find the next set of events to execute.</li>
<li>tv2 to tv5 each consists of 64 buckets, each bucket equally divides the category's range.</li>
<li>With 512 buckets, we map all 4294967295 future jiffies to these buckets! In other words: we've split up the 32 bits of 'timeout' value into 8+6+6+6+6 bits.</li>
</ul>
<p>Timers move down through the groups as their expiration time draws closer. The partitioning ensures that the kernel has to do little work to find the expired timers.</p>
<ul>
<li>first 256 jiffies is O(1) expiry check</li>
<li>At jiffy 257: it 'cascades' the first bucket of the tv2 'down into' the first 256 buckets.</li>
<li>In general: the expiry code keeps a persistent running index for every group, and if that index &quot;overflows&quot; back to 1, it increments the next category's index by one and 'cascades down' timers from that bucket into the previous group.</li>
<li>all timers will end up fully sorted, and average per-timer expiry overhead is still O(1)! Because we process every timer at most 5 times. But expiry worst-case is not bounded, it is O(N) because of the cascade down effect.</li>
</ul>
<p><img src="images/2022-03-04-23-33-52.png" alt=""></p>
<p>Timers are represented by struct timer_list, which is defined in <code>&lt;linux/timer.h&gt;</code>, most operations are defined here and <code>&lt;linux/timer.c&gt;</code></p>
<pre><code class="language-C++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span> <span class="hljs-comment">/* entry in linked list of timers */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> expires; <span class="hljs-comment">/* expiration value, in jiffies */</span>
    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*function)(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>); <span class="hljs-comment">/* the timer handler function */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data; <span class="hljs-comment">/* lone argument to the handler */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tvec_t_base_s</span> *<span class="hljs-title">base</span>;</span> <span class="hljs-comment">/* internal timer field, do not touch */</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">my_timer</span>;</span>
<span class="hljs-built_in">init_timer</span>(&amp;my_timer);

<span class="hljs-comment">// Now you fill out the remaining values as required:</span>
my_timer.expires = jiffies + delay; <span class="hljs-comment">/* timer expires in delay ticks */</span>
my_timer.data = <span class="hljs-number">0</span>; <span class="hljs-comment">/* zero (or any other value) is passed to the timer handler */</span>
my_timer.function = my_function; <span class="hljs-comment">/* function to run when timer expires */</span>
</div></code></pre>
<p>The <code>my_timer.expires</code> value specifies the timeout value in absolute ticks. When the current jiffies count is equal to or greater than <code>my_timer.expires</code>, the handler function my_timer.function is run with the lone argument of <code>my_timer.data</code>.</p>
<p>The kernel <strong>executes timers in bottom-half context as softirqs</strong>, after the timer interrupt completes. The timer interrupt handler runs update_process_times(), which calls run_local_timers():</p>
<pre><code class="language-C++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run_local_timers</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-built_in">hrtimer_run_queues</span>();
    <span class="hljs-built_in">raise_softirq</span>(TIMER_SOFTIRQ); <span class="hljs-comment">/* raise the timer softirq */</span>
    <span class="hljs-built_in">softlockup_tick</span>();
}
</div></code></pre>
<p><strong>Schedule_time()</strong></p>
<p>This call puts your task to sleep until at least the specified time has elapsed. When the specified time has elapsed, the kernel wakes the task up and places it back on the runqueue.</p>
<ul>
<li>There is no guarantee that the sleep duration will be exactly the specified time—only that the duration is at least at long as specified.</li>
</ul>
<p>It is implemented based on kernel timers.</p>
<p>Usage is easy:</p>
<pre><code class="language-C++"><div><span class="hljs-comment">/* set task’s state to interruptible sleep */</span>
<span class="hljs-built_in">set_current_state</span>(TASK_INTERRUPTIBLE);
<span class="hljs-comment">/* take a nap and wake up in “s” seconds */</span>
<span class="hljs-built_in">schedule_timeout</span>(s * HZ);
</div></code></pre>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>